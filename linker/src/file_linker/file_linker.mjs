import { AstObject } from '../ast/ast_value';
import { EmitScope } from './emit_scopes/emit_scope';
import { IifeEmitScope } from './emit_scopes/iife_emit_scope';
import { createLinkerMap, PartialLinkerSelector } from './partial_linkers/partial_linker_selector';
export const NO_STATEMENTS = [];
/**
 * This class is responsible for linking all the partial declarations found in a single file.
 */
export class FileLinker {
    constructor(linkerEnvironment, sourceUrl, code) {
        this.linkerEnvironment = linkerEnvironment;
        this.emitScopes = new Map();
        this.linkerSelector = new PartialLinkerSelector(createLinkerMap(this.linkerEnvironment, sourceUrl, code), this.linkerEnvironment.logger, this.linkerEnvironment.options.unknownDeclarationVersionHandling);
    }
    /**
     * Return true if the given callee name matches a partial declaration that can be linked.
     */
    isPartialDeclaration(calleeName) {
        return this.linkerSelector.supportsDeclaration(calleeName);
    }
    /**
     * Link the metadata extracted from the args of a call to a partial declaration function.
     *
     * The `declarationScope` is used to determine the scope and strategy of emission of the linked
     * definition and any shared constant statements.
     *
     * @param declarationFn the name of the function used to declare the partial declaration - e.g.
     *     `ɵɵngDeclareDirective`.
     * @param args the arguments passed to the declaration function, should be a single object that
     *     corresponds to the `R3DeclareDirectiveMetadata` or `R3DeclareComponentMetadata` interfaces.
     * @param declarationScope the scope that contains this call to the declaration function.
     */
    linkPartialDeclaration(declarationFn, args, declarationScope) {
        if (args.length !== 1) {
            throw new Error(`Invalid function call: It should have only a single object literal argument, but contained ${args.length}.`);
        }
        const metaObj = AstObject.parse(args[0], this.linkerEnvironment.host);
        const ngImport = metaObj.getNode('ngImport');
        const emitScope = this.getEmitScope(ngImport, declarationScope);
        const minVersion = metaObj.getString('minVersion');
        const version = metaObj.getString('version');
        const linker = this.linkerSelector.getLinker(declarationFn, minVersion, version);
        const definition = linker.linkPartialDeclaration(emitScope.constantPool, metaObj);
        return emitScope.translateDefinition(definition);
    }
    /**
     * Return all the shared constant statements and their associated constant scope references, so
     * that they can be inserted into the source code.
     */
    getConstantStatements() {
        const results = [];
        for (const [constantScope, emitScope] of this.emitScopes.entries()) {
            const statements = emitScope.getConstantStatements();
            results.push({ constantScope, statements });
        }
        return results;
    }
    getEmitScope(ngImport, declarationScope) {
        const constantScope = declarationScope.getConstantScopeRef(ngImport);
        if (constantScope === null) {
            // There is no constant scope so we will emit extra statements into the definition IIFE.
            return new IifeEmitScope(ngImport, this.linkerEnvironment.translator, this.linkerEnvironment.factory);
        }
        if (!this.emitScopes.has(constantScope)) {
            this.emitScopes.set(constantScope, new EmitScope(ngImport, this.linkerEnvironment.translator));
        }
        return this.emitScopes.get(constantScope);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV9saW5rZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbGlua2VyL3NyYy9maWxlX2xpbmtlci9maWxlX2xpbmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFTQSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFFM0MsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBQ25ELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSwrQkFBK0IsQ0FBQztBQUU1RCxPQUFPLEVBQUMsZUFBZSxFQUFFLHFCQUFxQixFQUFDLE1BQU0sMkNBQTJDLENBQUM7QUFFakcsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFvQixFQUFXLENBQUM7QUFFMUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sVUFBVTtJQUlyQixZQUNZLGlCQUE2RCxFQUNyRSxTQUF5QixFQUFFLElBQVk7UUFEL0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUE0QztRQUhqRSxlQUFVLEdBQUcsSUFBSSxHQUFHLEVBQXNELENBQUM7UUFLakYsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLHFCQUFxQixDQUMzQyxlQUFlLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUN2RixJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsb0JBQW9CLENBQUMsVUFBa0I7UUFDckMsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILHNCQUFzQixDQUNsQixhQUFxQixFQUFFLElBQW1CLEVBQzFDLGdCQUErRDtRQUNqRSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQ1gsOEZBQ0ksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDekI7UUFFRCxNQUFNLE9BQU8sR0FDVCxTQUFTLENBQUMsS0FBSyxDQUFvQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdGLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0MsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUVoRSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ25ELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0MsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqRixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsc0JBQXNCLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVsRixPQUFPLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gscUJBQXFCO1FBQ25CLE1BQU0sT0FBTyxHQUFnRSxFQUFFLENBQUM7UUFDaEYsS0FBSyxNQUFNLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDbEUsTUFBTSxVQUFVLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFDckQsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFDLGFBQWEsRUFBRSxVQUFVLEVBQUMsQ0FBQyxDQUFDO1NBQzNDO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVPLFlBQVksQ0FDaEIsUUFBcUIsRUFBRSxnQkFBK0Q7UUFFeEYsTUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckUsSUFBSSxhQUFhLEtBQUssSUFBSSxFQUFFO1lBQzFCLHdGQUF3RjtZQUN4RixPQUFPLElBQUksYUFBYSxDQUNwQixRQUFRLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDbEY7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDdkMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQ2YsYUFBYSxFQUFFLElBQUksU0FBUyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUNoRjtRQUNELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFFLENBQUM7SUFDN0MsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge1IzUGFydGlhbERlY2xhcmF0aW9ufSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQge0Fic29sdXRlRnNQYXRofSBmcm9tICcuLi8uLi8uLi9zcmMvbmd0c2MvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtBc3RPYmplY3R9IGZyb20gJy4uL2FzdC9hc3RfdmFsdWUnO1xuaW1wb3J0IHtEZWNsYXJhdGlvblNjb3BlfSBmcm9tICcuL2RlY2xhcmF0aW9uX3Njb3BlJztcbmltcG9ydCB7RW1pdFNjb3BlfSBmcm9tICcuL2VtaXRfc2NvcGVzL2VtaXRfc2NvcGUnO1xuaW1wb3J0IHtJaWZlRW1pdFNjb3BlfSBmcm9tICcuL2VtaXRfc2NvcGVzL2lpZmVfZW1pdF9zY29wZSc7XG5pbXBvcnQge0xpbmtlckVudmlyb25tZW50fSBmcm9tICcuL2xpbmtlcl9lbnZpcm9ubWVudCc7XG5pbXBvcnQge2NyZWF0ZUxpbmtlck1hcCwgUGFydGlhbExpbmtlclNlbGVjdG9yfSBmcm9tICcuL3BhcnRpYWxfbGlua2Vycy9wYXJ0aWFsX2xpbmtlcl9zZWxlY3Rvcic7XG5cbmV4cG9ydCBjb25zdCBOT19TVEFURU1FTlRTOiBSZWFkb25seTxhbnlbXT4gPSBbXSBhcyBjb25zdDtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBsaW5raW5nIGFsbCB0aGUgcGFydGlhbCBkZWNsYXJhdGlvbnMgZm91bmQgaW4gYSBzaW5nbGUgZmlsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbGVMaW5rZXI8VENvbnN0YW50U2NvcGUsIFRTdGF0ZW1lbnQsIFRFeHByZXNzaW9uPiB7XG4gIHByaXZhdGUgbGlua2VyU2VsZWN0b3I6IFBhcnRpYWxMaW5rZXJTZWxlY3RvcjxURXhwcmVzc2lvbj47XG4gIHByaXZhdGUgZW1pdFNjb3BlcyA9IG5ldyBNYXA8VENvbnN0YW50U2NvcGUsIEVtaXRTY29wZTxUU3RhdGVtZW50LCBURXhwcmVzc2lvbj4+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIGxpbmtlckVudmlyb25tZW50OiBMaW5rZXJFbnZpcm9ubWVudDxUU3RhdGVtZW50LCBURXhwcmVzc2lvbj4sXG4gICAgICBzb3VyY2VVcmw6IEFic29sdXRlRnNQYXRoLCBjb2RlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxpbmtlclNlbGVjdG9yID0gbmV3IFBhcnRpYWxMaW5rZXJTZWxlY3RvcjxURXhwcmVzc2lvbj4oXG4gICAgICAgIGNyZWF0ZUxpbmtlck1hcCh0aGlzLmxpbmtlckVudmlyb25tZW50LCBzb3VyY2VVcmwsIGNvZGUpLCB0aGlzLmxpbmtlckVudmlyb25tZW50LmxvZ2dlcixcbiAgICAgICAgdGhpcy5saW5rZXJFbnZpcm9ubWVudC5vcHRpb25zLnVua25vd25EZWNsYXJhdGlvblZlcnNpb25IYW5kbGluZyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGNhbGxlZSBuYW1lIG1hdGNoZXMgYSBwYXJ0aWFsIGRlY2xhcmF0aW9uIHRoYXQgY2FuIGJlIGxpbmtlZC5cbiAgICovXG4gIGlzUGFydGlhbERlY2xhcmF0aW9uKGNhbGxlZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxpbmtlclNlbGVjdG9yLnN1cHBvcnRzRGVjbGFyYXRpb24oY2FsbGVlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogTGluayB0aGUgbWV0YWRhdGEgZXh0cmFjdGVkIGZyb20gdGhlIGFyZ3Mgb2YgYSBjYWxsIHRvIGEgcGFydGlhbCBkZWNsYXJhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogVGhlIGBkZWNsYXJhdGlvblNjb3BlYCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2NvcGUgYW5kIHN0cmF0ZWd5IG9mIGVtaXNzaW9uIG9mIHRoZSBsaW5rZWRcbiAgICogZGVmaW5pdGlvbiBhbmQgYW55IHNoYXJlZCBjb25zdGFudCBzdGF0ZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gZGVjbGFyYXRpb25GbiB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdXNlZCB0byBkZWNsYXJlIHRoZSBwYXJ0aWFsIGRlY2xhcmF0aW9uIC0gZS5nLlxuICAgKiAgICAgYMm1ybVuZ0RlY2xhcmVEaXJlY3RpdmVgLlxuICAgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZGVjbGFyYXRpb24gZnVuY3Rpb24sIHNob3VsZCBiZSBhIHNpbmdsZSBvYmplY3QgdGhhdFxuICAgKiAgICAgY29ycmVzcG9uZHMgdG8gdGhlIGBSM0RlY2xhcmVEaXJlY3RpdmVNZXRhZGF0YWAgb3IgYFIzRGVjbGFyZUNvbXBvbmVudE1ldGFkYXRhYCBpbnRlcmZhY2VzLlxuICAgKiBAcGFyYW0gZGVjbGFyYXRpb25TY29wZSB0aGUgc2NvcGUgdGhhdCBjb250YWlucyB0aGlzIGNhbGwgdG8gdGhlIGRlY2xhcmF0aW9uIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlua1BhcnRpYWxEZWNsYXJhdGlvbihcbiAgICAgIGRlY2xhcmF0aW9uRm46IHN0cmluZywgYXJnczogVEV4cHJlc3Npb25bXSxcbiAgICAgIGRlY2xhcmF0aW9uU2NvcGU6IERlY2xhcmF0aW9uU2NvcGU8VENvbnN0YW50U2NvcGUsIFRFeHByZXNzaW9uPik6IFRFeHByZXNzaW9uIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBmdW5jdGlvbiBjYWxsOiBJdCBzaG91bGQgaGF2ZSBvbmx5IGEgc2luZ2xlIG9iamVjdCBsaXRlcmFsIGFyZ3VtZW50LCBidXQgY29udGFpbmVkICR7XG4gICAgICAgICAgICAgIGFyZ3MubGVuZ3RofS5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhT2JqID1cbiAgICAgICAgQXN0T2JqZWN0LnBhcnNlPFIzUGFydGlhbERlY2xhcmF0aW9uLCBURXhwcmVzc2lvbj4oYXJnc1swXSwgdGhpcy5saW5rZXJFbnZpcm9ubWVudC5ob3N0KTtcbiAgICBjb25zdCBuZ0ltcG9ydCA9IG1ldGFPYmouZ2V0Tm9kZSgnbmdJbXBvcnQnKTtcbiAgICBjb25zdCBlbWl0U2NvcGUgPSB0aGlzLmdldEVtaXRTY29wZShuZ0ltcG9ydCwgZGVjbGFyYXRpb25TY29wZSk7XG5cbiAgICBjb25zdCBtaW5WZXJzaW9uID0gbWV0YU9iai5nZXRTdHJpbmcoJ21pblZlcnNpb24nKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gbWV0YU9iai5nZXRTdHJpbmcoJ3ZlcnNpb24nKTtcbiAgICBjb25zdCBsaW5rZXIgPSB0aGlzLmxpbmtlclNlbGVjdG9yLmdldExpbmtlcihkZWNsYXJhdGlvbkZuLCBtaW5WZXJzaW9uLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gbGlua2VyLmxpbmtQYXJ0aWFsRGVjbGFyYXRpb24oZW1pdFNjb3BlLmNvbnN0YW50UG9vbCwgbWV0YU9iaik7XG5cbiAgICByZXR1cm4gZW1pdFNjb3BlLnRyYW5zbGF0ZURlZmluaXRpb24oZGVmaW5pdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB0aGUgc2hhcmVkIGNvbnN0YW50IHN0YXRlbWVudHMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgY29uc3RhbnQgc2NvcGUgcmVmZXJlbmNlcywgc29cbiAgICogdGhhdCB0aGV5IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIGdldENvbnN0YW50U3RhdGVtZW50cygpOiB7Y29uc3RhbnRTY29wZTogVENvbnN0YW50U2NvcGUsIHN0YXRlbWVudHM6IFRTdGF0ZW1lbnRbXX1bXSB7XG4gICAgY29uc3QgcmVzdWx0czoge2NvbnN0YW50U2NvcGU6IFRDb25zdGFudFNjb3BlLCBzdGF0ZW1lbnRzOiBUU3RhdGVtZW50W119W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtjb25zdGFudFNjb3BlLCBlbWl0U2NvcGVdIG9mIHRoaXMuZW1pdFNjb3Blcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBlbWl0U2NvcGUuZ2V0Q29uc3RhbnRTdGF0ZW1lbnRzKCk7XG4gICAgICByZXN1bHRzLnB1c2goe2NvbnN0YW50U2NvcGUsIHN0YXRlbWVudHN9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBwcml2YXRlIGdldEVtaXRTY29wZShcbiAgICAgIG5nSW1wb3J0OiBURXhwcmVzc2lvbiwgZGVjbGFyYXRpb25TY29wZTogRGVjbGFyYXRpb25TY29wZTxUQ29uc3RhbnRTY29wZSwgVEV4cHJlc3Npb24+KTpcbiAgICAgIEVtaXRTY29wZTxUU3RhdGVtZW50LCBURXhwcmVzc2lvbj4ge1xuICAgIGNvbnN0IGNvbnN0YW50U2NvcGUgPSBkZWNsYXJhdGlvblNjb3BlLmdldENvbnN0YW50U2NvcGVSZWYobmdJbXBvcnQpO1xuICAgIGlmIChjb25zdGFudFNjb3BlID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBjb25zdGFudCBzY29wZSBzbyB3ZSB3aWxsIGVtaXQgZXh0cmEgc3RhdGVtZW50cyBpbnRvIHRoZSBkZWZpbml0aW9uIElJRkUuXG4gICAgICByZXR1cm4gbmV3IElpZmVFbWl0U2NvcGUoXG4gICAgICAgICAgbmdJbXBvcnQsIHRoaXMubGlua2VyRW52aXJvbm1lbnQudHJhbnNsYXRvciwgdGhpcy5saW5rZXJFbnZpcm9ubWVudC5mYWN0b3J5KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZW1pdFNjb3Blcy5oYXMoY29uc3RhbnRTY29wZSkpIHtcbiAgICAgIHRoaXMuZW1pdFNjb3Blcy5zZXQoXG4gICAgICAgICAgY29uc3RhbnRTY29wZSwgbmV3IEVtaXRTY29wZShuZ0ltcG9ydCwgdGhpcy5saW5rZXJFbnZpcm9ubWVudC50cmFuc2xhdG9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVtaXRTY29wZXMuZ2V0KGNvbnN0YW50U2NvcGUpITtcbiAgfVxufVxuIl19