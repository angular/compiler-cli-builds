(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/ngcc/src/ngcc_options", ["require", "exports", "@angular/compiler-cli/src/ngtsc/file_system", "@angular/compiler-cli/src/perform_compile", "@angular/compiler-cli/ngcc/src/logging/console_logger", "@angular/compiler-cli/ngcc/src/logging/logger", "@angular/compiler-cli/ngcc/src/packages/entry_point", "@angular/compiler-cli/ngcc/src/path_mappings", "@angular/compiler-cli/ngcc/src/writing/in_place_file_writer", "@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSharedSetup = void 0;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var file_system_1 = require("@angular/compiler-cli/src/ngtsc/file_system");
    var perform_compile_1 = require("@angular/compiler-cli/src/perform_compile");
    var console_logger_1 = require("@angular/compiler-cli/ngcc/src/logging/console_logger");
    var logger_1 = require("@angular/compiler-cli/ngcc/src/logging/logger");
    var entry_point_1 = require("@angular/compiler-cli/ngcc/src/packages/entry_point");
    var path_mappings_1 = require("@angular/compiler-cli/ngcc/src/path_mappings");
    var in_place_file_writer_1 = require("@angular/compiler-cli/ngcc/src/writing/in_place_file_writer");
    var new_entry_point_file_writer_1 = require("@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer");
    /**
     * Instantiate common utilities that are always used and fix up options with defaults, as necessary.
     *
     * NOTE: Avoid eagerly instantiating anything that might not be used when running sync/async.
     */
    function getSharedSetup(options) {
        var fileSystem = file_system_1.getFileSystem();
        var absBasePath = file_system_1.absoluteFrom(options.basePath);
        var projectPath = fileSystem.dirname(absBasePath);
        var tsConfig = options.tsConfigPath !== null ? perform_compile_1.readConfiguration(options.tsConfigPath || projectPath) : null;
        var basePath = options.basePath, targetEntryPointPath = options.targetEntryPointPath, _a = options.propertiesToConsider, propertiesToConsider = _a === void 0 ? entry_point_1.SUPPORTED_FORMAT_PROPERTIES : _a, _b = options.compileAllFormats, compileAllFormats = _b === void 0 ? true : _b, _c = options.createNewEntryPointFormats, createNewEntryPointFormats = _c === void 0 ? false : _c, _d = options.logger, logger = _d === void 0 ? new console_logger_1.ConsoleLogger(logger_1.LogLevel.info) : _d, _e = options.pathMappings, pathMappings = _e === void 0 ? path_mappings_1.getPathMappingsFromTsConfig(tsConfig, projectPath) : _e, _f = options.async, async = _f === void 0 ? false : _f, _g = options.errorOnFailedEntryPoint, errorOnFailedEntryPoint = _g === void 0 ? false : _g, _h = options.enableI18nLegacyMessageIdFormat, enableI18nLegacyMessageIdFormat = _h === void 0 ? true : _h, _j = options.invalidateEntryPointManifest, invalidateEntryPointManifest = _j === void 0 ? false : _j, tsConfigPath = options.tsConfigPath;
        if (!!targetEntryPointPath) {
            // targetEntryPointPath forces us to error if an entry-point fails.
            errorOnFailedEntryPoint = true;
        }
        return {
            basePath: basePath,
            targetEntryPointPath: targetEntryPointPath,
            propertiesToConsider: propertiesToConsider,
            compileAllFormats: compileAllFormats,
            createNewEntryPointFormats: createNewEntryPointFormats,
            logger: logger,
            pathMappings: pathMappings,
            async: async,
            errorOnFailedEntryPoint: errorOnFailedEntryPoint,
            enableI18nLegacyMessageIdFormat: enableI18nLegacyMessageIdFormat,
            invalidateEntryPointManifest: invalidateEntryPointManifest,
            tsConfigPath: tsConfigPath,
            fileSystem: fileSystem,
            absBasePath: absBasePath,
            projectPath: projectPath,
            tsConfig: tsConfig,
            getFileWriter: function (pkgJsonUpdater) { return createNewEntryPointFormats ?
                new new_entry_point_file_writer_1.NewEntryPointFileWriter(fileSystem, logger, errorOnFailedEntryPoint, pkgJsonUpdater) :
                new in_place_file_writer_1.InPlaceFileWriter(fileSystem, logger, errorOnFailedEntryPoint); },
        };
    }
    exports.getSharedSetup = getSharedSetup;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdjY19vcHRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL25nY2Mvc3JjL25nY2Nfb3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFBQTs7Ozs7O09BTUc7SUFDSCwyRUFBb0c7SUFDcEcsNkVBQWlGO0lBRWpGLHdGQUF1RDtJQUN2RCx3RUFBa0Q7SUFDbEQsbUZBQW1FO0lBQ25FLDhFQUEwRTtJQUUxRSxvR0FBaUU7SUFDakUsa0hBQThFO0lBbUk5RTs7OztPQUlHO0lBQ0gsU0FBZ0IsY0FBYyxDQUFDLE9BQW9CO1FBRWpELElBQU0sVUFBVSxHQUFHLDJCQUFhLEVBQUUsQ0FBQztRQUNuQyxJQUFNLFdBQVcsR0FBRywwQkFBWSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNuRCxJQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3BELElBQU0sUUFBUSxHQUNWLE9BQU8sQ0FBQyxZQUFZLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxtQ0FBaUIsQ0FBQyxPQUFPLENBQUMsWUFBWSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFHaEcsSUFBQSxRQUFRLEdBWU4sT0FBTyxTQVpELEVBQ1Isb0JBQW9CLEdBV2xCLE9BQU8scUJBWFcsRUFDcEIsS0FVRSxPQUFPLHFCQVZ5QyxFQUFsRCxvQkFBb0IsbUJBQUcseUNBQTJCLEtBQUEsRUFDbEQsS0FTRSxPQUFPLGtCQVRlLEVBQXhCLGlCQUFpQixtQkFBRyxJQUFJLEtBQUEsRUFDeEIsS0FRRSxPQUFPLDJCQVJ5QixFQUFsQywwQkFBMEIsbUJBQUcsS0FBSyxLQUFBLEVBQ2xDLEtBT0UsT0FBTyxPQVBnQyxFQUF6QyxNQUFNLG1CQUFHLElBQUksOEJBQWEsQ0FBQyxpQkFBUSxDQUFDLElBQUksQ0FBQyxLQUFBLEVBQ3pDLEtBTUUsT0FBTyxhQU53RCxFQUFqRSxZQUFZLG1CQUFHLDJDQUEyQixDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsS0FBQSxFQUNqRSxLQUtFLE9BQU8sTUFMSSxFQUFiLEtBQUssbUJBQUcsS0FBSyxLQUFBLEVBQ2IsS0FJRSxPQUFPLHdCQUpzQixFQUEvQix1QkFBdUIsbUJBQUcsS0FBSyxLQUFBLEVBQy9CLEtBR0UsT0FBTyxnQ0FINkIsRUFBdEMsK0JBQStCLG1CQUFHLElBQUksS0FBQSxFQUN0QyxLQUVFLE9BQU8sNkJBRjJCLEVBQXBDLDRCQUE0QixtQkFBRyxLQUFLLEtBQUEsRUFDcEMsWUFBWSxHQUNWLE9BQU8sYUFERyxDQUNGO1FBRVosSUFBSSxDQUFDLENBQUMsb0JBQW9CLEVBQUU7WUFDMUIsbUVBQW1FO1lBQ25FLHVCQUF1QixHQUFHLElBQUksQ0FBQztTQUNoQztRQUVELE9BQU87WUFDTCxRQUFRLFVBQUE7WUFDUixvQkFBb0Isc0JBQUE7WUFDcEIsb0JBQW9CLHNCQUFBO1lBQ3BCLGlCQUFpQixtQkFBQTtZQUNqQiwwQkFBMEIsNEJBQUE7WUFDMUIsTUFBTSxRQUFBO1lBQ04sWUFBWSxjQUFBO1lBQ1osS0FBSyxPQUFBO1lBQ0wsdUJBQXVCLHlCQUFBO1lBQ3ZCLCtCQUErQixpQ0FBQTtZQUMvQiw0QkFBNEIsOEJBQUE7WUFDNUIsWUFBWSxjQUFBO1lBQ1osVUFBVSxZQUFBO1lBQ1YsV0FBVyxhQUFBO1lBQ1gsV0FBVyxhQUFBO1lBQ1gsUUFBUSxVQUFBO1lBQ1IsYUFBYSxFQUFFLFVBQUMsY0FBa0MsSUFBSyxPQUFBLDBCQUEwQixDQUFDLENBQUM7Z0JBQy9FLElBQUkscURBQXVCLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUMxRixJQUFJLHdDQUFpQixDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsdUJBQXVCLENBQUMsRUFGZixDQUVlO1NBQ3ZFLENBQUM7SUFDSixDQUFDO0lBakRELHdDQWlEQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7YWJzb2x1dGVGcm9tLCBBYnNvbHV0ZUZzUGF0aCwgRmlsZVN5c3RlbSwgZ2V0RmlsZVN5c3RlbX0gZnJvbSAnLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7UGFyc2VkQ29uZmlndXJhdGlvbiwgcmVhZENvbmZpZ3VyYXRpb259IGZyb20gJy4uLy4uL3NyYy9wZXJmb3JtX2NvbXBpbGUnO1xuXG5pbXBvcnQge0NvbnNvbGVMb2dnZXJ9IGZyb20gJy4vbG9nZ2luZy9jb25zb2xlX2xvZ2dlcic7XG5pbXBvcnQge0xvZ2dlciwgTG9nTGV2ZWx9IGZyb20gJy4vbG9nZ2luZy9sb2dnZXInO1xuaW1wb3J0IHtTVVBQT1JURURfRk9STUFUX1BST1BFUlRJRVN9IGZyb20gJy4vcGFja2FnZXMvZW50cnlfcG9pbnQnO1xuaW1wb3J0IHtnZXRQYXRoTWFwcGluZ3NGcm9tVHNDb25maWcsIFBhdGhNYXBwaW5nc30gZnJvbSAnLi9wYXRoX21hcHBpbmdzJztcbmltcG9ydCB7RmlsZVdyaXRlcn0gZnJvbSAnLi93cml0aW5nL2ZpbGVfd3JpdGVyJztcbmltcG9ydCB7SW5QbGFjZUZpbGVXcml0ZXJ9IGZyb20gJy4vd3JpdGluZy9pbl9wbGFjZV9maWxlX3dyaXRlcic7XG5pbXBvcnQge05ld0VudHJ5UG9pbnRGaWxlV3JpdGVyfSBmcm9tICcuL3dyaXRpbmcvbmV3X2VudHJ5X3BvaW50X2ZpbGVfd3JpdGVyJztcbmltcG9ydCB7UGFja2FnZUpzb25VcGRhdGVyfSBmcm9tICcuL3dyaXRpbmcvcGFja2FnZV9qc29uX3VwZGF0ZXInO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgbmdjYyBjb21waWxlciBmb3Igc3luY2hyb25vdXMgZXhlY3V0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bmNOZ2NjT3B0aW9ucyB7XG4gIC8qKiBUaGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgYG5vZGVfbW9kdWxlc2AgZm9sZGVyIHRoYXQgY29udGFpbnMgdGhlIHBhY2thZ2VzIHRvIHByb2Nlc3MuICovXG4gIGJhc2VQYXRoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBwcmltYXJ5IHBhY2thZ2UgdG8gYmUgcHJvY2Vzc2VkLiBJZiBub3QgYWJzb2x1dGUgdGhlbiBpdCBtdXN0IGJlIHJlbGF0aXZlIHRvXG4gICAqIGBiYXNlUGF0aGAuXG4gICAqXG4gICAqIEFsbCBpdHMgZGVwZW5kZW5jaWVzIHdpbGwgbmVlZCB0byBiZSBwcm9jZXNzZWQgdG9vLlxuICAgKlxuICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIHByb3ZpZGVkIHRoZW4gYGVycm9yT25GYWlsZWRFbnRyeVBvaW50YCBpcyBmb3JjZWQgdG8gdHJ1ZS5cbiAgICovXG4gIHRhcmdldEVudHJ5UG9pbnRQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGljaCBlbnRyeS1wb2ludCBwcm9wZXJ0aWVzIGluIHRoZSBwYWNrYWdlLmpzb24gdG8gY29uc2lkZXIgd2hlbiBwcm9jZXNzaW5nIGFuIGVudHJ5LXBvaW50LlxuICAgKiBFYWNoIHByb3BlcnR5IHNob3VsZCBob2xkIGEgcGF0aCB0byB0aGUgcGFydGljdWxhciBidW5kbGUgZm9ybWF0IGZvciB0aGUgZW50cnktcG9pbnQuXG4gICAqIERlZmF1bHRzIHRvIGFsbCB0aGUgcHJvcGVydGllcyBpbiB0aGUgcGFja2FnZS5qc29uLlxuICAgKi9cbiAgcHJvcGVydGllc1RvQ29uc2lkZXI/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwcm9jZXNzIGFsbCBmb3JtYXRzIHNwZWNpZmllZCBieSAoYHByb3BlcnRpZXNUb0NvbnNpZGVyYCkgIG9yIHRvIHN0b3AgcHJvY2Vzc2luZ1xuICAgKiB0aGlzIGVudHJ5LXBvaW50IGF0IHRoZSBmaXJzdCBtYXRjaGluZyBmb3JtYXQuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIGNvbXBpbGVBbGxGb3JtYXRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBjcmVhdGUgbmV3IGVudHJ5LXBvaW50cyBidW5kbGVzIHJhdGhlciB0aGFuIG92ZXJ3cml0aW5nIHRoZSBvcmlnaW5hbCBmaWxlcy5cbiAgICovXG4gIGNyZWF0ZU5ld0VudHJ5UG9pbnRGb3JtYXRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxvZ2dlciB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggbG9nIG1lc3NhZ2VzLlxuICAgKi9cbiAgbG9nZ2VyPzogTG9nZ2VyO1xuXG4gIC8qKlxuICAgKiBQYXRocyBtYXBwaW5nIGNvbmZpZ3VyYXRpb24gKGBwYXRoc2AgYW5kIGBiYXNlVXJsYCksIGFzIGZvdW5kIGluIGB0cy5Db21waWxlck9wdGlvbnNgLlxuICAgKiBUaGVzZSBhcmUgdXNlZCB0byByZXNvbHZlIHBhdGhzIHRvIGxvY2FsbHkgYnVpbHQgQW5ndWxhciBsaWJyYXJpZXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBgcGF0aE1hcHBpbmdzYCBzcGVjaWZpZWQgaGVyZSB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhbnkgYHBhdGhNYXBwaW5nc2AgbG9hZGVkIGZyb20gYVxuICAgKiBUUyBjb25maWcgZmlsZS5cbiAgICovXG4gIHBhdGhNYXBwaW5ncz86IFBhdGhNYXBwaW5ncztcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGZpbGUtc3lzdGVtIHNlcnZpY2UgdGhhdCB3aWxsIGJlIHVzZWQgYnkgbmdjYyBmb3IgYWxsIGZpbGUgaW50ZXJhY3Rpb25zLlxuICAgKi9cbiAgZmlsZVN5c3RlbT86IEZpbGVTeXN0ZW07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbXBpbGF0aW9uIHNob3VsZCBydW4gYW5kIHJldHVybiBhc3luY2hyb25vdXNseS4gQWxsb3dpbmcgYXN5bmNocm9ub3VzIGV4ZWN1dGlvblxuICAgKiBtYXkgc3BlZWQgdXAgdGhlIGNvbXBpbGF0aW9uIGJ5IHV0aWxpemluZyBtdWx0aXBsZSBDUFUgY29yZXMgKGlmIGF2YWlsYWJsZSkuXG4gICAqXG4gICAqIERlZmF1bHQ6IGBmYWxzZWAgKGkuZS4gcnVuIHN5bmNocm9ub3VzbHkpXG4gICAqL1xuICBhc3luYz86IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpbiBvcmRlciB0byB0ZXJtaW5hdGUgaW1tZWRpYXRlbHkgd2l0aCBhbiBlcnJvciBjb2RlIGlmIGFuIGVudHJ5LXBvaW50IGZhaWxzIHRvIGJlXG4gICAqIHByb2Nlc3NlZC5cbiAgICpcbiAgICogSWYgYHRhcmdldEVudHJ5UG9pbnRQYXRoYCBpcyBwcm92aWRlZCB0aGVuIHRoaXMgcHJvcGVydHkgaXMgYWx3YXlzIHRydWUgYW5kIGNhbm5vdCBiZVxuICAgKiBjaGFuZ2VkLiBPdGhlcndpc2UgdGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gICAqXG4gICAqIFdoZW4gc2V0IHRvIGZhbHNlLCBuZ2NjIHdpbGwgY29udGludWUgdG8gcHJvY2VzcyBlbnRyeS1wb2ludHMgYWZ0ZXIgYSBmYWlsdXJlLiBJbiB3aGljaCBjYXNlIGl0XG4gICAqIHdpbGwgbG9nIGFuIGVycm9yIGFuZCByZXN1bWUgcHJvY2Vzc2luZyBvdGhlciBlbnRyeS1wb2ludHMuXG4gICAqL1xuICBlcnJvck9uRmFpbGVkRW50cnlQb2ludD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlbmRlciBgJGxvY2FsaXplYCBtZXNzYWdlcyB3aXRoIGxlZ2FjeSBmb3JtYXQgaWRzLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuIE9ubHkgc2V0IHRoaXMgdG8gYGZhbHNlYCBpZiB5b3UgZG8gbm90IHdhbnQgbGVnYWN5IG1lc3NhZ2UgaWRzIHRvXG4gICAqIGJlIHJlbmRlcmVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBub3QgdXNpbmcgbGVnYWN5IG1lc3NhZ2UgaWRzIGluIHlvdXIgdHJhbnNsYXRpb24gZmlsZXNcbiAgICogQU5EIGFyZSBub3QgZG9pbmcgY29tcGlsZS10aW1lIGlubGluaW5nIG9mIHRyYW5zbGF0aW9ucywgaW4gd2hpY2ggY2FzZSB0aGUgZXh0cmEgbWVzc2FnZSBpZHNcbiAgICogd291bGQgYWRkIHVud2FudGVkIHNpemUgdG8gdGhlIGZpbmFsIHNvdXJjZSBidW5kbGUuXG4gICAqXG4gICAqIEl0IGlzIHNhZmUgdG8gbGVhdmUgdGhpcyBzZXQgdG8gdHJ1ZSBpZiB5b3UgYXJlIGRvaW5nIGNvbXBpbGUtdGltZSBpbmxpbmluZyBiZWNhdXNlIHRoZSBleHRyYVxuICAgKiBsZWdhY3kgbWVzc2FnZSBpZHMgd2lsbCBhbGwgYmUgc3RyaXBwZWQgZHVyaW5nIHRyYW5zbGF0aW9uLlxuICAgKi9cbiAgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gaW52YWxpZGF0ZSBhbnkgZW50cnktcG9pbnQgbWFuaWZlc3QgZmlsZSB0aGF0IGlzIG9uIGRpc2suIEluc3RlYWQsIHdhbGsgdGhlXG4gICAqIGRpcmVjdG9yeSB0cmVlIGxvb2tpbmcgZm9yIGVudHJ5LXBvaW50cywgYW5kIHRoZW4gd3JpdGUgYSBuZXcgZW50cnktcG9pbnQgbWFuaWZlc3QsIGlmXG4gICAqIHBvc3NpYmxlLlxuICAgKlxuICAgKiBEZWZhdWx0OiBgZmFsc2VgIChpLmUuIHRoZSBtYW5pZmVzdCB3aWxsIGJlIHVzZWQgaWYgYXZhaWxhYmxlKVxuICAgKi9cbiAgaW52YWxpZGF0ZUVudHJ5UG9pbnRNYW5pZmVzdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFuIGFic29sdXRlIHBhdGggdG8gYSBUUyBjb25maWcgZmlsZSAoZS5nLiBgdHNjb25maWcuanNvbmApIG9yIGEgZGlyZWN0b3J5IGNvbnRhaW5pbmcgb25lLCB0aGF0XG4gICAqIHdpbGwgYmUgdXNlZCB0byBjb25maWd1cmUgbW9kdWxlIHJlc29sdXRpb24gd2l0aCB0aGluZ3MgbGlrZSBwYXRoIG1hcHBpbmdzLCBpZiBub3Qgc3BlY2lmaWVkXG4gICAqIGV4cGxpY2l0bHkgdmlhIHRoZSBgcGF0aE1hcHBpbmdzYCBwcm9wZXJ0eSB0byBgbWFpbk5nY2NgLlxuICAgKlxuICAgKiBJZiBgdW5kZWZpbmVkYCwgbmdjYyB3aWxsIGF0dGVtcHQgdG8gbG9hZCBhIGB0c2NvbmZpZy5qc29uYCBmaWxlIGZyb20gdGhlIGRpcmVjdG9yeSBhYm92ZSB0aGVcbiAgICogYGJhc2VQYXRoYC5cbiAgICpcbiAgICogSWYgYG51bGxgLCBuZ2NjIHdpbGwgbm90IGF0dGVtcHQgdG8gbG9hZCBhbnkgVFMgY29uZmlnIGZpbGUgYXQgYWxsLlxuICAgKi9cbiAgdHNDb25maWdQYXRoPzogc3RyaW5nfG51bGw7XG59XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBuZ2NjIGNvbXBpbGVyIGZvciBhc3luY2hyb25vdXMgZXhlY3V0aW9uLlxuICovXG5leHBvcnQgdHlwZSBBc3luY05nY2NPcHRpb25zID0gT21pdDxTeW5jTmdjY09wdGlvbnMsICdhc3luYyc+Jnthc3luYzogdHJ1ZX07XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBuZ2NjIGNvbXBpbGVyLlxuICovXG5leHBvcnQgdHlwZSBOZ2NjT3B0aW9ucyA9IEFzeW5jTmdjY09wdGlvbnN8U3luY05nY2NPcHRpb25zO1xuXG5leHBvcnQgdHlwZSBPcHRpb25hbE5nY2NPcHRpb25LZXlzID0gJ3RhcmdldEVudHJ5UG9pbnRQYXRoJ3wndHNDb25maWdQYXRoJ3wncGF0aE1hcHBpbmdzJztcbmV4cG9ydCB0eXBlIFJlcXVpcmVkTmdjY09wdGlvbnMgPSBSZXF1aXJlZDxPbWl0PE5nY2NPcHRpb25zLCBPcHRpb25hbE5nY2NPcHRpb25LZXlzPj47XG5leHBvcnQgdHlwZSBPcHRpb25hbE5nY2NPcHRpb25zID0gUGljazxOZ2NjT3B0aW9ucywgT3B0aW9uYWxOZ2NjT3B0aW9uS2V5cz47XG5leHBvcnQgdHlwZSBTaGFyZWRTZXR1cCA9IHtcbiAgZmlsZVN5c3RlbTogRmlsZVN5c3RlbTsgYWJzQmFzZVBhdGg6IEFic29sdXRlRnNQYXRoOyBwcm9qZWN0UGF0aDogQWJzb2x1dGVGc1BhdGg7XG4gIHRzQ29uZmlnOiBQYXJzZWRDb25maWd1cmF0aW9uIHwgbnVsbDtcbiAgZ2V0RmlsZVdyaXRlcihwa2dKc29uVXBkYXRlcjogUGFja2FnZUpzb25VcGRhdGVyKTogRmlsZVdyaXRlcjtcbn07XG5cbi8qKlxuICogSW5zdGFudGlhdGUgY29tbW9uIHV0aWxpdGllcyB0aGF0IGFyZSBhbHdheXMgdXNlZCBhbmQgZml4IHVwIG9wdGlvbnMgd2l0aCBkZWZhdWx0cywgYXMgbmVjZXNzYXJ5LlxuICpcbiAqIE5PVEU6IEF2b2lkIGVhZ2VybHkgaW5zdGFudGlhdGluZyBhbnl0aGluZyB0aGF0IG1pZ2h0IG5vdCBiZSB1c2VkIHdoZW4gcnVubmluZyBzeW5jL2FzeW5jLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkU2V0dXAob3B0aW9uczogTmdjY09wdGlvbnMpOiBTaGFyZWRTZXR1cCZSZXF1aXJlZE5nY2NPcHRpb25zJlxuICAgIE9wdGlvbmFsTmdjY09wdGlvbnMge1xuICBjb25zdCBmaWxlU3lzdGVtID0gZ2V0RmlsZVN5c3RlbSgpO1xuICBjb25zdCBhYnNCYXNlUGF0aCA9IGFic29sdXRlRnJvbShvcHRpb25zLmJhc2VQYXRoKTtcbiAgY29uc3QgcHJvamVjdFBhdGggPSBmaWxlU3lzdGVtLmRpcm5hbWUoYWJzQmFzZVBhdGgpO1xuICBjb25zdCB0c0NvbmZpZyA9XG4gICAgICBvcHRpb25zLnRzQ29uZmlnUGF0aCAhPT0gbnVsbCA/IHJlYWRDb25maWd1cmF0aW9uKG9wdGlvbnMudHNDb25maWdQYXRoIHx8IHByb2plY3RQYXRoKSA6IG51bGw7XG5cbiAgbGV0IHtcbiAgICBiYXNlUGF0aCxcbiAgICB0YXJnZXRFbnRyeVBvaW50UGF0aCxcbiAgICBwcm9wZXJ0aWVzVG9Db25zaWRlciA9IFNVUFBPUlRFRF9GT1JNQVRfUFJPUEVSVElFUyxcbiAgICBjb21waWxlQWxsRm9ybWF0cyA9IHRydWUsXG4gICAgY3JlYXRlTmV3RW50cnlQb2ludEZvcm1hdHMgPSBmYWxzZSxcbiAgICBsb2dnZXIgPSBuZXcgQ29uc29sZUxvZ2dlcihMb2dMZXZlbC5pbmZvKSxcbiAgICBwYXRoTWFwcGluZ3MgPSBnZXRQYXRoTWFwcGluZ3NGcm9tVHNDb25maWcodHNDb25maWcsIHByb2plY3RQYXRoKSxcbiAgICBhc3luYyA9IGZhbHNlLFxuICAgIGVycm9yT25GYWlsZWRFbnRyeVBvaW50ID0gZmFsc2UsXG4gICAgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCA9IHRydWUsXG4gICAgaW52YWxpZGF0ZUVudHJ5UG9pbnRNYW5pZmVzdCA9IGZhbHNlLFxuICAgIHRzQ29uZmlnUGF0aCxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCEhdGFyZ2V0RW50cnlQb2ludFBhdGgpIHtcbiAgICAvLyB0YXJnZXRFbnRyeVBvaW50UGF0aCBmb3JjZXMgdXMgdG8gZXJyb3IgaWYgYW4gZW50cnktcG9pbnQgZmFpbHMuXG4gICAgZXJyb3JPbkZhaWxlZEVudHJ5UG9pbnQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlUGF0aCxcbiAgICB0YXJnZXRFbnRyeVBvaW50UGF0aCxcbiAgICBwcm9wZXJ0aWVzVG9Db25zaWRlcixcbiAgICBjb21waWxlQWxsRm9ybWF0cyxcbiAgICBjcmVhdGVOZXdFbnRyeVBvaW50Rm9ybWF0cyxcbiAgICBsb2dnZXIsXG4gICAgcGF0aE1hcHBpbmdzLFxuICAgIGFzeW5jLFxuICAgIGVycm9yT25GYWlsZWRFbnRyeVBvaW50LFxuICAgIGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQsXG4gICAgaW52YWxpZGF0ZUVudHJ5UG9pbnRNYW5pZmVzdCxcbiAgICB0c0NvbmZpZ1BhdGgsXG4gICAgZmlsZVN5c3RlbSxcbiAgICBhYnNCYXNlUGF0aCxcbiAgICBwcm9qZWN0UGF0aCxcbiAgICB0c0NvbmZpZyxcbiAgICBnZXRGaWxlV3JpdGVyOiAocGtnSnNvblVwZGF0ZXI6IFBhY2thZ2VKc29uVXBkYXRlcikgPT4gY3JlYXRlTmV3RW50cnlQb2ludEZvcm1hdHMgP1xuICAgICAgICBuZXcgTmV3RW50cnlQb2ludEZpbGVXcml0ZXIoZmlsZVN5c3RlbSwgbG9nZ2VyLCBlcnJvck9uRmFpbGVkRW50cnlQb2ludCwgcGtnSnNvblVwZGF0ZXIpIDpcbiAgICAgICAgbmV3IEluUGxhY2VGaWxlV3JpdGVyKGZpbGVTeXN0ZW0sIGxvZ2dlciwgZXJyb3JPbkZhaWxlZEVudHJ5UG9pbnQpLFxuICB9O1xufVxuIl19