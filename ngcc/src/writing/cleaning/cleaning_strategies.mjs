/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { absoluteFrom } from '../../../../src/ngtsc/file_system';
import { cleanPackageJson } from '../../packages/build_marker';
import { NGCC_BACKUP_EXTENSION } from '../in_place_file_writer';
import { NGCC_DIRECTORY } from '../new_entry_point_file_writer';
import { isLocalDirectory } from './utils';
/**
 * A CleaningStrategy that reverts changes to package.json files by removing the build marker and
 * other properties.
 */
export class PackageJsonCleaner {
    constructor(fs) {
        this.fs = fs;
    }
    canClean(_path, basename) {
        return basename === 'package.json';
    }
    clean(path, _basename) {
        const packageJson = JSON.parse(this.fs.readFile(path));
        if (cleanPackageJson(packageJson)) {
            this.fs.writeFile(path, `${JSON.stringify(packageJson, null, 2)}\n`);
        }
    }
}
/**
 * A CleaningStrategy that removes the extra directory containing generated entry-point formats.
 */
export class NgccDirectoryCleaner {
    constructor(fs) {
        this.fs = fs;
    }
    canClean(path, basename) {
        return basename === NGCC_DIRECTORY && isLocalDirectory(this.fs, path);
    }
    clean(path, _basename) {
        this.fs.removeDeep(path);
    }
}
/**
 * A CleaningStrategy that reverts files that were overwritten and removes the backup files that
 * ngcc created.
 */
export class BackupFileCleaner {
    constructor(fs) {
        this.fs = fs;
    }
    canClean(path, basename) {
        return this.fs.extname(basename) === NGCC_BACKUP_EXTENSION &&
            this.fs.exists(absoluteFrom(path.replace(NGCC_BACKUP_EXTENSION, '')));
    }
    clean(path, _basename) {
        this.fs.moveFile(path, absoluteFrom(path.replace(NGCC_BACKUP_EXTENSION, '')));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xlYW5pbmdfc3RyYXRlZ2llcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9uZ2NjL3NyYy93cml0aW5nL2NsZWFuaW5nL2NsZWFuaW5nX3N0cmF0ZWdpZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxFQUFDLFlBQVksRUFBMEMsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUU3RCxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUM5RCxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sZ0NBQWdDLENBQUM7QUFFOUQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sU0FBUyxDQUFDO0FBVXpDOzs7R0FHRztBQUNILE1BQU0sT0FBTyxrQkFBa0I7SUFDN0IsWUFBb0IsRUFBYztRQUFkLE9BQUUsR0FBRixFQUFFLENBQVk7SUFBRyxDQUFDO0lBQ3RDLFFBQVEsQ0FBQyxLQUFxQixFQUFFLFFBQXFCO1FBQ25ELE9BQU8sUUFBUSxLQUFLLGNBQWMsQ0FBQztJQUNyQyxDQUFDO0lBQ0QsS0FBSyxDQUFDLElBQW9CLEVBQUUsU0FBc0I7UUFDaEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBMEIsQ0FBQztRQUNoRixJQUFJLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEU7SUFDSCxDQUFDO0NBQ0Y7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxvQkFBb0I7SUFDL0IsWUFBb0IsRUFBYztRQUFkLE9BQUUsR0FBRixFQUFFLENBQVk7SUFBRyxDQUFDO0lBQ3RDLFFBQVEsQ0FBQyxJQUFvQixFQUFFLFFBQXFCO1FBQ2xELE9BQU8sUUFBUSxLQUFLLGNBQWMsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFDRCxLQUFLLENBQUMsSUFBb0IsRUFBRSxTQUFzQjtRQUNoRCxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8saUJBQWlCO0lBQzVCLFlBQW9CLEVBQWM7UUFBZCxPQUFFLEdBQUYsRUFBRSxDQUFZO0lBQUcsQ0FBQztJQUN0QyxRQUFRLENBQUMsSUFBb0IsRUFBRSxRQUFxQjtRQUNsRCxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLHFCQUFxQjtZQUN0RCxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUNELEtBQUssQ0FBQyxJQUFvQixFQUFFLFNBQXNCO1FBQ2hELElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEYsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge2Fic29sdXRlRnJvbSwgQWJzb2x1dGVGc1BhdGgsIEZpbGVTeXN0ZW0sIFBhdGhTZWdtZW50fSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvbmd0c2MvZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtjbGVhblBhY2thZ2VKc29ufSBmcm9tICcuLi8uLi9wYWNrYWdlcy9idWlsZF9tYXJrZXInO1xuaW1wb3J0IHtFbnRyeVBvaW50UGFja2FnZUpzb259IGZyb20gJy4uLy4uL3BhY2thZ2VzL2VudHJ5X3BvaW50JztcbmltcG9ydCB7TkdDQ19CQUNLVVBfRVhURU5TSU9OfSBmcm9tICcuLi9pbl9wbGFjZV9maWxlX3dyaXRlcic7XG5pbXBvcnQge05HQ0NfRElSRUNUT1JZfSBmcm9tICcuLi9uZXdfZW50cnlfcG9pbnRfZmlsZV93cml0ZXInO1xuXG5pbXBvcnQge2lzTG9jYWxEaXJlY3Rvcnl9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEltcGxlbWVudCB0aGlzIGludGVyZmFjZSB0byBleHRlbmQgdGhlIGNsZWFuaW5nIHN0cmF0ZWdpZXMgb2YgdGhlIGBQYWNrYWdlQ2xlYW5lcmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2xlYW5pbmdTdHJhdGVneSB7XG4gIGNhbkNsZWFuKHBhdGg6IEFic29sdXRlRnNQYXRoLCBiYXNlbmFtZTogUGF0aFNlZ21lbnQpOiBib29sZWFuO1xuICBjbGVhbihwYXRoOiBBYnNvbHV0ZUZzUGF0aCwgYmFzZW5hbWU6IFBhdGhTZWdtZW50KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIENsZWFuaW5nU3RyYXRlZ3kgdGhhdCByZXZlcnRzIGNoYW5nZXMgdG8gcGFja2FnZS5qc29uIGZpbGVzIGJ5IHJlbW92aW5nIHRoZSBidWlsZCBtYXJrZXIgYW5kXG4gKiBvdGhlciBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgY2xhc3MgUGFja2FnZUpzb25DbGVhbmVyIGltcGxlbWVudHMgQ2xlYW5pbmdTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZnM6IEZpbGVTeXN0ZW0pIHt9XG4gIGNhbkNsZWFuKF9wYXRoOiBBYnNvbHV0ZUZzUGF0aCwgYmFzZW5hbWU6IFBhdGhTZWdtZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGJhc2VuYW1lID09PSAncGFja2FnZS5qc29uJztcbiAgfVxuICBjbGVhbihwYXRoOiBBYnNvbHV0ZUZzUGF0aCwgX2Jhc2VuYW1lOiBQYXRoU2VnbWVudCk6IHZvaWQge1xuICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZSh0aGlzLmZzLnJlYWRGaWxlKHBhdGgpKSBhcyBFbnRyeVBvaW50UGFja2FnZUpzb247XG4gICAgaWYgKGNsZWFuUGFja2FnZUpzb24ocGFja2FnZUpzb24pKSB7XG4gICAgICB0aGlzLmZzLndyaXRlRmlsZShwYXRoLCBgJHtKU09OLnN0cmluZ2lmeShwYWNrYWdlSnNvbiwgbnVsbCwgMil9XFxuYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSBDbGVhbmluZ1N0cmF0ZWd5IHRoYXQgcmVtb3ZlcyB0aGUgZXh0cmEgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGVudHJ5LXBvaW50IGZvcm1hdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZ2NjRGlyZWN0b3J5Q2xlYW5lciBpbXBsZW1lbnRzIENsZWFuaW5nU3RyYXRlZ3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZzOiBGaWxlU3lzdGVtKSB7fVxuICBjYW5DbGVhbihwYXRoOiBBYnNvbHV0ZUZzUGF0aCwgYmFzZW5hbWU6IFBhdGhTZWdtZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGJhc2VuYW1lID09PSBOR0NDX0RJUkVDVE9SWSAmJiBpc0xvY2FsRGlyZWN0b3J5KHRoaXMuZnMsIHBhdGgpO1xuICB9XG4gIGNsZWFuKHBhdGg6IEFic29sdXRlRnNQYXRoLCBfYmFzZW5hbWU6IFBhdGhTZWdtZW50KTogdm9pZCB7XG4gICAgdGhpcy5mcy5yZW1vdmVEZWVwKHBhdGgpO1xuICB9XG59XG5cbi8qKlxuICogQSBDbGVhbmluZ1N0cmF0ZWd5IHRoYXQgcmV2ZXJ0cyBmaWxlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW4gYW5kIHJlbW92ZXMgdGhlIGJhY2t1cCBmaWxlcyB0aGF0XG4gKiBuZ2NjIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWNrdXBGaWxlQ2xlYW5lciBpbXBsZW1lbnRzIENsZWFuaW5nU3RyYXRlZ3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZzOiBGaWxlU3lzdGVtKSB7fVxuICBjYW5DbGVhbihwYXRoOiBBYnNvbHV0ZUZzUGF0aCwgYmFzZW5hbWU6IFBhdGhTZWdtZW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXh0bmFtZShiYXNlbmFtZSkgPT09IE5HQ0NfQkFDS1VQX0VYVEVOU0lPTiAmJlxuICAgICAgICB0aGlzLmZzLmV4aXN0cyhhYnNvbHV0ZUZyb20ocGF0aC5yZXBsYWNlKE5HQ0NfQkFDS1VQX0VYVEVOU0lPTiwgJycpKSk7XG4gIH1cbiAgY2xlYW4ocGF0aDogQWJzb2x1dGVGc1BhdGgsIF9iYXNlbmFtZTogUGF0aFNlZ21lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmZzLm1vdmVGaWxlKHBhdGgsIGFic29sdXRlRnJvbShwYXRoLnJlcGxhY2UoTkdDQ19CQUNLVVBfRVhURU5TSU9OLCAnJykpKTtcbiAgfVxufVxuIl19