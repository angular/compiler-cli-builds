import { createDependencyInfo } from '../dependencies/dependency_host';
import { EsmDependencyHost } from '../dependencies/esm_dependency_host';
import { ModuleResolver } from '../dependencies/module_resolver';
import { getPathMappingsFromTsConfig } from '../path_mappings';
import { TracingEntryPointFinder } from './tracing_entry_point_finder';
import { trackDuration } from './utils';
/**
 * An EntryPointFinder that starts from the files in the program defined by the given tsconfig.json
 * and only returns entry-points that are dependencies of these files.
 *
 * This is faster than searching the entire file-system for all the entry-points,
 * and is used primarily by the CLI integration.
 */
export class ProgramBasedEntryPointFinder extends TracingEntryPointFinder {
    constructor(fs, config, logger, resolver, entryPointCollector, entryPointManifest, basePath, tsConfig, projectPath) {
        super(fs, config, logger, resolver, basePath, getPathMappingsFromTsConfig(fs, tsConfig, projectPath));
        this.entryPointCollector = entryPointCollector;
        this.entryPointManifest = entryPointManifest;
        this.tsConfig = tsConfig;
        this.entryPointsWithDependencies = null;
    }
    /**
     * Return an array containing the external import paths that were extracted from the source-files
     * of the program defined by the tsconfig.json.
     */
    getInitialEntryPointPaths() {
        const moduleResolver = new ModuleResolver(this.fs, this.pathMappings, ['', '.ts', '/index.ts']);
        const host = new EsmDependencyHost(this.fs, moduleResolver);
        const dependencies = createDependencyInfo();
        const rootFiles = this.tsConfig.rootNames.map(rootName => this.fs.resolve(rootName));
        this.logger.debug(`Using the program from ${this.tsConfig.project} to seed the entry-point finding.`);
        this.logger.debug(`Collecting dependencies from the following files:` + rootFiles.map(file => `\n- ${file}`));
        host.collectDependenciesInFiles(rootFiles, dependencies);
        return Array.from(dependencies.dependencies);
    }
    /**
     * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including
     * paths to other entry-points that this entry-point depends upon.
     *
     * In this entry-point finder, we use the `EntryPointManifest` to avoid computing each
     * entry-point's dependencies in the case that this had been done previously.
     *
     * @param entryPointPath the path to the entry-point whose information and dependencies are to be
     *     retrieved or computed.
     *
     * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by
     *     Angular or cannot be determined.
     */
    getEntryPointWithDeps(entryPointPath) {
        const entryPoints = this.findOrLoadEntryPoints();
        if (!entryPoints.has(entryPointPath)) {
            return null;
        }
        const entryPointWithDeps = entryPoints.get(entryPointPath);
        if (!entryPointWithDeps.entryPoint.compiledByAngular) {
            return null;
        }
        return entryPointWithDeps;
    }
    /**
     * Walk the base paths looking for entry-points or load this information from an entry-point
     * manifest, if available.
     */
    findOrLoadEntryPoints() {
        if (this.entryPointsWithDependencies === null) {
            const entryPointsWithDependencies = this.entryPointsWithDependencies =
                new Map();
            for (const basePath of this.getBasePaths()) {
                const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) ||
                    this.walkBasePathForPackages(basePath);
                for (const e of entryPoints) {
                    entryPointsWithDependencies.set(e.entryPoint.path, e);
                }
            }
        }
        return this.entryPointsWithDependencies;
    }
    /**
     * Search the `basePath` for possible Angular packages and entry-points.
     *
     * @param basePath The path at which to start the search.
     * @returns an array of `EntryPoint`s that were found within `basePath`.
     */
    walkBasePathForPackages(basePath) {
        this.logger.debug(`No manifest found for ${basePath} so walking the directories for entry-points.`);
        const entryPoints = trackDuration(() => this.entryPointCollector.walkDirectoryForPackages(basePath), duration => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));
        this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);
        return entryPoints;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3JhbV9iYXNlZF9lbnRyeV9wb2ludF9maW5kZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbmdjYy9zcmMvZW50cnlfcG9pbnRfZmluZGVyL3Byb2dyYW1fYmFzZWRfZW50cnlfcG9pbnRfZmluZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVdBLE9BQU8sRUFBQyxvQkFBb0IsRUFBNkIsTUFBTSxpQ0FBaUMsQ0FBQztBQUVqRyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxxQ0FBcUMsQ0FBQztBQUN0RSxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0saUNBQWlDLENBQUM7QUFHL0QsT0FBTyxFQUFDLDJCQUEyQixFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFHN0QsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDckUsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUV0Qzs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8sNEJBQTZCLFNBQVEsdUJBQXVCO0lBR3ZFLFlBQ0ksRUFBc0IsRUFBRSxNQUF5QixFQUFFLE1BQWMsRUFDakUsUUFBNEIsRUFBVSxtQkFBd0MsRUFDdEUsa0JBQXNDLEVBQUUsUUFBd0IsRUFDaEUsUUFBNkIsRUFBRSxXQUEyQjtRQUNwRSxLQUFLLENBQ0QsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFDdEMsMkJBQTJCLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBTHBCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDdEUsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxhQUFRLEdBQVIsUUFBUSxDQUFxQjtRQU5qQyxnQ0FBMkIsR0FBeUQsSUFBSSxDQUFDO0lBVWpHLENBQUM7SUFFRDs7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OUYsSUFBSSxDQUFDLGtCQUFrQixDQUFDLHVCQUF1QixDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUN2RSxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7QWJzb2x1dGVGc1BhdGgsIFJlYWRvbmx5RmlsZVN5c3RlbX0gZnJvbSAnLi4vLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi8uLi9zcmMvbmd0c2MvbG9nZ2luZyc7XG5pbXBvcnQge1BhcnNlZENvbmZpZ3VyYXRpb259IGZyb20gJy4uLy4uLy4uL3NyYy9wZXJmb3JtX2NvbXBpbGUnO1xuXG5pbXBvcnQge2NyZWF0ZURlcGVuZGVuY3lJbmZvLCBFbnRyeVBvaW50V2l0aERlcGVuZGVuY2llc30gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL2RlcGVuZGVuY3lfaG9zdCc7XG5pbXBvcnQge0RlcGVuZGVuY3lSZXNvbHZlcn0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL2RlcGVuZGVuY3lfcmVzb2x2ZXInO1xuaW1wb3J0IHtFc21EZXBlbmRlbmN5SG9zdH0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL2VzbV9kZXBlbmRlbmN5X2hvc3QnO1xuaW1wb3J0IHtNb2R1bGVSZXNvbHZlcn0gZnJvbSAnLi4vZGVwZW5kZW5jaWVzL21vZHVsZV9yZXNvbHZlcic7XG5pbXBvcnQge05nY2NDb25maWd1cmF0aW9ufSBmcm9tICcuLi9wYWNrYWdlcy9jb25maWd1cmF0aW9uJztcbmltcG9ydCB7RW50cnlQb2ludE1hbmlmZXN0fSBmcm9tICcuLi9wYWNrYWdlcy9lbnRyeV9wb2ludF9tYW5pZmVzdCc7XG5pbXBvcnQge2dldFBhdGhNYXBwaW5nc0Zyb21Uc0NvbmZpZ30gZnJvbSAnLi4vcGF0aF9tYXBwaW5ncyc7XG5cbmltcG9ydCB7RW50cnlQb2ludENvbGxlY3Rvcn0gZnJvbSAnLi9lbnRyeV9wb2ludF9jb2xsZWN0b3InO1xuaW1wb3J0IHtUcmFjaW5nRW50cnlQb2ludEZpbmRlcn0gZnJvbSAnLi90cmFjaW5nX2VudHJ5X3BvaW50X2ZpbmRlcic7XG5pbXBvcnQge3RyYWNrRHVyYXRpb259IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEFuIEVudHJ5UG9pbnRGaW5kZXIgdGhhdCBzdGFydHMgZnJvbSB0aGUgZmlsZXMgaW4gdGhlIHByb2dyYW0gZGVmaW5lZCBieSB0aGUgZ2l2ZW4gdHNjb25maWcuanNvblxuICogYW5kIG9ubHkgcmV0dXJucyBlbnRyeS1wb2ludHMgdGhhdCBhcmUgZGVwZW5kZW5jaWVzIG9mIHRoZXNlIGZpbGVzLlxuICpcbiAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2VhcmNoaW5nIHRoZSBlbnRpcmUgZmlsZS1zeXN0ZW0gZm9yIGFsbCB0aGUgZW50cnktcG9pbnRzLFxuICogYW5kIGlzIHVzZWQgcHJpbWFyaWx5IGJ5IHRoZSBDTEkgaW50ZWdyYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtQmFzZWRFbnRyeVBvaW50RmluZGVyIGV4dGVuZHMgVHJhY2luZ0VudHJ5UG9pbnRGaW5kZXIge1xuICBwcml2YXRlIGVudHJ5UG9pbnRzV2l0aERlcGVuZGVuY2llczogTWFwPEFic29sdXRlRnNQYXRoLCBFbnRyeVBvaW50V2l0aERlcGVuZGVuY2llcz58bnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBmczogUmVhZG9ubHlGaWxlU3lzdGVtLCBjb25maWc6IE5nY2NDb25maWd1cmF0aW9uLCBsb2dnZXI6IExvZ2dlcixcbiAgICAgIHJlc29sdmVyOiBEZXBlbmRlbmN5UmVzb2x2ZXIsIHByaXZhdGUgZW50cnlQb2ludENvbGxlY3RvcjogRW50cnlQb2ludENvbGxlY3RvcixcbiAgICAgIHByaXZhdGUgZW50cnlQb2ludE1hbmlmZXN0OiBFbnRyeVBvaW50TWFuaWZlc3QsIGJhc2VQYXRoOiBBYnNvbHV0ZUZzUGF0aCxcbiAgICAgIHByaXZhdGUgdHNDb25maWc6IFBhcnNlZENvbmZpZ3VyYXRpb24sIHByb2plY3RQYXRoOiBBYnNvbHV0ZUZzUGF0aCkge1xuICAgIHN1cGVyKFxuICAgICAgICBmcywgY29uZmlnLCBsb2dnZXIsIHJlc29sdmVyLCBiYXNlUGF0aCxcbiAgICAgICAgZ2V0UGF0aE1hcHBpbmdzRnJvbVRzQ29uZmlnKGZzLCB0c0NvbmZpZywgcHJvamVjdFBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgZXh0ZXJuYWwgaW1wb3J0IHBhdGhzIHRoYXQgd2VyZSBleHRyYWN0ZWQgZnJvbSB0aGUgc291cmNlLWZpbGVzXG4gICAqIG9mIHRoZSBwcm9ncmFtIGRlZmluZWQgYnkgdGhlIHRzY29uZmlnLmpzb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0SW5pdGlhbEVudHJ5UG9pbnRQYXRocygpOiBBYnNvbHV0ZUZzUGF0aFtdIHtcbiAgICBjb25zdCBtb2R1bGVSZXNvbHZlciA9IG5ldyBNb2R1bGVSZXNvbHZlcih0aGlzLmZzLCB0aGlzLnBhdGhNYXBwaW5ncywgWycnLCAnLnRzJywgJy9pbmRleC50cyddKTtcbiAgICBjb25zdCBob3N0ID0gbmV3IEVzbURlcGVuZGVuY3lIb3N0KHRoaXMuZnMsIG1vZHVsZVJlc29sdmVyKTtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBjcmVhdGVEZXBlbmRlbmN5SW5mbygpO1xuICAgIGNvbnN0IHJvb3RGaWxlcyA9IHRoaXMudHNDb25maWcucm9vdE5hbWVzLm1hcChyb290TmFtZSA9PiB0aGlzLmZzLnJlc29sdmUocm9vdE5hbWUpKTtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYFVzaW5nIHRoZSBwcm9ncmFtIGZyb20gJHt0aGlzLnRzQ29uZmlnLnByb2plY3R9IHRvIHNlZWQgdGhlIGVudHJ5LXBvaW50IGZpbmRpbmcuYCk7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGBDb2xsZWN0aW5nIGRlcGVuZGVuY2llcyBmcm9tIHRoZSBmb2xsb3dpbmcgZmlsZXM6YCArIHJvb3RGaWxlcy5tYXAoZmlsZSA9PiBgXFxuLSAke2ZpbGV9YCkpO1xuICAgIGhvc3QuY29sbGVjdERlcGVuZGVuY2llc0luRmlsZXMocm9vdEZpbGVzLCBkZXBlbmRlbmNpZXMpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRlcGVuZGVuY2llcy5kZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgZ2l2ZW4gYGVudHJ5UG9pbnRQYXRoYCwgY29tcHV0ZSwgb3IgcmV0cmlldmUsIHRoZSBlbnRyeS1wb2ludCBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nXG4gICAqIHBhdGhzIHRvIG90aGVyIGVudHJ5LXBvaW50cyB0aGF0IHRoaXMgZW50cnktcG9pbnQgZGVwZW5kcyB1cG9uLlxuICAgKlxuICAgKiBJbiB0aGlzIGVudHJ5LXBvaW50IGZpbmRlciwgd2UgdXNlIHRoZSBgRW50cnlQb2ludE1hbmlmZXN0YCB0byBhdm9pZCBjb21wdXRpbmcgZWFjaFxuICAgKiBlbnRyeS1wb2ludCdzIGRlcGVuZGVuY2llcyBpbiB0aGUgY2FzZSB0aGF0IHRoaXMgaGFkIGJlZW4gZG9uZSBwcmV2aW91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gZW50cnlQb2ludFBhdGggdGhlIHBhdGggdG8gdGhlIGVudHJ5LXBvaW50IHdob3NlIGluZm9ybWF0aW9uIGFuZCBkZXBlbmRlbmNpZXMgYXJlIHRvIGJlXG4gICAqICAgICByZXRyaWV2ZWQgb3IgY29tcHV0ZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBlbnRyeS1wb2ludCBhbmQgaXRzIGRlcGVuZGVuY2llcyBvciBgbnVsbGAgaWYgdGhlIGVudHJ5LXBvaW50IGlzIG5vdCBjb21waWxlZCBieVxuICAgKiAgICAgQW5ndWxhciBvciBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRFbnRyeVBvaW50V2l0aERlcHMoZW50cnlQb2ludFBhdGg6IEFic29sdXRlRnNQYXRoKTogRW50cnlQb2ludFdpdGhEZXBlbmRlbmNpZXN8bnVsbCB7XG4gICAgY29uc3QgZW50cnlQb2ludHMgPSB0aGlzLmZpbmRPckxvYWRFbnRyeVBvaW50cygpO1xuICAgIGlmICghZW50cnlQb2ludHMuaGFzKGVudHJ5UG9pbnRQYXRoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5UG9pbnRXaXRoRGVwcyA9IGVudHJ5UG9pbnRzLmdldChlbnRyeVBvaW50UGF0aCkhO1xuICAgIGlmICghZW50cnlQb2ludFdpdGhEZXBzLmVudHJ5UG9pbnQuY29tcGlsZWRCeUFuZ3VsYXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnlQb2ludFdpdGhEZXBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhlIGJhc2UgcGF0aHMgbG9va2luZyBmb3IgZW50cnktcG9pbnRzIG9yIGxvYWQgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIGFuIGVudHJ5LXBvaW50XG4gICAqIG1hbmlmZXN0LCBpZiBhdmFpbGFibGUuXG4gICAqL1xuICBwcml2YXRlIGZpbmRPckxvYWRFbnRyeVBvaW50cygpOiBNYXA8QWJzb2x1dGVGc1BhdGgsIEVudHJ5UG9pbnRXaXRoRGVwZW5kZW5jaWVzPiB7XG4gICAgaWYgKHRoaXMuZW50cnlQb2ludHNXaXRoRGVwZW5kZW5jaWVzID09PSBudWxsKSB7XG4gICAgICBjb25zdCBlbnRyeVBvaW50c1dpdGhEZXBlbmRlbmNpZXMgPSB0aGlzLmVudHJ5UG9pbnRzV2l0aERlcGVuZGVuY2llcyA9XG4gICAgICAgICAgbmV3IE1hcDxBYnNvbHV0ZUZzUGF0aCwgRW50cnlQb2ludFdpdGhEZXBlbmRlbmNpZXM+KCk7XG4gICAgICBmb3IgKGNvbnN0IGJhc2VQYXRoIG9mIHRoaXMuZ2V0QmFzZVBhdGhzKCkpIHtcbiAgICAgICAgY29uc3QgZW50cnlQb2ludHMgPSB0aGlzLmVudHJ5UG9pbnRNYW5pZmVzdC5yZWFkRW50cnlQb2ludHNVc2luZ01hbmlmZXN0KGJhc2VQYXRoKSB8fFxuICAgICAgICAgICAgdGhpcy53YWxrQmFzZVBhdGhGb3JQYWNrYWdlcyhiYXNlUGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyeVBvaW50cykge1xuICAgICAgICAgIGVudHJ5UG9pbnRzV2l0aERlcGVuZGVuY2llcy5zZXQoZS5lbnRyeVBvaW50LnBhdGgsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVudHJ5UG9pbnRzV2l0aERlcGVuZGVuY2llcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggdGhlIGBiYXNlUGF0aGAgZm9yIHBvc3NpYmxlIEFuZ3VsYXIgcGFja2FnZXMgYW5kIGVudHJ5LXBvaW50cy5cbiAgICpcbiAgICogQHBhcmFtIGJhc2VQYXRoIFRoZSBwYXRoIGF0IHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGBFbnRyeVBvaW50YHMgdGhhdCB3ZXJlIGZvdW5kIHdpdGhpbiBgYmFzZVBhdGhgLlxuICAgKi9cbiAgd2Fsa0Jhc2VQYXRoRm9yUGFja2FnZXMoYmFzZVBhdGg6IEFic29sdXRlRnNQYXRoKTogRW50cnlQb2ludFdpdGhEZXBlbmRlbmNpZXNbXSB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoXG4gICAgICAgIGBObyBtYW5pZmVzdCBmb3VuZCBmb3IgJHtiYXNlUGF0aH0gc28gd2Fsa2luZyB0aGUgZGlyZWN0b3JpZXMgZm9yIGVudHJ5LXBvaW50cy5gKTtcbiAgICBjb25zdCBlbnRyeVBvaW50cyA9IHRyYWNrRHVyYXRpb24oXG4gICAgICAgICgpID0+IHRoaXMuZW50cnlQb2ludENvbGxlY3Rvci53YWxrRGlyZWN0b3J5Rm9yUGFja2FnZXMoYmFzZVBhdGgpLFxuICAgICAgICBkdXJhdGlvbiA9PiB0aGlzLmxvZ2dlci5kZWJ1ZyhgV2Fsa2luZyAke2Jhc2VQYXRofSBmb3IgZW50cnktcG9pbnRzIHRvb2sgJHtkdXJhdGlvbn1zLmApKTtcbiAgICB0aGlzLmVudHJ5UG9pbnRNYW5pZmVzdC53cml0ZUVudHJ5UG9pbnRNYW5pZmVzdChiYXNlUGF0aCwgZW50cnlQb2ludHMpO1xuICAgIHJldHVybiBlbnRyeVBvaW50cztcbiAgfVxufVxuIl19