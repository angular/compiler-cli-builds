import { getBasePaths } from './utils';
/**
 * An EntryPointFinder that starts from a set of initial files and only returns entry-points that
 * are dependencies of these files.
 *
 * This is faster than processing all entry-points in the entire file-system, and is used primarily
 * by the CLI integration.
 *
 * There are two concrete implementations of this class.
 *
 * * `TargetEntryPointFinder` - is given a single entry-point as the initial entry-point. This can
 *   be used in the synchronous CLI integration where the build tool has identified an external
 *   import to one of the source files being built.
 * * `ProgramBasedEntryPointFinder` - computes the initial entry-points from the source files
 *   computed from a `tsconfig.json` file. This can be used in the asynchronous CLI integration
 *   where the `tsconfig.json` to be used to do the build is known.
 */
export class TracingEntryPointFinder {
    constructor(fs, config, logger, resolver, basePath, pathMappings) {
        this.fs = fs;
        this.config = config;
        this.logger = logger;
        this.resolver = resolver;
        this.basePath = basePath;
        this.pathMappings = pathMappings;
        this.basePaths = null;
    }
    /**
     * Search for Angular package entry-points.
     */
    findEntryPoints() {
        const unsortedEntryPoints = new Map();
        const unprocessedPaths = this.getInitialEntryPointPaths();
        while (unprocessedPaths.length > 0) {
            const path = unprocessedPaths.shift();
            const entryPointWithDeps = this.getEntryPointWithDeps(path);
            if (entryPointWithDeps === null) {
                continue;
            }
            unsortedEntryPoints.set(entryPointWithDeps.entryPoint.path, entryPointWithDeps);
            entryPointWithDeps.depInfo.dependencies.forEach(dep => {
                if (!unsortedEntryPoints.has(dep)) {
                    unprocessedPaths.push(dep);
                }
            });
        }
        return this.resolver.sortEntryPointsByDependency(Array.from(unsortedEntryPoints.values()));
    }
    /**
     * Parse the path-mappings to compute the base-paths that need to be considered when finding
     * entry-points.
     *
     * This processing can be time-consuming if the path-mappings are complex or extensive.
     * So the result is cached locally once computed.
     */
    getBasePaths() {
        if (this.basePaths === null) {
            this.basePaths = getBasePaths(this.logger, this.basePath, this.pathMappings);
        }
        return this.basePaths;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZ19lbnRyeV9wb2ludF9maW5kZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbmdjYy9zcmMvZW50cnlfcG9pbnRfZmluZGVyL3RyYWNpbmdfZW50cnlfcG9pbnRfZmluZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWVBLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFckM7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsTUFBTSxPQUFnQix1QkFBdUI7SUFHM0MsWUFDYyxFQUFzQixFQUFZLE1BQXlCLEVBQzNELE1BQWMsRUFBWSxRQUE0QixFQUN0RCxRQUF3QixFQUFZLFlBQW9DO1FBRnhFLE9BQUUsR0FBRixFQUFFLENBQW9CO1FBQVksV0FBTSxHQUFOLE1BQU0sQ0FBbUI7UUFDM0QsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUFZLGFBQVEsR0FBUixRQUFRLENBQW9CO1FBQ3RELGFBQVEsR0FBUixRQUFRLENBQWdCO1FBQVksaUJBQVksR0FBWixZQUFZLENBQXdCO1FBTDlFLGNBQVMsR0FBMEIsSUFBSSxDQUFDO0lBS3lDLENBQUM7SUFFMUY7O09BRUc7SUFDSCxlQUFlO1FBQ2IsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLEdBQUcsRUFBOEMsQ0FBQztRQUNsRixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO1FBQzFELE9BQU8sZ0JBQWdCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNsQyxNQUFNLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUcsQ0FBQztZQUN2QyxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1RCxJQUFJLGtCQUFrQixLQUFLLElBQUksRUFBRTtnQkFDL0IsU0FBUzthQUNWO1lBQ0QsbUJBQW1CLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztZQUNoRixrQkFBa0IsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDakMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUM1QjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsMkJBQTJCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDN0YsQ0FBQztJQXNCRDs7Ozs7O09BTUc7SUFDTyxZQUFZO1FBQ3BCLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUM5RTtRQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7QWJzb2x1dGVGc1BhdGgsIFBhdGhNYW5pcHVsYXRpb24sIFJlYWRvbmx5RmlsZVN5c3RlbX0gZnJvbSAnLi4vLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi8uLi9zcmMvbmd0c2MvbG9nZ2luZyc7XG5pbXBvcnQge0VudHJ5UG9pbnRXaXRoRGVwZW5kZW5jaWVzfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvZGVwZW5kZW5jeV9ob3N0JztcbmltcG9ydCB7RGVwZW5kZW5jeVJlc29sdmVyLCBTb3J0ZWRFbnRyeVBvaW50c0luZm99IGZyb20gJy4uL2RlcGVuZGVuY2llcy9kZXBlbmRlbmN5X3Jlc29sdmVyJztcbmltcG9ydCB7TmdjY0NvbmZpZ3VyYXRpb259IGZyb20gJy4uL3BhY2thZ2VzL2NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHtQYXRoTWFwcGluZ3N9IGZyb20gJy4uL3BhdGhfbWFwcGluZ3MnO1xuXG5pbXBvcnQge0VudHJ5UG9pbnRGaW5kZXJ9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7Z2V0QmFzZVBhdGhzfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gKiBBbiBFbnRyeVBvaW50RmluZGVyIHRoYXQgc3RhcnRzIGZyb20gYSBzZXQgb2YgaW5pdGlhbCBmaWxlcyBhbmQgb25seSByZXR1cm5zIGVudHJ5LXBvaW50cyB0aGF0XG4gKiBhcmUgZGVwZW5kZW5jaWVzIG9mIHRoZXNlIGZpbGVzLlxuICpcbiAqIFRoaXMgaXMgZmFzdGVyIHRoYW4gcHJvY2Vzc2luZyBhbGwgZW50cnktcG9pbnRzIGluIHRoZSBlbnRpcmUgZmlsZS1zeXN0ZW0sIGFuZCBpcyB1c2VkIHByaW1hcmlseVxuICogYnkgdGhlIENMSSBpbnRlZ3JhdGlvbi5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGNvbmNyZXRlIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNsYXNzLlxuICpcbiAqICogYFRhcmdldEVudHJ5UG9pbnRGaW5kZXJgIC0gaXMgZ2l2ZW4gYSBzaW5nbGUgZW50cnktcG9pbnQgYXMgdGhlIGluaXRpYWwgZW50cnktcG9pbnQuIFRoaXMgY2FuXG4gKiAgIGJlIHVzZWQgaW4gdGhlIHN5bmNocm9ub3VzIENMSSBpbnRlZ3JhdGlvbiB3aGVyZSB0aGUgYnVpbGQgdG9vbCBoYXMgaWRlbnRpZmllZCBhbiBleHRlcm5hbFxuICogICBpbXBvcnQgdG8gb25lIG9mIHRoZSBzb3VyY2UgZmlsZXMgYmVpbmcgYnVpbHQuXG4gKiAqIGBQcm9ncmFtQmFzZWRFbnRyeVBvaW50RmluZGVyYCAtIGNvbXB1dGVzIHRoZSBpbml0aWFsIGVudHJ5LXBvaW50cyBmcm9tIHRoZSBzb3VyY2UgZmlsZXNcbiAqICAgY29tcHV0ZWQgZnJvbSBhIGB0c2NvbmZpZy5qc29uYCBmaWxlLiBUaGlzIGNhbiBiZSB1c2VkIGluIHRoZSBhc3luY2hyb25vdXMgQ0xJIGludGVncmF0aW9uXG4gKiAgIHdoZXJlIHRoZSBgdHNjb25maWcuanNvbmAgdG8gYmUgdXNlZCB0byBkbyB0aGUgYnVpbGQgaXMga25vd24uXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFjaW5nRW50cnlQb2ludEZpbmRlciBpbXBsZW1lbnRzIEVudHJ5UG9pbnRGaW5kZXIge1xuICBwcml2YXRlIGJhc2VQYXRoczogQWJzb2x1dGVGc1BhdGhbXXxudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByb3RlY3RlZCBmczogUmVhZG9ubHlGaWxlU3lzdGVtLCBwcm90ZWN0ZWQgY29uZmlnOiBOZ2NjQ29uZmlndXJhdGlvbixcbiAgICAgIHByb3RlY3RlZCBsb2dnZXI6IExvZ2dlciwgcHJvdGVjdGVkIHJlc29sdmVyOiBEZXBlbmRlbmN5UmVzb2x2ZXIsXG4gICAgICBwcm90ZWN0ZWQgYmFzZVBhdGg6IEFic29sdXRlRnNQYXRoLCBwcm90ZWN0ZWQgcGF0aE1hcHBpbmdzOiBQYXRoTWFwcGluZ3N8dW5kZWZpbmVkKSB7fVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIEFuZ3VsYXIgcGFja2FnZSBlbnRyeS1wb2ludHMuXG4gICAqL1xuICBmaW5kRW50cnlQb2ludHMoKTogU29ydGVkRW50cnlQb2ludHNJbmZvIHtcbiAgICBjb25zdCB1bnNvcnRlZEVudHJ5UG9pbnRzID0gbmV3IE1hcDxBYnNvbHV0ZUZzUGF0aCwgRW50cnlQb2ludFdpdGhEZXBlbmRlbmNpZXM+KCk7XG4gICAgY29uc3QgdW5wcm9jZXNzZWRQYXRocyA9IHRoaXMuZ2V0SW5pdGlhbEVudHJ5UG9pbnRQYXRocygpO1xuICAgIHdoaWxlICh1bnByb2Nlc3NlZFBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhdGggPSB1bnByb2Nlc3NlZFBhdGhzLnNoaWZ0KCkhO1xuICAgICAgY29uc3QgZW50cnlQb2ludFdpdGhEZXBzID0gdGhpcy5nZXRFbnRyeVBvaW50V2l0aERlcHMocGF0aCk7XG4gICAgICBpZiAoZW50cnlQb2ludFdpdGhEZXBzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdW5zb3J0ZWRFbnRyeVBvaW50cy5zZXQoZW50cnlQb2ludFdpdGhEZXBzLmVudHJ5UG9pbnQucGF0aCwgZW50cnlQb2ludFdpdGhEZXBzKTtcbiAgICAgIGVudHJ5UG9pbnRXaXRoRGVwcy5kZXBJbmZvLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICAgIGlmICghdW5zb3J0ZWRFbnRyeVBvaW50cy5oYXMoZGVwKSkge1xuICAgICAgICAgIHVucHJvY2Vzc2VkUGF0aHMucHVzaChkZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZXIuc29ydEVudHJ5UG9pbnRzQnlEZXBlbmRlbmN5KEFycmF5LmZyb20odW5zb3J0ZWRFbnRyeVBvaW50cy52YWx1ZXMoKSkpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVudHJ5LXBvaW50IHBhdGhzIGZyb20gd2hpY2ggdG8gc3RhcnQgdGhlIHRyYWNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEluaXRpYWxFbnRyeVBvaW50UGF0aHMoKTogQWJzb2x1dGVGc1BhdGhbXTtcblxuICAvKipcbiAgICogRm9yIHRoZSBnaXZlbiBgZW50cnlQb2ludFBhdGhgLCBjb21wdXRlLCBvciByZXRyaWV2ZSwgdGhlIGVudHJ5LXBvaW50IGluZm9ybWF0aW9uLCBpbmNsdWRpbmdcbiAgICogcGF0aHMgdG8gb3RoZXIgZW50cnktcG9pbnRzIHRoYXQgdGhpcyBlbnRyeS1wb2ludCBkZXBlbmRzIHVwb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbnRyeVBvaW50UGF0aCB0aGUgcGF0aCB0byB0aGUgZW50cnktcG9pbnQgd2hvc2UgaW5mb3JtYXRpb24gYW5kIGRlcGVuZGVuY2llcyBhcmUgdG8gYmVcbiAgICogICAgIHJldHJpZXZlZCBvciBjb21wdXRlZC5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIGVudHJ5LXBvaW50IGFuZCBpdHMgZGVwZW5kZW5jaWVzIG9yIGBudWxsYCBpZiB0aGUgZW50cnktcG9pbnQgaXMgbm90IGNvbXBpbGVkIGJ5XG4gICAqICAgICBBbmd1bGFyIG9yIGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEVudHJ5UG9pbnRXaXRoRGVwcyhlbnRyeVBvaW50UGF0aDogQWJzb2x1dGVGc1BhdGgpOlxuICAgICAgRW50cnlQb2ludFdpdGhEZXBlbmRlbmNpZXN8bnVsbDtcblxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcGF0aC1tYXBwaW5ncyB0byBjb21wdXRlIHRoZSBiYXNlLXBhdGhzIHRoYXQgbmVlZCB0byBiZSBjb25zaWRlcmVkIHdoZW4gZmluZGluZ1xuICAgKiBlbnRyeS1wb2ludHMuXG4gICAqXG4gICAqIFRoaXMgcHJvY2Vzc2luZyBjYW4gYmUgdGltZS1jb25zdW1pbmcgaWYgdGhlIHBhdGgtbWFwcGluZ3MgYXJlIGNvbXBsZXggb3IgZXh0ZW5zaXZlLlxuICAgKiBTbyB0aGUgcmVzdWx0IGlzIGNhY2hlZCBsb2NhbGx5IG9uY2UgY29tcHV0ZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QmFzZVBhdGhzKCkge1xuICAgIGlmICh0aGlzLmJhc2VQYXRocyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5iYXNlUGF0aHMgPSBnZXRCYXNlUGF0aHModGhpcy5sb2dnZXIsIHRoaXMuYmFzZVBhdGgsIHRoaXMucGF0aE1hcHBpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmFzZVBhdGhzO1xuICB9XG59XG4iXX0=