import { getBasePaths, trackDuration } from './utils';
/**
 * An EntryPointFinder that searches for all entry-points that can be found given a `basePath` and
 * `pathMappings`.
 */
export class DirectoryWalkerEntryPointFinder {
    constructor(logger, resolver, entryPointCollector, entryPointManifest, sourceDirectory, pathMappings) {
        this.logger = logger;
        this.resolver = resolver;
        this.entryPointCollector = entryPointCollector;
        this.entryPointManifest = entryPointManifest;
        this.sourceDirectory = sourceDirectory;
        this.pathMappings = pathMappings;
        this.basePaths = getBasePaths(this.logger, this.sourceDirectory, this.pathMappings);
    }
    /**
     * Search the `sourceDirectory`, and sub-directories, using `pathMappings` as necessary, to find
     * all package entry-points.
     */
    findEntryPoints() {
        const unsortedEntryPoints = [];
        for (const basePath of this.basePaths) {
            const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) ||
                this.walkBasePathForPackages(basePath);
            entryPoints.forEach(e => unsortedEntryPoints.push(e));
        }
        return this.resolver.sortEntryPointsByDependency(unsortedEntryPoints);
    }
    /**
     * Search the `basePath` for possible Angular packages and entry-points.
     *
     * @param basePath The path at which to start the search.
     * @returns an array of `EntryPoint`s that were found within `basePath`.
     */
    walkBasePathForPackages(basePath) {
        this.logger.debug(`No manifest found for ${basePath} so walking the directories for entry-points.`);
        const entryPoints = trackDuration(() => this.entryPointCollector.walkDirectoryForPackages(basePath), duration => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));
        this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);
        return entryPoints;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlyZWN0b3J5X3dhbGtlcl9lbnRyeV9wb2ludF9maW5kZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbmdjYy9zcmMvZW50cnlfcG9pbnRfZmluZGVyL2RpcmVjdG9yeV93YWxrZXJfZW50cnlfcG9pbnRfZmluZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdCQSxPQUFPLEVBQUMsWUFBWSxFQUFFLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUVwRDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sK0JBQStCO0lBRTFDLFlBQ1ksTUFBYyxFQUFVLFFBQTRCLEVBQ3BELG1CQUF3QyxFQUN4QyxrQkFBc0MsRUFBVSxlQUErQixFQUMvRSxZQUFvQztRQUhwQyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBb0I7UUFDcEQsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4Qyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO1FBQVUsb0JBQWUsR0FBZixlQUFlLENBQWdCO1FBQy9FLGlCQUFZLEdBQVosWUFBWSxDQUF3QjtRQUx4QyxjQUFTLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFLcEMsQ0FBQztJQUVwRDs7O09BR0c7SUFDSCxlQUFlO1FBQ2IsTUFBTSxtQkFBbUIsR0FBaUMsRUFBRSxDQUFDO1FBQzdELEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNyQyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsNEJBQTRCLENBQUMsUUFBUSxDQUFDO2dCQUM5RSxJQUFJLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0MsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3ZEO1FBQ0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLDJCQUEyQixDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsdUJBQXVCLENBQUMsUUFBd0I7UUFDOUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQ2IseUJBQXlCLFFBQVEsK0NBQStDLENBQUMsQ0FBQztRQUN0RixNQUFNLFdBQVcsR0FBRyxhQUFhLENBQzdCLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsRUFDakUsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLFFBQVEsMEJBQTBCLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM5RixJQUFJLENBQUMsa0JBQWtCLENBQUMsdUJBQXVCLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3ZFLE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtBYnNvbHV0ZUZzUGF0aH0gZnJvbSAnLi4vLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi8uLi9zcmMvbmd0c2MvbG9nZ2luZyc7XG5pbXBvcnQge0VudHJ5UG9pbnRXaXRoRGVwZW5kZW5jaWVzfSBmcm9tICcuLi9kZXBlbmRlbmNpZXMvZGVwZW5kZW5jeV9ob3N0JztcbmltcG9ydCB7RGVwZW5kZW5jeVJlc29sdmVyLCBTb3J0ZWRFbnRyeVBvaW50c0luZm99IGZyb20gJy4uL2RlcGVuZGVuY2llcy9kZXBlbmRlbmN5X3Jlc29sdmVyJztcbmltcG9ydCB7RW50cnlQb2ludE1hbmlmZXN0fSBmcm9tICcuLi9wYWNrYWdlcy9lbnRyeV9wb2ludF9tYW5pZmVzdCc7XG5pbXBvcnQge1BhdGhNYXBwaW5nc30gZnJvbSAnLi4vcGF0aF9tYXBwaW5ncyc7XG5cbmltcG9ydCB7RW50cnlQb2ludENvbGxlY3Rvcn0gZnJvbSAnLi9lbnRyeV9wb2ludF9jb2xsZWN0b3InO1xuaW1wb3J0IHtFbnRyeVBvaW50RmluZGVyfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQge2dldEJhc2VQYXRocywgdHJhY2tEdXJhdGlvbn0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQW4gRW50cnlQb2ludEZpbmRlciB0aGF0IHNlYXJjaGVzIGZvciBhbGwgZW50cnktcG9pbnRzIHRoYXQgY2FuIGJlIGZvdW5kIGdpdmVuIGEgYGJhc2VQYXRoYCBhbmRcbiAqIGBwYXRoTWFwcGluZ3NgLlxuICovXG5leHBvcnQgY2xhc3MgRGlyZWN0b3J5V2Fsa2VyRW50cnlQb2ludEZpbmRlciBpbXBsZW1lbnRzIEVudHJ5UG9pbnRGaW5kZXIge1xuICBwcml2YXRlIGJhc2VQYXRocyA9IGdldEJhc2VQYXRocyh0aGlzLmxvZ2dlciwgdGhpcy5zb3VyY2VEaXJlY3RvcnksIHRoaXMucGF0aE1hcHBpbmdzKTtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIGxvZ2dlcjogTG9nZ2VyLCBwcml2YXRlIHJlc29sdmVyOiBEZXBlbmRlbmN5UmVzb2x2ZXIsXG4gICAgICBwcml2YXRlIGVudHJ5UG9pbnRDb2xsZWN0b3I6IEVudHJ5UG9pbnRDb2xsZWN0b3IsXG4gICAgICBwcml2YXRlIGVudHJ5UG9pbnRNYW5pZmVzdDogRW50cnlQb2ludE1hbmlmZXN0LCBwcml2YXRlIHNvdXJjZURpcmVjdG9yeTogQWJzb2x1dGVGc1BhdGgsXG4gICAgICBwcml2YXRlIHBhdGhNYXBwaW5nczogUGF0aE1hcHBpbmdzfHVuZGVmaW5lZCkge31cblxuICAvKipcbiAgICogU2VhcmNoIHRoZSBgc291cmNlRGlyZWN0b3J5YCwgYW5kIHN1Yi1kaXJlY3RvcmllcywgdXNpbmcgYHBhdGhNYXBwaW5nc2AgYXMgbmVjZXNzYXJ5LCB0byBmaW5kXG4gICAqIGFsbCBwYWNrYWdlIGVudHJ5LXBvaW50cy5cbiAgICovXG4gIGZpbmRFbnRyeVBvaW50cygpOiBTb3J0ZWRFbnRyeVBvaW50c0luZm8ge1xuICAgIGNvbnN0IHVuc29ydGVkRW50cnlQb2ludHM6IEVudHJ5UG9pbnRXaXRoRGVwZW5kZW5jaWVzW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJhc2VQYXRoIG9mIHRoaXMuYmFzZVBhdGhzKSB7XG4gICAgICBjb25zdCBlbnRyeVBvaW50cyA9IHRoaXMuZW50cnlQb2ludE1hbmlmZXN0LnJlYWRFbnRyeVBvaW50c1VzaW5nTWFuaWZlc3QoYmFzZVBhdGgpIHx8XG4gICAgICAgICAgdGhpcy53YWxrQmFzZVBhdGhGb3JQYWNrYWdlcyhiYXNlUGF0aCk7XG4gICAgICBlbnRyeVBvaW50cy5mb3JFYWNoKGUgPT4gdW5zb3J0ZWRFbnRyeVBvaW50cy5wdXNoKGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZXIuc29ydEVudHJ5UG9pbnRzQnlEZXBlbmRlbmN5KHVuc29ydGVkRW50cnlQb2ludHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCB0aGUgYGJhc2VQYXRoYCBmb3IgcG9zc2libGUgQW5ndWxhciBwYWNrYWdlcyBhbmQgZW50cnktcG9pbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gYmFzZVBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgYEVudHJ5UG9pbnRgcyB0aGF0IHdlcmUgZm91bmQgd2l0aGluIGBiYXNlUGF0aGAuXG4gICAqL1xuICB3YWxrQmFzZVBhdGhGb3JQYWNrYWdlcyhiYXNlUGF0aDogQWJzb2x1dGVGc1BhdGgpOiBFbnRyeVBvaW50V2l0aERlcGVuZGVuY2llc1tdIHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYE5vIG1hbmlmZXN0IGZvdW5kIGZvciAke2Jhc2VQYXRofSBzbyB3YWxraW5nIHRoZSBkaXJlY3RvcmllcyBmb3IgZW50cnktcG9pbnRzLmApO1xuICAgIGNvbnN0IGVudHJ5UG9pbnRzID0gdHJhY2tEdXJhdGlvbihcbiAgICAgICAgKCkgPT4gdGhpcy5lbnRyeVBvaW50Q29sbGVjdG9yLndhbGtEaXJlY3RvcnlGb3JQYWNrYWdlcyhiYXNlUGF0aCksXG4gICAgICAgIGR1cmF0aW9uID0+IHRoaXMubG9nZ2VyLmRlYnVnKGBXYWxraW5nICR7YmFzZVBhdGh9IGZvciBlbnRyeS1wb2ludHMgdG9vayAke2R1cmF0aW9ufXMuYCkpO1xuICAgIHRoaXMuZW50cnlQb2ludE1hbmlmZXN0LndyaXRlRW50cnlQb2ludE1hbmlmZXN0KGJhc2VQYXRoLCBlbnRyeVBvaW50cyk7XG4gICAgcmV0dXJuIGVudHJ5UG9pbnRzO1xuICB9XG59XG4iXX0=