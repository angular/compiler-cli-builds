import * as ts from 'typescript';
import { translateStatement } from '../../../src/ngtsc/translator';
import { getContainingStatement } from '../host/esm2015_host';
import { EsmRenderingFormatter } from './esm_rendering_formatter';
/**
 * A RenderingFormatter that works with files that use ECMAScript Module `import` and `export`
 * statements, but instead of `class` declarations it uses ES5 `function` wrappers for classes.
 */
export class Esm5RenderingFormatter extends EsmRenderingFormatter {
    /**
     * Add the definitions, directly before the return statement, inside the IIFE of each decorated
     * class.
     */
    addDefinitions(output, compiledClass, definitions) {
        const classSymbol = this.host.getClassSymbol(compiledClass.declaration);
        if (!classSymbol) {
            throw new Error(`Compiled class "${compiledClass.name}" in "${compiledClass.declaration.getSourceFile()
                .fileName}" does not have a valid syntax.\n` +
                `Expected an ES5 IIFE wrapped function. But got:\n` +
                compiledClass.declaration.getText());
        }
        const declarationStatement = getContainingStatement(classSymbol.implementation.valueDeclaration);
        const iifeBody = declarationStatement.parent;
        if (!iifeBody || !ts.isBlock(iifeBody)) {
            throw new Error(`Compiled class declaration is not inside an IIFE: ${compiledClass.name} in ${compiledClass.declaration.getSourceFile().fileName}`);
        }
        const returnStatement = iifeBody.statements.find(ts.isReturnStatement);
        if (!returnStatement) {
            throw new Error(`Compiled class wrapper IIFE does not have a return statement: ${compiledClass.name} in ${compiledClass.declaration.getSourceFile().fileName}`);
        }
        const insertionPoint = returnStatement.getFullStart();
        output.appendLeft(insertionPoint, '\n' + definitions);
    }
    /**
     * Convert a `Statement` to JavaScript code in a format suitable for rendering by this formatter.
     *
     * @param stmt The `Statement` to print.
     * @param sourceFile A `ts.SourceFile` that provides context for the statement. See
     *     `ts.Printer#printNode()` for more info.
     * @param importManager The `ImportManager` to use for managing imports.
     *
     * @return The JavaScript code corresponding to `stmt` (in the appropriate format).
     */
    printStatement(stmt, sourceFile, importManager) {
        const node = translateStatement(stmt, importManager, { downlevelTaggedTemplates: true, downlevelVariableDeclarations: true });
        const code = this.printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);
        return code;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNtNV9yZW5kZXJpbmdfZm9ybWF0dGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL25nY2Mvc3JjL3JlbmRlcmluZy9lc201X3JlbmRlcmluZ19mb3JtYXR0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBU0EsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFakMsT0FBTyxFQUFnQixrQkFBa0IsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBRWhGLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRTVELE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRWhFOzs7R0FHRztBQUNILE1BQU0sT0FBTyxzQkFBdUIsU0FBUSxxQkFBcUI7SUFDL0Q7OztPQUdHO0lBQ0gsY0FBYyxDQUFDLE1BQW1CLEVBQUUsYUFBNEIsRUFBRSxXQUFtQjtRQUNuRixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDeEUsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUNYLG1CQUFtQixhQUFhLENBQUMsSUFBSSxTQUNqQyxhQUFhLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRTtpQkFDcEMsUUFBUSxtQ0FBbUM7Z0JBQ3BELG1EQUFtRDtnQkFDbkQsYUFBYSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQzFDO1FBQ0QsTUFBTSxvQkFBb0IsR0FDdEIsc0JBQXNCLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXhFLE1BQU0sUUFBUSxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQztRQUM3QyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxhQUFhLENBQUMsSUFBSSxPQUNuRixhQUFhLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDM0Q7UUFFRCxNQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUVBQ1osYUFBYSxDQUFDLElBQUksT0FBTyxhQUFhLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDcEY7UUFFRCxNQUFNLGNBQWMsR0FBRyxlQUFlLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDdEQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUUsSUFBSSxHQUFHLFdBQVcsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxjQUFjLENBQUMsSUFBZSxFQUFFLFVBQXlCLEVBQUUsYUFBNEI7UUFDckYsTUFBTSxJQUFJLEdBQUcsa0JBQWtCLENBQzNCLElBQUksRUFBRSxhQUFhLEVBQUUsRUFBQyx3QkFBd0IsRUFBRSxJQUFJLEVBQUUsNkJBQTZCLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUNoRyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFL0UsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7U3RhdGVtZW50fSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgTWFnaWNTdHJpbmcgZnJvbSAnbWFnaWMtc3RyaW5nJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0ltcG9ydE1hbmFnZXIsIHRyYW5zbGF0ZVN0YXRlbWVudH0gZnJvbSAnLi4vLi4vLi4vc3JjL25ndHNjL3RyYW5zbGF0b3InO1xuaW1wb3J0IHtDb21waWxlZENsYXNzfSBmcm9tICcuLi9hbmFseXNpcy90eXBlcyc7XG5pbXBvcnQge2dldENvbnRhaW5pbmdTdGF0ZW1lbnR9IGZyb20gJy4uL2hvc3QvZXNtMjAxNV9ob3N0JztcblxuaW1wb3J0IHtFc21SZW5kZXJpbmdGb3JtYXR0ZXJ9IGZyb20gJy4vZXNtX3JlbmRlcmluZ19mb3JtYXR0ZXInO1xuXG4vKipcbiAqIEEgUmVuZGVyaW5nRm9ybWF0dGVyIHRoYXQgd29ya3Mgd2l0aCBmaWxlcyB0aGF0IHVzZSBFQ01BU2NyaXB0IE1vZHVsZSBgaW1wb3J0YCBhbmQgYGV4cG9ydGBcbiAqIHN0YXRlbWVudHMsIGJ1dCBpbnN0ZWFkIG9mIGBjbGFzc2AgZGVjbGFyYXRpb25zIGl0IHVzZXMgRVM1IGBmdW5jdGlvbmAgd3JhcHBlcnMgZm9yIGNsYXNzZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFc201UmVuZGVyaW5nRm9ybWF0dGVyIGV4dGVuZHMgRXNtUmVuZGVyaW5nRm9ybWF0dGVyIHtcbiAgLyoqXG4gICAqIEFkZCB0aGUgZGVmaW5pdGlvbnMsIGRpcmVjdGx5IGJlZm9yZSB0aGUgcmV0dXJuIHN0YXRlbWVudCwgaW5zaWRlIHRoZSBJSUZFIG9mIGVhY2ggZGVjb3JhdGVkXG4gICAqIGNsYXNzLlxuICAgKi9cbiAgYWRkRGVmaW5pdGlvbnMob3V0cHV0OiBNYWdpY1N0cmluZywgY29tcGlsZWRDbGFzczogQ29tcGlsZWRDbGFzcywgZGVmaW5pdGlvbnM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGNsYXNzU3ltYm9sID0gdGhpcy5ob3N0LmdldENsYXNzU3ltYm9sKGNvbXBpbGVkQ2xhc3MuZGVjbGFyYXRpb24pO1xuICAgIGlmICghY2xhc3NTeW1ib2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ29tcGlsZWQgY2xhc3MgXCIke2NvbXBpbGVkQ2xhc3MubmFtZX1cIiBpbiBcIiR7XG4gICAgICAgICAgICAgIGNvbXBpbGVkQ2xhc3MuZGVjbGFyYXRpb24uZ2V0U291cmNlRmlsZSgpXG4gICAgICAgICAgICAgICAgICAuZmlsZU5hbWV9XCIgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHN5bnRheC5cXG5gICtcbiAgICAgICAgICBgRXhwZWN0ZWQgYW4gRVM1IElJRkUgd3JhcHBlZCBmdW5jdGlvbi4gQnV0IGdvdDpcXG5gICtcbiAgICAgICAgICBjb21waWxlZENsYXNzLmRlY2xhcmF0aW9uLmdldFRleHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGRlY2xhcmF0aW9uU3RhdGVtZW50ID1cbiAgICAgICAgZ2V0Q29udGFpbmluZ1N0YXRlbWVudChjbGFzc1N5bWJvbC5pbXBsZW1lbnRhdGlvbi52YWx1ZURlY2xhcmF0aW9uKTtcblxuICAgIGNvbnN0IGlpZmVCb2R5ID0gZGVjbGFyYXRpb25TdGF0ZW1lbnQucGFyZW50O1xuICAgIGlmICghaWlmZUJvZHkgfHwgIXRzLmlzQmxvY2soaWlmZUJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGVkIGNsYXNzIGRlY2xhcmF0aW9uIGlzIG5vdCBpbnNpZGUgYW4gSUlGRTogJHtjb21waWxlZENsYXNzLm5hbWV9IGluICR7XG4gICAgICAgICAgY29tcGlsZWRDbGFzcy5kZWNsYXJhdGlvbi5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0dXJuU3RhdGVtZW50ID0gaWlmZUJvZHkuc3RhdGVtZW50cy5maW5kKHRzLmlzUmV0dXJuU3RhdGVtZW50KTtcbiAgICBpZiAoIXJldHVyblN0YXRlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlZCBjbGFzcyB3cmFwcGVyIElJRkUgZG9lcyBub3QgaGF2ZSBhIHJldHVybiBzdGF0ZW1lbnQ6ICR7XG4gICAgICAgICAgY29tcGlsZWRDbGFzcy5uYW1lfSBpbiAke2NvbXBpbGVkQ2xhc3MuZGVjbGFyYXRpb24uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGluc2VydGlvblBvaW50ID0gcmV0dXJuU3RhdGVtZW50LmdldEZ1bGxTdGFydCgpO1xuICAgIG91dHB1dC5hcHBlbmRMZWZ0KGluc2VydGlvblBvaW50LCAnXFxuJyArIGRlZmluaXRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgYFN0YXRlbWVudGAgdG8gSmF2YVNjcmlwdCBjb2RlIGluIGEgZm9ybWF0IHN1aXRhYmxlIGZvciByZW5kZXJpbmcgYnkgdGhpcyBmb3JtYXR0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzdG10IFRoZSBgU3RhdGVtZW50YCB0byBwcmludC5cbiAgICogQHBhcmFtIHNvdXJjZUZpbGUgQSBgdHMuU291cmNlRmlsZWAgdGhhdCBwcm92aWRlcyBjb250ZXh0IGZvciB0aGUgc3RhdGVtZW50LiBTZWVcbiAgICogICAgIGB0cy5QcmludGVyI3ByaW50Tm9kZSgpYCBmb3IgbW9yZSBpbmZvLlxuICAgKiBAcGFyYW0gaW1wb3J0TWFuYWdlciBUaGUgYEltcG9ydE1hbmFnZXJgIHRvIHVzZSBmb3IgbWFuYWdpbmcgaW1wb3J0cy5cbiAgICpcbiAgICogQHJldHVybiBUaGUgSmF2YVNjcmlwdCBjb2RlIGNvcnJlc3BvbmRpbmcgdG8gYHN0bXRgIChpbiB0aGUgYXBwcm9wcmlhdGUgZm9ybWF0KS5cbiAgICovXG4gIHByaW50U3RhdGVtZW50KHN0bXQ6IFN0YXRlbWVudCwgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgaW1wb3J0TWFuYWdlcjogSW1wb3J0TWFuYWdlcik6IHN0cmluZyB7XG4gICAgY29uc3Qgbm9kZSA9IHRyYW5zbGF0ZVN0YXRlbWVudChcbiAgICAgICAgc3RtdCwgaW1wb3J0TWFuYWdlciwge2Rvd25sZXZlbFRhZ2dlZFRlbXBsYXRlczogdHJ1ZSwgZG93bmxldmVsVmFyaWFibGVEZWNsYXJhdGlvbnM6IHRydWV9KTtcbiAgICBjb25zdCBjb2RlID0gdGhpcy5wcmludGVyLnByaW50Tm9kZSh0cy5FbWl0SGludC5VbnNwZWNpZmllZCwgbm9kZSwgc291cmNlRmlsZSk7XG5cbiAgICByZXR1cm4gY29kZTtcbiAgfVxufVxuIl19