/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
import { absoluteFrom, isRooted } from '../../src/ngtsc/file_system';
import { KnownDeclaration } from '../../src/ngtsc/reflection';
export function getOriginalSymbol(checker) {
    return function (symbol) {
        return ts.SymbolFlags.Alias & symbol.flags ? checker.getAliasedSymbol(symbol) : symbol;
    };
}
export function isDefined(value) {
    return (value !== undefined) && (value !== null);
}
export function getNameText(name) {
    return ts.isIdentifier(name) || ts.isLiteralExpression(name) ? name.text : name.getText();
}
/**
 * Parse down the AST and capture all the nodes that satisfy the test.
 * @param node The start node.
 * @param test The function that tests whether a node should be included.
 * @returns a collection of nodes that satisfy the test.
 */
export function findAll(node, test) {
    const nodes = [];
    findAllVisitor(node);
    return nodes;
    function findAllVisitor(n) {
        if (test(n)) {
            nodes.push(n);
        }
        else {
            n.forEachChild(child => findAllVisitor(child));
        }
    }
}
/**
 * Does the given declaration have a name which is an identifier?
 * @param declaration The declaration to test.
 * @returns true if the declaration has an identifier for a name.
 */
export function hasNameIdentifier(declaration) {
    const namedDeclaration = declaration;
    return namedDeclaration.name !== undefined && ts.isIdentifier(namedDeclaration.name);
}
/**
 * Test whether a path is "relative".
 *
 * Relative paths start with `/`, `./` or `../` (or the Windows equivalents); or are simply `.` or
 * `..`.
 */
export function isRelativePath(path) {
    return isRooted(path) || /^\.\.?(\/|\\|$)/.test(path);
}
/**
 * A `Map`-like object that can compute and memoize a missing value for any key.
 *
 * The computed values are memoized, so the factory function is not called more than once per key.
 * This is useful for storing values that are expensive to compute and may be used multiple times.
 */
// NOTE:
// Ideally, this class should extend `Map`, but that causes errors in ES5 transpiled code:
// `TypeError: Constructor Map requires 'new'`
export class FactoryMap {
    constructor(factory, entries) {
        this.factory = factory;
        this.internalMap = new Map(entries);
    }
    get(key) {
        if (!this.internalMap.has(key)) {
            this.internalMap.set(key, this.factory(key));
        }
        return this.internalMap.get(key);
    }
    set(key, value) {
        this.internalMap.set(key, value);
    }
}
/**
 * Attempt to resolve a `path` to a file by appending the provided `postFixes`
 * to the `path` and checking if the file exists on disk.
 * @returns An absolute path to the first matching existing file, or `null` if none exist.
 */
export function resolveFileWithPostfixes(fs, path, postFixes) {
    for (const postFix of postFixes) {
        const testPath = absoluteFrom(path + postFix);
        if (fs.exists(testPath) && fs.stat(testPath).isFile()) {
            return testPath;
        }
    }
    return null;
}
/**
 * Determine whether a function declaration corresponds with a TypeScript helper function, returning
 * its kind if so or null if the declaration does not seem to correspond with such a helper.
 */
export function getTsHelperFnFromDeclaration(decl) {
    if (!ts.isFunctionDeclaration(decl) && !ts.isVariableDeclaration(decl)) {
        return null;
    }
    if (decl.name === undefined || !ts.isIdentifier(decl.name)) {
        return null;
    }
    return getTsHelperFnFromIdentifier(decl.name);
}
/**
 * Determine whether an identifier corresponds with a TypeScript helper function (based on its
 * name), returning its kind if so or null if the identifier does not seem to correspond with such a
 * helper.
 */
export function getTsHelperFnFromIdentifier(id) {
    switch (stripDollarSuffix(id.text)) {
        case '__assign':
            return KnownDeclaration.TsHelperAssign;
        case '__spread':
            return KnownDeclaration.TsHelperSpread;
        case '__spreadArrays':
            return KnownDeclaration.TsHelperSpreadArrays;
        case '__spreadArray':
            return KnownDeclaration.TsHelperSpreadArray;
        case '__read':
            return KnownDeclaration.TsHelperRead;
        default:
            return null;
    }
}
/**
 * An identifier may become repeated when bundling multiple source files into a single bundle, so
 * bundlers have a strategy of suffixing non-unique identifiers with a suffix like $2. This function
 * strips off such suffixes, so that ngcc deals with the canonical name of an identifier.
 * @param value The value to strip any suffix of, if applicable.
 * @returns The canonical representation of the value, without any suffix.
 */
export function stripDollarSuffix(value) {
    return value.replace(/\$\d+$/, '');
}
export function stripExtension(fileName) {
    return fileName.replace(/\..+$/, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbmdjYy9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFakMsT0FBTyxFQUFDLFlBQVksRUFBa0IsUUFBUSxFQUFxQixNQUFNLDZCQUE2QixDQUFDO0FBQ3ZHLE9BQU8sRUFBa0IsZ0JBQWdCLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQXdCN0UsTUFBTSxVQUFVLGlCQUFpQixDQUFDLE9BQXVCO0lBQ3ZELE9BQU8sVUFBUyxNQUFpQjtRQUMvQixPQUFPLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3pGLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsU0FBUyxDQUFJLEtBQXVCO0lBQ2xELE9BQU8sQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUM7QUFDbkQsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBb0M7SUFDOUQsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzVGLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxPQUFPLENBQUksSUFBYSxFQUFFLElBQTRDO0lBQ3BGLE1BQU0sS0FBSyxHQUFRLEVBQUUsQ0FBQztJQUN0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Q0FBQyxFQUFpQjtJQUMzRCxRQUFRLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNsQyxLQUFLLFVBQVU7WUFDYixPQUFPLGdCQUFnQixDQUFDLGNBQWMsQ0FBQztRQUN6QyxLQUFLLFVBQVU7WUFDYixPQUFPLGdCQUFnQixDQUFDLGNBQWMsQ0FBQztRQUN6QyxLQUFLLGdCQUFnQjtZQUNuQixPQUFPLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDO1FBQy9DLEtBQUssZUFBZTtZQUNsQixPQUFPLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDO1FBQzlDLEtBQUssUUFBUTtZQUNYLE9BQU8sZ0JBQWdCLENBQUMsWUFBWSxDQUFDO1FBQ3ZDO1lBQ0UsT0FBTyxJQUFJLENBQUM7S0FDZjtBQUNILENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsS0FBYTtJQUM3QyxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3JDLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFDLFFBQWdCO0lBQzdDLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDdkMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7YWJzb2x1dGVGcm9tLCBBYnNvbHV0ZUZzUGF0aCwgaXNSb290ZWQsIFJlYWRvbmx5RmlsZVN5c3RlbX0gZnJvbSAnLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7RGVjbGFyYXRpb25Ob2RlLCBLbm93bkRlY2xhcmF0aW9ufSBmcm9tICcuLi8uLi9zcmMvbmd0c2MvcmVmbGVjdGlvbic7XG5cbi8qKlxuICogQSBsaXN0IChgQXJyYXlgKSBvZiBwYXJ0aWFsbHkgb3JkZXJlZCBgVGAgaXRlbXMuXG4gKlxuICogVGhlIGl0ZW1zIGluIHRoZSBsaXN0IGFyZSBwYXJ0aWFsbHkgb3JkZXJlZCBpbiB0aGUgc2Vuc2UgdGhhdCBhbnkgZWxlbWVudCBoYXMgZWl0aGVyIHRoZSBzYW1lIG9yXG4gKiBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIGFueSBlbGVtZW50IHdoaWNoIGFwcGVhcnMgbGF0ZXIgaW4gdGhlIGxpc3QuIFdoYXQgXCJoaWdoZXIgcHJlY2VkZW5jZVwiXG4gKiBtZWFucyBhbmQgaG93IGl0IGlzIGRldGVybWluZWQgaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50LlxuICpcbiAqIFNlZSBbUGFydGlhbGx5T3JkZXJlZFNldF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbGx5X29yZGVyZWRfc2V0KSBmb3IgbW9yZSBkZXRhaWxzLlxuICogKFJlZnJhaW5pbmcgZnJvbSB1c2luZyB0aGUgdGVybSBcInNldFwiIGhlcmUsIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIEphdmFTY3JpcHQnc1xuICogW1NldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0KS4pXG4gKlxuICogTk9URTogQSBwbGFpbiBgQXJyYXk8VD5gIGlzIG5vdCBhc3NpZ25hYmxlIHRvIGEgYFBhcnRpYWxseU9yZGVyZWRMaXN0PFQ+YCwgYnV0IGFcbiAqICAgICAgIGBQYXJ0aWFsbHlPcmRlcmVkTGlzdDxUPmAgaXMgYXNzaWduYWJsZSB0byBhbiBgQXJyYXk8VD5gLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpYWxseU9yZGVyZWRMaXN0PFQ+IGV4dGVuZHMgQXJyYXk8VD4ge1xuICBfcGFydGlhbGx5T3JkZXJlZDogdHJ1ZTtcblxuICBtYXA8VT4oY2FsbGJhY2tmbjogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBhcnJheTogUGFydGlhbGx5T3JkZXJlZExpc3Q8VD4pID0+IFUsIHRoaXNBcmc/OiBhbnkpOlxuICAgICAgUGFydGlhbGx5T3JkZXJlZExpc3Q8VT47XG4gIHNsaWNlKC4uLmFyZ3M6IFBhcmFtZXRlcnM8QXJyYXk8VD5bJ3NsaWNlJ10+KTogUGFydGlhbGx5T3JkZXJlZExpc3Q8VD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmlnaW5hbFN5bWJvbChjaGVja2VyOiB0cy5UeXBlQ2hlY2tlcik6IChzeW1ib2w6IHRzLlN5bWJvbCkgPT4gdHMuU3ltYm9sIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN5bWJvbDogdHMuU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRzLlN5bWJvbEZsYWdzLkFsaWFzICYgc3ltYm9sLmZsYWdzID8gY2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bWJvbCkgOiBzeW1ib2w7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQ8VD4odmFsdWU6IFR8dW5kZWZpbmVkfG51bGwpOiB2YWx1ZSBpcyBUIHtcbiAgcmV0dXJuICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSAmJiAodmFsdWUgIT09IG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZVRleHQobmFtZTogdHMuUHJvcGVydHlOYW1lfHRzLkJpbmRpbmdOYW1lKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRzLmlzSWRlbnRpZmllcihuYW1lKSB8fCB0cy5pc0xpdGVyYWxFeHByZXNzaW9uKG5hbWUpID8gbmFtZS50ZXh0IDogbmFtZS5nZXRUZXh0KCk7XG59XG5cbi8qKlxuICogUGFyc2UgZG93biB0aGUgQVNUIGFuZCBjYXB0dXJlIGFsbCB0aGUgbm9kZXMgdGhhdCBzYXRpc2Z5IHRoZSB0ZXN0LlxuICogQHBhcmFtIG5vZGUgVGhlIHN0YXJ0IG5vZGUuXG4gKiBAcGFyYW0gdGVzdCBUaGUgZnVuY3Rpb24gdGhhdCB0ZXN0cyB3aGV0aGVyIGEgbm9kZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4gKiBAcmV0dXJucyBhIGNvbGxlY3Rpb24gb2Ygbm9kZXMgdGhhdCBzYXRpc2Z5IHRoZSB0ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEFsbDxUPihub2RlOiB0cy5Ob2RlLCB0ZXN0OiAobm9kZTogdHMuTm9kZSkgPT4gbm9kZSBpcyB0cy5Ob2RlICYgVCk6IFRbXSB7XG4gIGNvbnN0IG5vZGVzOiBUW10gPSBbXTtcbiAgZmluZEFsbFZpc2l0b3Iobm9kZSk7XG4gIHJldHVybiBub2RlcztcblxuICBmdW5jdGlvbiBmaW5kQWxsVmlzaXRvcihuOiB0cy5Ob2RlKSB7XG4gICAgaWYgKHRlc3QobikpIHtcbiAgICAgIG5vZGVzLnB1c2gobik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4uZm9yRWFjaENoaWxkKGNoaWxkID0+IGZpbmRBbGxWaXNpdG9yKGNoaWxkKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRG9lcyB0aGUgZ2l2ZW4gZGVjbGFyYXRpb24gaGF2ZSBhIG5hbWUgd2hpY2ggaXMgYW4gaWRlbnRpZmllcj9cbiAqIEBwYXJhbSBkZWNsYXJhdGlvbiBUaGUgZGVjbGFyYXRpb24gdG8gdGVzdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGRlY2xhcmF0aW9uIGhhcyBhbiBpZGVudGlmaWVyIGZvciBhIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNOYW1lSWRlbnRpZmllcihkZWNsYXJhdGlvbjogdHMuTm9kZSk6IGRlY2xhcmF0aW9uIGlzIERlY2xhcmF0aW9uTm9kZSZcbiAgICB7bmFtZTogdHMuSWRlbnRpZmllcn0ge1xuICBjb25zdCBuYW1lZERlY2xhcmF0aW9uOiB0cy5Ob2RlJntuYW1lPzogdHMuTm9kZX0gPSBkZWNsYXJhdGlvbjtcbiAgcmV0dXJuIG5hbWVkRGVjbGFyYXRpb24ubmFtZSAhPT0gdW5kZWZpbmVkICYmIHRzLmlzSWRlbnRpZmllcihuYW1lZERlY2xhcmF0aW9uLm5hbWUpO1xufVxuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHBhdGggaXMgXCJyZWxhdGl2ZVwiLlxuICpcbiAqIFJlbGF0aXZlIHBhdGhzIHN0YXJ0IHdpdGggYC9gLCBgLi9gIG9yIGAuLi9gIChvciB0aGUgV2luZG93cyBlcXVpdmFsZW50cyk7IG9yIGFyZSBzaW1wbHkgYC5gIG9yXG4gKiBgLi5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSZWxhdGl2ZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1Jvb3RlZChwYXRoKSB8fCAvXlxcLlxcLj8oXFwvfFxcXFx8JCkvLnRlc3QocGF0aCk7XG59XG5cbi8qKlxuICogQSBgTWFwYC1saWtlIG9iamVjdCB0aGF0IGNhbiBjb21wdXRlIGFuZCBtZW1vaXplIGEgbWlzc2luZyB2YWx1ZSBmb3IgYW55IGtleS5cbiAqXG4gKiBUaGUgY29tcHV0ZWQgdmFsdWVzIGFyZSBtZW1vaXplZCwgc28gdGhlIGZhY3RvcnkgZnVuY3Rpb24gaXMgbm90IGNhbGxlZCBtb3JlIHRoYW4gb25jZSBwZXIga2V5LlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHN0b3JpbmcgdmFsdWVzIHRoYXQgYXJlIGV4cGVuc2l2ZSB0byBjb21wdXRlIGFuZCBtYXkgYmUgdXNlZCBtdWx0aXBsZSB0aW1lcy5cbiAqL1xuLy8gTk9URTpcbi8vIElkZWFsbHksIHRoaXMgY2xhc3Mgc2hvdWxkIGV4dGVuZCBgTWFwYCwgYnV0IHRoYXQgY2F1c2VzIGVycm9ycyBpbiBFUzUgdHJhbnNwaWxlZCBjb2RlOlxuLy8gYFR5cGVFcnJvcjogQ29uc3RydWN0b3IgTWFwIHJlcXVpcmVzICduZXcnYFxuZXhwb3J0IGNsYXNzIEZhY3RvcnlNYXA8SywgVj4ge1xuICBwcml2YXRlIGludGVybmFsTWFwOiBNYXA8SywgVj47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmYWN0b3J5OiAoa2V5OiBLKSA9PiBWLCBlbnRyaWVzPzogcmVhZG9ubHkocmVhZG9ubHlbSywgVl0pW118bnVsbCkge1xuICAgIHRoaXMuaW50ZXJuYWxNYXAgPSBuZXcgTWFwKGVudHJpZXMpO1xuICB9XG5cbiAgZ2V0KGtleTogSyk6IFYge1xuICAgIGlmICghdGhpcy5pbnRlcm5hbE1hcC5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5pbnRlcm5hbE1hcC5zZXQoa2V5LCB0aGlzLmZhY3Rvcnkoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNYXAuZ2V0KGtleSkhO1xuICB9XG5cbiAgc2V0KGtleTogSywgdmFsdWU6IFYpOiB2b2lkIHtcbiAgICB0aGlzLmludGVybmFsTWFwLnNldChrZXksIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhIGBwYXRoYCB0byBhIGZpbGUgYnkgYXBwZW5kaW5nIHRoZSBwcm92aWRlZCBgcG9zdEZpeGVzYFxuICogdG8gdGhlIGBwYXRoYCBhbmQgY2hlY2tpbmcgaWYgdGhlIGZpbGUgZXhpc3RzIG9uIGRpc2suXG4gKiBAcmV0dXJucyBBbiBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaXJzdCBtYXRjaGluZyBleGlzdGluZyBmaWxlLCBvciBgbnVsbGAgaWYgbm9uZSBleGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVGaWxlV2l0aFBvc3RmaXhlcyhcbiAgICBmczogUmVhZG9ubHlGaWxlU3lzdGVtLCBwYXRoOiBBYnNvbHV0ZUZzUGF0aCwgcG9zdEZpeGVzOiBzdHJpbmdbXSk6IEFic29sdXRlRnNQYXRofG51bGwge1xuICBmb3IgKGNvbnN0IHBvc3RGaXggb2YgcG9zdEZpeGVzKSB7XG4gICAgY29uc3QgdGVzdFBhdGggPSBhYnNvbHV0ZUZyb20ocGF0aCArIHBvc3RGaXgpO1xuICAgIGlmIChmcy5leGlzdHModGVzdFBhdGgpICYmIGZzLnN0YXQodGVzdFBhdGgpLmlzRmlsZSgpKSB7XG4gICAgICByZXR1cm4gdGVzdFBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gY29ycmVzcG9uZHMgd2l0aCBhIFR5cGVTY3JpcHQgaGVscGVyIGZ1bmN0aW9uLCByZXR1cm5pbmdcbiAqIGl0cyBraW5kIGlmIHNvIG9yIG51bGwgaWYgdGhlIGRlY2xhcmF0aW9uIGRvZXMgbm90IHNlZW0gdG8gY29ycmVzcG9uZCB3aXRoIHN1Y2ggYSBoZWxwZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUc0hlbHBlckZuRnJvbURlY2xhcmF0aW9uKGRlY2w6IERlY2xhcmF0aW9uTm9kZSk6IEtub3duRGVjbGFyYXRpb258bnVsbCB7XG4gIGlmICghdHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2wpICYmICF0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChkZWNsLm5hbWUgPT09IHVuZGVmaW5lZCB8fCAhdHMuaXNJZGVudGlmaWVyKGRlY2wubmFtZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRUc0hlbHBlckZuRnJvbUlkZW50aWZpZXIoZGVjbC5uYW1lKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhbiBpZGVudGlmaWVyIGNvcnJlc3BvbmRzIHdpdGggYSBUeXBlU2NyaXB0IGhlbHBlciBmdW5jdGlvbiAoYmFzZWQgb24gaXRzXG4gKiBuYW1lKSwgcmV0dXJuaW5nIGl0cyBraW5kIGlmIHNvIG9yIG51bGwgaWYgdGhlIGlkZW50aWZpZXIgZG9lcyBub3Qgc2VlbSB0byBjb3JyZXNwb25kIHdpdGggc3VjaCBhXG4gKiBoZWxwZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUc0hlbHBlckZuRnJvbUlkZW50aWZpZXIoaWQ6IHRzLklkZW50aWZpZXIpOiBLbm93bkRlY2xhcmF0aW9ufG51bGwge1xuICBzd2l0Y2ggKHN0cmlwRG9sbGFyU3VmZml4KGlkLnRleHQpKSB7XG4gICAgY2FzZSAnX19hc3NpZ24nOlxuICAgICAgcmV0dXJuIEtub3duRGVjbGFyYXRpb24uVHNIZWxwZXJBc3NpZ247XG4gICAgY2FzZSAnX19zcHJlYWQnOlxuICAgICAgcmV0dXJuIEtub3duRGVjbGFyYXRpb24uVHNIZWxwZXJTcHJlYWQ7XG4gICAgY2FzZSAnX19zcHJlYWRBcnJheXMnOlxuICAgICAgcmV0dXJuIEtub3duRGVjbGFyYXRpb24uVHNIZWxwZXJTcHJlYWRBcnJheXM7XG4gICAgY2FzZSAnX19zcHJlYWRBcnJheSc6XG4gICAgICByZXR1cm4gS25vd25EZWNsYXJhdGlvbi5Uc0hlbHBlclNwcmVhZEFycmF5O1xuICAgIGNhc2UgJ19fcmVhZCc6XG4gICAgICByZXR1cm4gS25vd25EZWNsYXJhdGlvbi5Uc0hlbHBlclJlYWQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQW4gaWRlbnRpZmllciBtYXkgYmVjb21lIHJlcGVhdGVkIHdoZW4gYnVuZGxpbmcgbXVsdGlwbGUgc291cmNlIGZpbGVzIGludG8gYSBzaW5nbGUgYnVuZGxlLCBzb1xuICogYnVuZGxlcnMgaGF2ZSBhIHN0cmF0ZWd5IG9mIHN1ZmZpeGluZyBub24tdW5pcXVlIGlkZW50aWZpZXJzIHdpdGggYSBzdWZmaXggbGlrZSAkMi4gVGhpcyBmdW5jdGlvblxuICogc3RyaXBzIG9mZiBzdWNoIHN1ZmZpeGVzLCBzbyB0aGF0IG5nY2MgZGVhbHMgd2l0aCB0aGUgY2Fub25pY2FsIG5hbWUgb2YgYW4gaWRlbnRpZmllci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RyaXAgYW55IHN1ZmZpeCBvZiwgaWYgYXBwbGljYWJsZS5cbiAqIEByZXR1cm5zIFRoZSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLCB3aXRob3V0IGFueSBzdWZmaXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcERvbGxhclN1ZmZpeCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcJFxcZCskLywgJycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBFeHRlbnNpb24oZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBmaWxlTmFtZS5yZXBsYWNlKC9cXC4uKyQvLCAnJyk7XG59XG4iXX0=