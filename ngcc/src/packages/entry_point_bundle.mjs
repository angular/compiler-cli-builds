import { DtsProcessing } from '../execution/tasks/api';
import { makeBundleProgram } from './bundle_program';
import { NgccDtsCompilerHost, NgccSourcesCompilerHost } from './ngcc_compiler_host';
import { EntryPointFileCache } from './source_file_cache';
/**
 * Get an object that describes a formatted bundle for an entry-point.
 * @param fs The current file-system being used.
 * @param entryPoint The entry-point that contains the bundle.
 * @param sharedFileCache The cache to use for source files that are shared across all entry-points.
 * @param moduleResolutionCache The module resolution cache to use.
 * @param formatPath The path to the source files for this bundle.
 * @param isCore This entry point is the Angular core package.
 * @param format The underlying format of the bundle.
 * @param dtsProcessing Whether to transform the typings along with this bundle.
 * @param pathMappings An optional set of mappings to use when compiling files.
 * @param mirrorDtsFromSrc If true then the `dts` program will contain additional files that
 * were guessed by mapping the `src` files to `dts` files.
 * @param enableI18nLegacyMessageIdFormat Whether to render legacy message ids for i18n messages in
 * component templates.
 */
export function makeEntryPointBundle(fs, entryPoint, sharedFileCache, moduleResolutionCache, formatPath, isCore, format, dtsProcessing, pathMappings, mirrorDtsFromSrc = false, enableI18nLegacyMessageIdFormat = true) {
    // Create the TS program and necessary helpers.
    const rootDir = entryPoint.packagePath;
    const options = Object.assign({ allowJs: true, maxNodeModuleJsDepth: Infinity, rootDir }, pathMappings);
    const entryPointCache = new EntryPointFileCache(fs, sharedFileCache);
    const dtsHost = new NgccDtsCompilerHost(fs, options, entryPointCache, moduleResolutionCache);
    const srcHost = new NgccSourcesCompilerHost(fs, options, entryPointCache, moduleResolutionCache, entryPoint.packagePath);
    // Create the bundle programs, as necessary.
    const absFormatPath = fs.resolve(entryPoint.path, formatPath);
    const typingsPath = fs.resolve(entryPoint.path, entryPoint.typings);
    const src = makeBundleProgram(fs, isCore, entryPoint.packagePath, absFormatPath, 'r3_symbols.js', options, srcHost);
    const additionalDtsFiles = dtsProcessing !== DtsProcessing.No && mirrorDtsFromSrc ?
        computePotentialDtsFilesFromJsFiles(fs, src.program, absFormatPath, typingsPath) :
        [];
    const dts = dtsProcessing !== DtsProcessing.No ?
        makeBundleProgram(fs, isCore, entryPoint.packagePath, typingsPath, 'r3_symbols.d.ts', Object.assign(Object.assign({}, options), { allowJs: false }), dtsHost, additionalDtsFiles) :
        null;
    const isFlatCore = isCore && src.r3SymbolsFile === null;
    return {
        entryPoint,
        format,
        rootDirs: [rootDir],
        isCore,
        isFlatCore,
        src,
        dts,
        dtsProcessing,
        enableI18nLegacyMessageIdFormat
    };
}
function computePotentialDtsFilesFromJsFiles(fs, srcProgram, formatPath, typingsPath) {
    const formatRoot = fs.dirname(formatPath);
    const typingsRoot = fs.dirname(typingsPath);
    const additionalFiles = [];
    for (const sf of srcProgram.getSourceFiles()) {
        if (!sf.fileName.endsWith('.js')) {
            continue;
        }
        // Given a source file at e.g. `esm2015/src/some/nested/index.js`, try to resolve the
        // declaration file under the typings root in `src/some/nested/index.d.ts`.
        const mirroredDtsPath = fs.resolve(typingsRoot, fs.relative(formatRoot, sf.fileName.replace(/\.js$/, '.d.ts')));
        if (fs.exists(mirroredDtsPath)) {
            additionalFiles.push(mirroredDtsPath);
        }
    }
    return additionalFiles;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50cnlfcG9pbnRfYnVuZGxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL25nY2Mvc3JjL3BhY2thZ2VzL2VudHJ5X3BvaW50X2J1bmRsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFTQSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFFckQsT0FBTyxFQUFnQixpQkFBaUIsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBRWxFLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ2xGLE9BQU8sRUFBQyxtQkFBbUIsRUFBa0IsTUFBTSxxQkFBcUIsQ0FBQztBQWtCekU7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUNoQyxFQUFjLEVBQUUsVUFBc0IsRUFBRSxlQUFnQyxFQUN4RSxxQkFBK0MsRUFBRSxVQUFrQixFQUFFLE1BQWUsRUFDcEYsTUFBd0IsRUFBRSxhQUE0QixFQUFFLFlBQTJCLEVBQ25GLG1CQUE0QixLQUFLLEVBQ2pDLGtDQUEyQyxJQUFJO0lBQ2pELCtDQUErQztJQUMvQyxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDO0lBQ3ZDLE1BQU0sT0FBTyxtQkFDVyxPQUFPLEVBQUUsSUFBSSxFQUFFLG9CQUFvQixFQUFFLFFBQVEsRUFBRSxPQUFPLElBQUssWUFBWSxDQUFDLENBQUM7SUFDakcsTUFBTSxlQUFlLEdBQUcsSUFBSSxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDckUsTUFBTSxPQUFPLEdBQUcsSUFBSSxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQzdGLE1BQU0sT0FBTyxHQUFHLElBQUksdUJBQXVCLENBQ3ZDLEVBQUUsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLHFCQUFxQixFQUFFLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUVqRiw0Q0FBNEM7SUFDNUMsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzlELE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEUsTUFBTSxHQUFHLEdBQUcsaUJBQWlCLENBQ3pCLEVBQUUsRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLFdBQVcsRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMxRixNQUFNLGtCQUFrQixHQUFHLGFBQWEsS0FBSyxhQUFhLENBQUMsRUFBRSxJQUFJLGdCQUFnQixDQUFDLENBQUM7UUFDL0UsbUNBQW1DLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDbEYsRUFBRSxDQUFDO0lBQ1AsTUFBTSxHQUFHLEdBQUcsYUFBYSxLQUFLLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM1QyxpQkFBaUIsQ0FDYixFQUFFLEVBQUUsTUFBTSxFQUFFLFVBQVUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixrQ0FDOUQsT0FBTyxLQUFFLE9BQU8sRUFBRSxLQUFLLEtBQUcsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUM7SUFDVCxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLGFBQWEsS0FBSyxJQUFJLENBQUM7SUFFeEQsT0FBTztRQUNMLFVBQVU7UUFDVixNQUFNO1FBQ04sUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDO1FBQ25CLE1BQU07UUFDTixVQUFVO1FBQ1YsR0FBRztRQUNILEdBQUc7UUFDSCxhQUFhO1FBQ2IsK0JBQStCO0tBQ2hDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxtQ0FBbUMsQ0FDeEMsRUFBc0IsRUFBRSxVQUFzQixFQUFFLFVBQTBCLEVBQzFFLFdBQTJCO0lBQzdCLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDMUMsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM1QyxNQUFNLGVBQWUsR0FBcUIsRUFBRSxDQUFDO0lBQzdDLEtBQUssTUFBTSxFQUFFLElBQUksVUFBVSxDQUFDLGNBQWMsRUFBRSxFQUFFO1FBQzVDLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNoQyxTQUFTO1NBQ1Y7UUFFRCxxRkFBcUY7UUFDckYsMkVBQTJFO1FBQzNFLE1BQU0sZUFBZSxHQUNqQixFQUFFLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVGLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUM5QixlQUFlLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1NBQ3ZDO0tBQ0Y7SUFDRCxPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7QWJzb2x1dGVGc1BhdGgsIEZpbGVTeXN0ZW0sIFJlYWRvbmx5RmlsZVN5c3RlbX0gZnJvbSAnLi4vLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7RHRzUHJvY2Vzc2luZ30gZnJvbSAnLi4vZXhlY3V0aW9uL3Rhc2tzL2FwaSc7XG5pbXBvcnQge1BhdGhNYXBwaW5nc30gZnJvbSAnLi4vcGF0aF9tYXBwaW5ncyc7XG5pbXBvcnQge0J1bmRsZVByb2dyYW0sIG1ha2VCdW5kbGVQcm9ncmFtfSBmcm9tICcuL2J1bmRsZV9wcm9ncmFtJztcbmltcG9ydCB7RW50cnlQb2ludCwgRW50cnlQb2ludEZvcm1hdH0gZnJvbSAnLi9lbnRyeV9wb2ludCc7XG5pbXBvcnQge05nY2NEdHNDb21waWxlckhvc3QsIE5nY2NTb3VyY2VzQ29tcGlsZXJIb3N0fSBmcm9tICcuL25nY2NfY29tcGlsZXJfaG9zdCc7XG5pbXBvcnQge0VudHJ5UG9pbnRGaWxlQ2FjaGUsIFNoYXJlZEZpbGVDYWNoZX0gZnJvbSAnLi9zb3VyY2VfZmlsZV9jYWNoZSc7XG5cbi8qKlxuICogQSBidW5kbGUgb2YgZmlsZXMgYW5kIHBhdGhzIChhbmQgVFMgcHJvZ3JhbXMpIHRoYXQgY29ycmVzcG9uZCB0byBhIHBhcnRpY3VsYXJcbiAqIGZvcm1hdCBvZiBhIHBhY2thZ2UgZW50cnktcG9pbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW50cnlQb2ludEJ1bmRsZSB7XG4gIGVudHJ5UG9pbnQ6IEVudHJ5UG9pbnQ7XG4gIGZvcm1hdDogRW50cnlQb2ludEZvcm1hdDtcbiAgaXNDb3JlOiBib29sZWFuO1xuICBpc0ZsYXRDb3JlOiBib29sZWFuO1xuICByb290RGlyczogQWJzb2x1dGVGc1BhdGhbXTtcbiAgc3JjOiBCdW5kbGVQcm9ncmFtO1xuICBkdHM6IEJ1bmRsZVByb2dyYW18bnVsbDtcbiAgZHRzUHJvY2Vzc2luZzogRHRzUHJvY2Vzc2luZztcbiAgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdDogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgZm9ybWF0dGVkIGJ1bmRsZSBmb3IgYW4gZW50cnktcG9pbnQuXG4gKiBAcGFyYW0gZnMgVGhlIGN1cnJlbnQgZmlsZS1zeXN0ZW0gYmVpbmcgdXNlZC5cbiAqIEBwYXJhbSBlbnRyeVBvaW50IFRoZSBlbnRyeS1wb2ludCB0aGF0IGNvbnRhaW5zIHRoZSBidW5kbGUuXG4gKiBAcGFyYW0gc2hhcmVkRmlsZUNhY2hlIFRoZSBjYWNoZSB0byB1c2UgZm9yIHNvdXJjZSBmaWxlcyB0aGF0IGFyZSBzaGFyZWQgYWNyb3NzIGFsbCBlbnRyeS1wb2ludHMuXG4gKiBAcGFyYW0gbW9kdWxlUmVzb2x1dGlvbkNhY2hlIFRoZSBtb2R1bGUgcmVzb2x1dGlvbiBjYWNoZSB0byB1c2UuXG4gKiBAcGFyYW0gZm9ybWF0UGF0aCBUaGUgcGF0aCB0byB0aGUgc291cmNlIGZpbGVzIGZvciB0aGlzIGJ1bmRsZS5cbiAqIEBwYXJhbSBpc0NvcmUgVGhpcyBlbnRyeSBwb2ludCBpcyB0aGUgQW5ndWxhciBjb3JlIHBhY2thZ2UuXG4gKiBAcGFyYW0gZm9ybWF0IFRoZSB1bmRlcmx5aW5nIGZvcm1hdCBvZiB0aGUgYnVuZGxlLlxuICogQHBhcmFtIGR0c1Byb2Nlc3NpbmcgV2hldGhlciB0byB0cmFuc2Zvcm0gdGhlIHR5cGluZ3MgYWxvbmcgd2l0aCB0aGlzIGJ1bmRsZS5cbiAqIEBwYXJhbSBwYXRoTWFwcGluZ3MgQW4gb3B0aW9uYWwgc2V0IG9mIG1hcHBpbmdzIHRvIHVzZSB3aGVuIGNvbXBpbGluZyBmaWxlcy5cbiAqIEBwYXJhbSBtaXJyb3JEdHNGcm9tU3JjIElmIHRydWUgdGhlbiB0aGUgYGR0c2AgcHJvZ3JhbSB3aWxsIGNvbnRhaW4gYWRkaXRpb25hbCBmaWxlcyB0aGF0XG4gKiB3ZXJlIGd1ZXNzZWQgYnkgbWFwcGluZyB0aGUgYHNyY2AgZmlsZXMgdG8gYGR0c2AgZmlsZXMuXG4gKiBAcGFyYW0gZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCBXaGV0aGVyIHRvIHJlbmRlciBsZWdhY3kgbWVzc2FnZSBpZHMgZm9yIGkxOG4gbWVzc2FnZXMgaW5cbiAqIGNvbXBvbmVudCB0ZW1wbGF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW50cnlQb2ludEJ1bmRsZShcbiAgICBmczogRmlsZVN5c3RlbSwgZW50cnlQb2ludDogRW50cnlQb2ludCwgc2hhcmVkRmlsZUNhY2hlOiBTaGFyZWRGaWxlQ2FjaGUsXG4gICAgbW9kdWxlUmVzb2x1dGlvbkNhY2hlOiB0cy5Nb2R1bGVSZXNvbHV0aW9uQ2FjaGUsIGZvcm1hdFBhdGg6IHN0cmluZywgaXNDb3JlOiBib29sZWFuLFxuICAgIGZvcm1hdDogRW50cnlQb2ludEZvcm1hdCwgZHRzUHJvY2Vzc2luZzogRHRzUHJvY2Vzc2luZywgcGF0aE1hcHBpbmdzPzogUGF0aE1hcHBpbmdzLFxuICAgIG1pcnJvckR0c0Zyb21TcmM6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBlbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0OiBib29sZWFuID0gdHJ1ZSk6IEVudHJ5UG9pbnRCdW5kbGUge1xuICAvLyBDcmVhdGUgdGhlIFRTIHByb2dyYW0gYW5kIG5lY2Vzc2FyeSBoZWxwZXJzLlxuICBjb25zdCByb290RGlyID0gZW50cnlQb2ludC5wYWNrYWdlUGF0aDtcbiAgY29uc3Qgb3B0aW9uczogdHNcbiAgICAgIC5Db21waWxlck9wdGlvbnMgPSB7YWxsb3dKczogdHJ1ZSwgbWF4Tm9kZU1vZHVsZUpzRGVwdGg6IEluZmluaXR5LCByb290RGlyLCAuLi5wYXRoTWFwcGluZ3N9O1xuICBjb25zdCBlbnRyeVBvaW50Q2FjaGUgPSBuZXcgRW50cnlQb2ludEZpbGVDYWNoZShmcywgc2hhcmVkRmlsZUNhY2hlKTtcbiAgY29uc3QgZHRzSG9zdCA9IG5ldyBOZ2NjRHRzQ29tcGlsZXJIb3N0KGZzLCBvcHRpb25zLCBlbnRyeVBvaW50Q2FjaGUsIG1vZHVsZVJlc29sdXRpb25DYWNoZSk7XG4gIGNvbnN0IHNyY0hvc3QgPSBuZXcgTmdjY1NvdXJjZXNDb21waWxlckhvc3QoXG4gICAgICBmcywgb3B0aW9ucywgZW50cnlQb2ludENhY2hlLCBtb2R1bGVSZXNvbHV0aW9uQ2FjaGUsIGVudHJ5UG9pbnQucGFja2FnZVBhdGgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgYnVuZGxlIHByb2dyYW1zLCBhcyBuZWNlc3NhcnkuXG4gIGNvbnN0IGFic0Zvcm1hdFBhdGggPSBmcy5yZXNvbHZlKGVudHJ5UG9pbnQucGF0aCwgZm9ybWF0UGF0aCk7XG4gIGNvbnN0IHR5cGluZ3NQYXRoID0gZnMucmVzb2x2ZShlbnRyeVBvaW50LnBhdGgsIGVudHJ5UG9pbnQudHlwaW5ncyk7XG4gIGNvbnN0IHNyYyA9IG1ha2VCdW5kbGVQcm9ncmFtKFxuICAgICAgZnMsIGlzQ29yZSwgZW50cnlQb2ludC5wYWNrYWdlUGF0aCwgYWJzRm9ybWF0UGF0aCwgJ3IzX3N5bWJvbHMuanMnLCBvcHRpb25zLCBzcmNIb3N0KTtcbiAgY29uc3QgYWRkaXRpb25hbER0c0ZpbGVzID0gZHRzUHJvY2Vzc2luZyAhPT0gRHRzUHJvY2Vzc2luZy5ObyAmJiBtaXJyb3JEdHNGcm9tU3JjID9cbiAgICAgIGNvbXB1dGVQb3RlbnRpYWxEdHNGaWxlc0Zyb21Kc0ZpbGVzKGZzLCBzcmMucHJvZ3JhbSwgYWJzRm9ybWF0UGF0aCwgdHlwaW5nc1BhdGgpIDpcbiAgICAgIFtdO1xuICBjb25zdCBkdHMgPSBkdHNQcm9jZXNzaW5nICE9PSBEdHNQcm9jZXNzaW5nLk5vID9cbiAgICAgIG1ha2VCdW5kbGVQcm9ncmFtKFxuICAgICAgICAgIGZzLCBpc0NvcmUsIGVudHJ5UG9pbnQucGFja2FnZVBhdGgsIHR5cGluZ3NQYXRoLCAncjNfc3ltYm9scy5kLnRzJyxcbiAgICAgICAgICB7Li4ub3B0aW9ucywgYWxsb3dKczogZmFsc2V9LCBkdHNIb3N0LCBhZGRpdGlvbmFsRHRzRmlsZXMpIDpcbiAgICAgIG51bGw7XG4gIGNvbnN0IGlzRmxhdENvcmUgPSBpc0NvcmUgJiYgc3JjLnIzU3ltYm9sc0ZpbGUgPT09IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyeVBvaW50LFxuICAgIGZvcm1hdCxcbiAgICByb290RGlyczogW3Jvb3REaXJdLFxuICAgIGlzQ29yZSxcbiAgICBpc0ZsYXRDb3JlLFxuICAgIHNyYyxcbiAgICBkdHMsXG4gICAgZHRzUHJvY2Vzc2luZyxcbiAgICBlbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVQb3RlbnRpYWxEdHNGaWxlc0Zyb21Kc0ZpbGVzKFxuICAgIGZzOiBSZWFkb25seUZpbGVTeXN0ZW0sIHNyY1Byb2dyYW06IHRzLlByb2dyYW0sIGZvcm1hdFBhdGg6IEFic29sdXRlRnNQYXRoLFxuICAgIHR5cGluZ3NQYXRoOiBBYnNvbHV0ZUZzUGF0aCkge1xuICBjb25zdCBmb3JtYXRSb290ID0gZnMuZGlybmFtZShmb3JtYXRQYXRoKTtcbiAgY29uc3QgdHlwaW5nc1Jvb3QgPSBmcy5kaXJuYW1lKHR5cGluZ3NQYXRoKTtcbiAgY29uc3QgYWRkaXRpb25hbEZpbGVzOiBBYnNvbHV0ZUZzUGF0aFtdID0gW107XG4gIGZvciAoY29uc3Qgc2Ygb2Ygc3JjUHJvZ3JhbS5nZXRTb3VyY2VGaWxlcygpKSB7XG4gICAgaWYgKCFzZi5maWxlTmFtZS5lbmRzV2l0aCgnLmpzJykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdpdmVuIGEgc291cmNlIGZpbGUgYXQgZS5nLiBgZXNtMjAxNS9zcmMvc29tZS9uZXN0ZWQvaW5kZXguanNgLCB0cnkgdG8gcmVzb2x2ZSB0aGVcbiAgICAvLyBkZWNsYXJhdGlvbiBmaWxlIHVuZGVyIHRoZSB0eXBpbmdzIHJvb3QgaW4gYHNyYy9zb21lL25lc3RlZC9pbmRleC5kLnRzYC5cbiAgICBjb25zdCBtaXJyb3JlZER0c1BhdGggPVxuICAgICAgICBmcy5yZXNvbHZlKHR5cGluZ3NSb290LCBmcy5yZWxhdGl2ZShmb3JtYXRSb290LCBzZi5maWxlTmFtZS5yZXBsYWNlKC9cXC5qcyQvLCAnLmQudHMnKSkpO1xuICAgIGlmIChmcy5leGlzdHMobWlycm9yZWREdHNQYXRoKSkge1xuICAgICAgYWRkaXRpb25hbEZpbGVzLnB1c2gobWlycm9yZWREdHNQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZGl0aW9uYWxGaWxlcztcbn1cbiJdfQ==