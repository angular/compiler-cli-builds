(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/ngcc/src/packages/entry_point_bundle", ["require", "exports", "tslib", "@angular/compiler-cli/src/ngtsc/path", "@angular/compiler-cli/ngcc/src/packages/bundle_program", "@angular/compiler-cli/ngcc/src/packages/ngcc_compiler_host"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var path_1 = require("@angular/compiler-cli/src/ngtsc/path");
    var bundle_program_1 = require("@angular/compiler-cli/ngcc/src/packages/bundle_program");
    var ngcc_compiler_host_1 = require("@angular/compiler-cli/ngcc/src/packages/ngcc_compiler_host");
    /**
     * Get an object that describes a formatted bundle for an entry-point.
     * @param entryPointPath The path to the entry-point that contains the bundle.
     * @param formatPath The path to the source files for this bundle.
     * @param typingsPath The path to the typings files if we should transform them with this bundle.
     * @param isCore This entry point is the Angular core package.
     * @param format The underlying format of the bundle.
     * @param transformDts Whether to transform the typings along with this bundle.
     */
    function makeEntryPointBundle(fs, entryPointPath, formatPath, typingsPath, isCore, formatProperty, format, transformDts, pathMappings) {
        // Create the TS program and necessary helpers.
        var options = tslib_1.__assign({ allowJs: true, maxNodeModuleJsDepth: Infinity, noLib: true, rootDir: entryPointPath }, pathMappings);
        var host = new ngcc_compiler_host_1.NgccCompilerHost(fs, options);
        var rootDirs = [path_1.AbsoluteFsPath.from(entryPointPath)];
        // Create the bundle programs, as necessary.
        var src = bundle_program_1.makeBundleProgram(fs, isCore, path_1.AbsoluteFsPath.resolve(entryPointPath, formatPath), 'r3_symbols.js', options, host);
        var dts = transformDts ? bundle_program_1.makeBundleProgram(fs, isCore, path_1.AbsoluteFsPath.resolve(entryPointPath, typingsPath), 'r3_symbols.d.ts', options, host) :
            null;
        var isFlatCore = isCore && src.r3SymbolsFile === null;
        return { format: format, formatProperty: formatProperty, rootDirs: rootDirs, isCore: isCore, isFlatCore: isFlatCore, src: src, dts: dts };
    }
    exports.makeEntryPointBundle = makeEntryPointBundle;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50cnlfcG9pbnRfYnVuZGxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL25nY2Mvc3JjL3BhY2thZ2VzL2VudHJ5X3BvaW50X2J1bmRsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFTQSw2REFBdUQ7SUFHdkQseUZBQWtFO0lBRWxFLGlHQUFzRDtJQWdCdEQ7Ozs7Ozs7O09BUUc7SUFDSCxTQUFnQixvQkFBb0IsQ0FDaEMsRUFBYyxFQUFFLGNBQXNCLEVBQUUsVUFBa0IsRUFBRSxXQUFtQixFQUMvRSxNQUFlLEVBQUUsY0FBc0MsRUFBRSxNQUF3QixFQUNqRixZQUFxQixFQUFFLFlBQTJCO1FBQ3BELCtDQUErQztRQUMvQyxJQUFNLE9BQU8sc0JBQ1gsT0FBTyxFQUFFLElBQUksRUFDYixvQkFBb0IsRUFBRSxRQUFRLEVBQzlCLEtBQUssRUFBRSxJQUFJLEVBQ1gsT0FBTyxFQUFFLGNBQWMsSUFBSyxZQUFZLENBQ3pDLENBQUM7UUFDRixJQUFNLElBQUksR0FBRyxJQUFJLHFDQUFnQixDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMvQyxJQUFNLFFBQVEsR0FBRyxDQUFDLHFCQUFjLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFFdkQsNENBQTRDO1FBQzVDLElBQU0sR0FBRyxHQUFHLGtDQUFpQixDQUN6QixFQUFFLEVBQUUsTUFBTSxFQUFFLHFCQUFjLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxVQUFVLENBQUMsRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUN4RixJQUFJLENBQUMsQ0FBQztRQUNWLElBQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsa0NBQWlCLENBQ2IsRUFBRSxFQUFFLE1BQU0sRUFBRSxxQkFBYyxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsV0FBVyxDQUFDLEVBQy9ELGlCQUFpQixFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQztRQUNoQyxJQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksR0FBRyxDQUFDLGFBQWEsS0FBSyxJQUFJLENBQUM7UUFFeEQsT0FBTyxFQUFDLE1BQU0sUUFBQSxFQUFFLGNBQWMsZ0JBQUEsRUFBRSxRQUFRLFVBQUEsRUFBRSxNQUFNLFFBQUEsRUFBRSxVQUFVLFlBQUEsRUFBRSxHQUFHLEtBQUEsRUFBRSxHQUFHLEtBQUEsRUFBQyxDQUFDO0lBQzFFLENBQUM7SUF6QkQsb0RBeUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7QWJzb2x1dGVGc1BhdGh9IGZyb20gJy4uLy4uLy4uL3NyYy9uZ3RzYy9wYXRoJztcbmltcG9ydCB7RmlsZVN5c3RlbX0gZnJvbSAnLi4vZmlsZV9zeXN0ZW0vZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtQYXRoTWFwcGluZ3N9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7QnVuZGxlUHJvZ3JhbSwgbWFrZUJ1bmRsZVByb2dyYW19IGZyb20gJy4vYnVuZGxlX3Byb2dyYW0nO1xuaW1wb3J0IHtFbnRyeVBvaW50Rm9ybWF0LCBFbnRyeVBvaW50SnNvblByb3BlcnR5fSBmcm9tICcuL2VudHJ5X3BvaW50JztcbmltcG9ydCB7TmdjY0NvbXBpbGVySG9zdH0gZnJvbSAnLi9uZ2NjX2NvbXBpbGVyX2hvc3QnO1xuXG4vKipcbiAqIEEgYnVuZGxlIG9mIGZpbGVzIGFuZCBwYXRocyAoYW5kIFRTIHByb2dyYW1zKSB0aGF0IGNvcnJlc3BvbmQgdG8gYSBwYXJ0aWN1bGFyXG4gKiBmb3JtYXQgb2YgYSBwYWNrYWdlIGVudHJ5LXBvaW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudHJ5UG9pbnRCdW5kbGUge1xuICBmb3JtYXRQcm9wZXJ0eTogRW50cnlQb2ludEpzb25Qcm9wZXJ0eTtcbiAgZm9ybWF0OiBFbnRyeVBvaW50Rm9ybWF0O1xuICBpc0NvcmU6IGJvb2xlYW47XG4gIGlzRmxhdENvcmU6IGJvb2xlYW47XG4gIHJvb3REaXJzOiBBYnNvbHV0ZUZzUGF0aFtdO1xuICBzcmM6IEJ1bmRsZVByb2dyYW07XG4gIGR0czogQnVuZGxlUHJvZ3JhbXxudWxsO1xufVxuXG4vKipcbiAqIEdldCBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBmb3JtYXR0ZWQgYnVuZGxlIGZvciBhbiBlbnRyeS1wb2ludC5cbiAqIEBwYXJhbSBlbnRyeVBvaW50UGF0aCBUaGUgcGF0aCB0byB0aGUgZW50cnktcG9pbnQgdGhhdCBjb250YWlucyB0aGUgYnVuZGxlLlxuICogQHBhcmFtIGZvcm1hdFBhdGggVGhlIHBhdGggdG8gdGhlIHNvdXJjZSBmaWxlcyBmb3IgdGhpcyBidW5kbGUuXG4gKiBAcGFyYW0gdHlwaW5nc1BhdGggVGhlIHBhdGggdG8gdGhlIHR5cGluZ3MgZmlsZXMgaWYgd2Ugc2hvdWxkIHRyYW5zZm9ybSB0aGVtIHdpdGggdGhpcyBidW5kbGUuXG4gKiBAcGFyYW0gaXNDb3JlIFRoaXMgZW50cnkgcG9pbnQgaXMgdGhlIEFuZ3VsYXIgY29yZSBwYWNrYWdlLlxuICogQHBhcmFtIGZvcm1hdCBUaGUgdW5kZXJseWluZyBmb3JtYXQgb2YgdGhlIGJ1bmRsZS5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1EdHMgV2hldGhlciB0byB0cmFuc2Zvcm0gdGhlIHR5cGluZ3MgYWxvbmcgd2l0aCB0aGlzIGJ1bmRsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFbnRyeVBvaW50QnVuZGxlKFxuICAgIGZzOiBGaWxlU3lzdGVtLCBlbnRyeVBvaW50UGF0aDogc3RyaW5nLCBmb3JtYXRQYXRoOiBzdHJpbmcsIHR5cGluZ3NQYXRoOiBzdHJpbmcsXG4gICAgaXNDb3JlOiBib29sZWFuLCBmb3JtYXRQcm9wZXJ0eTogRW50cnlQb2ludEpzb25Qcm9wZXJ0eSwgZm9ybWF0OiBFbnRyeVBvaW50Rm9ybWF0LFxuICAgIHRyYW5zZm9ybUR0czogYm9vbGVhbiwgcGF0aE1hcHBpbmdzPzogUGF0aE1hcHBpbmdzKTogRW50cnlQb2ludEJ1bmRsZXxudWxsIHtcbiAgLy8gQ3JlYXRlIHRoZSBUUyBwcm9ncmFtIGFuZCBuZWNlc3NhcnkgaGVscGVycy5cbiAgY29uc3Qgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zID0ge1xuICAgIGFsbG93SnM6IHRydWUsXG4gICAgbWF4Tm9kZU1vZHVsZUpzRGVwdGg6IEluZmluaXR5LFxuICAgIG5vTGliOiB0cnVlLFxuICAgIHJvb3REaXI6IGVudHJ5UG9pbnRQYXRoLCAuLi5wYXRoTWFwcGluZ3NcbiAgfTtcbiAgY29uc3QgaG9zdCA9IG5ldyBOZ2NjQ29tcGlsZXJIb3N0KGZzLCBvcHRpb25zKTtcbiAgY29uc3Qgcm9vdERpcnMgPSBbQWJzb2x1dGVGc1BhdGguZnJvbShlbnRyeVBvaW50UGF0aCldO1xuXG4gIC8vIENyZWF0ZSB0aGUgYnVuZGxlIHByb2dyYW1zLCBhcyBuZWNlc3NhcnkuXG4gIGNvbnN0IHNyYyA9IG1ha2VCdW5kbGVQcm9ncmFtKFxuICAgICAgZnMsIGlzQ29yZSwgQWJzb2x1dGVGc1BhdGgucmVzb2x2ZShlbnRyeVBvaW50UGF0aCwgZm9ybWF0UGF0aCksICdyM19zeW1ib2xzLmpzJywgb3B0aW9ucyxcbiAgICAgIGhvc3QpO1xuICBjb25zdCBkdHMgPSB0cmFuc2Zvcm1EdHMgPyBtYWtlQnVuZGxlUHJvZ3JhbShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLCBpc0NvcmUsIEFic29sdXRlRnNQYXRoLnJlc29sdmUoZW50cnlQb2ludFBhdGgsIHR5cGluZ3NQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyM19zeW1ib2xzLmQudHMnLCBvcHRpb25zLCBob3N0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gIGNvbnN0IGlzRmxhdENvcmUgPSBpc0NvcmUgJiYgc3JjLnIzU3ltYm9sc0ZpbGUgPT09IG51bGw7XG5cbiAgcmV0dXJuIHtmb3JtYXQsIGZvcm1hdFByb3BlcnR5LCByb290RGlycywgaXNDb3JlLCBpc0ZsYXRDb3JlLCBzcmMsIGR0c307XG59XG4iXX0=