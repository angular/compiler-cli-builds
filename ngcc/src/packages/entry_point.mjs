/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
import { parseStatementForUmdModule } from '../host/umd_host';
import { resolveFileWithPostfixes } from '../utils';
// We need to keep the elements of this const and the `EntryPointJsonProperty` type in sync.
export const SUPPORTED_FORMAT_PROPERTIES = ['fesm2015', 'fesm5', 'es2015', 'esm2015', 'esm5', 'main', 'module', 'browser'];
/**
 * The path does not represent an entry-point, i.e. there is no package.json at the path and there
 * is no config to force an entry-point.
 */
export const NO_ENTRY_POINT = 'no-entry-point';
/**
 * The path represents an entry-point that is `ignored` by an ngcc config.
 */
export const IGNORED_ENTRY_POINT = 'ignored-entry-point';
/**
 * The path has a package.json, but it is not a valid entry-point for ngcc processing.
 */
export const INCOMPATIBLE_ENTRY_POINT = 'incompatible-entry-point';
/**
 * Try to create an entry-point from the given paths and properties.
 *
 * @param packagePath the absolute path to the containing npm package
 * @param entryPointPath the absolute path to the potential entry-point.
 * @returns
 * - An entry-point if it is valid and not ignored.
 * - `NO_ENTRY_POINT` when there is no package.json at the path and there is no config to force an
 *   entry-point,
 * - `IGNORED_ENTRY_POINT` when the entry-point is ignored by an ngcc config.
 * - `INCOMPATIBLE_ENTRY_POINT` when there is a package.json but it is not a valid Angular compiled
 *   entry-point.
 */
export function getEntryPointInfo(fs, config, logger, packagePath, entryPointPath) {
    const packagePackageJsonPath = fs.resolve(packagePath, 'package.json');
    const entryPointPackageJsonPath = fs.resolve(entryPointPath, 'package.json');
    const loadedPackagePackageJson = loadPackageJson(fs, packagePackageJsonPath);
    const loadedEntryPointPackageJson = (packagePackageJsonPath === entryPointPackageJsonPath) ?
        loadedPackagePackageJson :
        loadPackageJson(fs, entryPointPackageJsonPath);
    const { packageName, packageVersion } = getPackageNameAndVersion(fs, packagePath, loadedPackagePackageJson, loadedEntryPointPackageJson);
    const packageConfig = config.getPackageConfig(packageName, packagePath, packageVersion);
    const entryPointConfig = packageConfig.entryPoints.get(entryPointPath);
    let entryPointPackageJson;
    if (entryPointConfig === undefined) {
        if (!fs.exists(entryPointPackageJsonPath)) {
            // No `package.json` and no config.
            return NO_ENTRY_POINT;
        }
        else if (loadedEntryPointPackageJson === null) {
            // `package.json` exists but could not be parsed and there is no redeeming config.
            logger.warn(`Failed to read entry point info from invalid 'package.json' file: ${entryPointPackageJsonPath}`);
            return INCOMPATIBLE_ENTRY_POINT;
        }
        else {
            entryPointPackageJson = loadedEntryPointPackageJson;
        }
    }
    else if (entryPointConfig.ignore === true) {
        // Explicitly ignored entry-point.
        return IGNORED_ENTRY_POINT;
    }
    else {
        entryPointPackageJson = mergeConfigAndPackageJson(fs, loadedEntryPointPackageJson, entryPointConfig, packagePath, entryPointPath);
    }
    const typings = entryPointPackageJson.typings || entryPointPackageJson.types ||
        guessTypingsFromPackageJson(fs, entryPointPath, entryPointPackageJson);
    if (typeof typings !== 'string') {
        // Missing the required `typings` property
        return INCOMPATIBLE_ENTRY_POINT;
    }
    // An entry-point is assumed to be compiled by Angular if there is either:
    // * a `metadata.json` file next to the typings entry-point
    // * a custom config for this entry-point
    const metadataPath = fs.resolve(entryPointPath, typings.replace(/\.d\.ts$/, '') + '.metadata.json');
    const compiledByAngular = entryPointConfig !== undefined || fs.exists(metadataPath);
    const entryPointInfo = {
        name: entryPointPackageJson.name,
        path: entryPointPath,
        packageName,
        packagePath,
        packageJson: entryPointPackageJson,
        typings: fs.resolve(entryPointPath, typings),
        compiledByAngular,
        ignoreMissingDependencies: entryPointConfig !== undefined ? !!entryPointConfig.ignoreMissingDependencies : false,
        generateDeepReexports: entryPointConfig !== undefined ? !!entryPointConfig.generateDeepReexports : false,
    };
    return entryPointInfo;
}
export function isEntryPoint(result) {
    return result !== NO_ENTRY_POINT && result !== INCOMPATIBLE_ENTRY_POINT &&
        result !== IGNORED_ENTRY_POINT;
}
/**
 * Convert a package.json property into an entry-point format.
 *
 * @param property The property to convert to a format.
 * @returns An entry-point format or `undefined` if none match the given property.
 */
export function getEntryPointFormat(fs, entryPoint, property) {
    switch (property) {
        case 'fesm2015':
            return 'esm2015';
        case 'fesm5':
            return 'esm5';
        case 'es2015':
            return 'esm2015';
        case 'esm2015':
            return 'esm2015';
        case 'esm5':
            return 'esm5';
        case 'browser':
            const browserFile = entryPoint.packageJson['browser'];
            if (typeof browserFile !== 'string') {
                return undefined;
            }
            return sniffModuleFormat(fs, fs.join(entryPoint.path, browserFile));
        case 'main':
            const mainFile = entryPoint.packageJson['main'];
            if (mainFile === undefined) {
                return undefined;
            }
            return sniffModuleFormat(fs, fs.join(entryPoint.path, mainFile));
        case 'module':
            const moduleFilePath = entryPoint.packageJson['module'];
            // As of version 10, the `module` property in `package.json` should point to
            // the ESM2015 format output as per Angular Package format specification. This
            // means that the `module` property captures multiple formats, as old libraries
            // built with the old APF can still be processed. We detect the format by checking
            // the paths that should be used as per APF specification.
            if (typeof moduleFilePath === 'string' && moduleFilePath.includes('esm2015')) {
                return `esm2015`;
            }
            return 'esm5';
        default:
            return undefined;
    }
}
/**
 * Parse the JSON from a `package.json` file.
 * @param packageJsonPath the absolute path to the `package.json` file.
 * @returns JSON from the `package.json` file if it is valid, `null` otherwise.
 */
function loadPackageJson(fs, packageJsonPath) {
    try {
        return JSON.parse(fs.readFile(packageJsonPath));
    }
    catch (_a) {
        return null;
    }
}
function sniffModuleFormat(fs, sourceFilePath) {
    const resolvedPath = resolveFileWithPostfixes(fs, sourceFilePath, ['', '.js', '/index.js']);
    if (resolvedPath === null) {
        return undefined;
    }
    const sourceFile = ts.createSourceFile(sourceFilePath, fs.readFile(resolvedPath), ts.ScriptTarget.ES5);
    if (sourceFile.statements.length === 0) {
        return undefined;
    }
    if (ts.isExternalModule(sourceFile)) {
        return 'esm5';
    }
    else if (parseStatementForUmdModule(sourceFile.statements[0]) !== null) {
        return 'umd';
    }
    else {
        return 'commonjs';
    }
}
function mergeConfigAndPackageJson(fs, entryPointPackageJson, entryPointConfig, packagePath, entryPointPath) {
    if (entryPointPackageJson !== null) {
        return Object.assign(Object.assign({}, entryPointPackageJson), entryPointConfig.override);
    }
    else {
        const name = `${fs.basename(packagePath)}/${fs.relative(packagePath, entryPointPath)}`;
        return Object.assign({ name }, entryPointConfig.override);
    }
}
function guessTypingsFromPackageJson(fs, entryPointPath, entryPointPackageJson) {
    for (const prop of SUPPORTED_FORMAT_PROPERTIES) {
        const field = entryPointPackageJson[prop];
        if (typeof field !== 'string') {
            // Some crazy packages have things like arrays in these fields!
            continue;
        }
        const relativeTypingsPath = field.replace(/\.js$/, '.d.ts');
        const typingsPath = fs.resolve(entryPointPath, relativeTypingsPath);
        if (fs.exists(typingsPath)) {
            return typingsPath;
        }
    }
    return null;
}
/**
 * Find or infer the name and version of a package.
 *
 * - The name is computed based on the `name` property of the package's or the entry-point's
 *   `package.json` file (if available) or inferred from the package's path.
 * - The version is read off of the `version` property of the package's `package.json` file (if
 *   available).
 *
 * @param fs The file-system to use for processing `packagePath`.
 * @param packagePath the absolute path to the package.
 * @param packagePackageJson the parsed `package.json` of the package (if available).
 * @param entryPointPackageJson the parsed `package.json` of an entry-point (if available).
 * @returns the computed name and version of the package.
 */
function getPackageNameAndVersion(fs, packagePath, packagePackageJson, entryPointPackageJson) {
    var _a;
    let packageName;
    if (packagePackageJson !== null) {
        // We have a valid `package.json` for the package: Get the package name from that.
        packageName = packagePackageJson.name;
    }
    else if (entryPointPackageJson !== null) {
        // We have a valid `package.json` for the entry-point: Get the package name from that.
        // This might be a secondary entry-point, so make sure we only keep the main package's name
        // (e.g. only keep `@angular/common` from `@angular/common/http`).
        packageName = /^(?:@[^/]+\/)?[^/]*/.exec(entryPointPackageJson.name)[0];
    }
    else {
        // We don't have a valid `package.json`: Infer the package name from the package's path.
        const lastSegment = fs.basename(packagePath);
        const secondLastSegment = fs.basename(fs.dirname(packagePath));
        packageName =
            secondLastSegment.startsWith('@') ? `${secondLastSegment}/${lastSegment}` : lastSegment;
    }
    return {
        packageName,
        packageVersion: (_a = packagePackageJson === null || packagePackageJson === void 0 ? void 0 : packagePackageJson.version) !== null && _a !== void 0 ? _a : null,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50cnlfcG9pbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbmdjYy9zcmMvcGFja2FnZXMvZW50cnlfcG9pbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFJakMsT0FBTyxFQUFDLDBCQUEwQixFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDNUQsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBc0VsRCw0RkFBNEY7QUFDNUYsTUFBTSxDQUFDLE1BQU0sMkJBQTJCLEdBQ3BDLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBR3BGOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQztBQUUvQzs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLHFCQUFxQixDQUFDO0FBRXpEOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQUcsMEJBQTBCLENBQUM7QUFlbkU7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQUM3QixFQUFzQixFQUFFLE1BQXlCLEVBQUUsTUFBYyxFQUFFLFdBQTJCLEVBQzlGLGNBQThCO0lBQ2hDLE1BQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDdkUsTUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUM3RSxNQUFNLHdCQUF3QixHQUFHLGVBQWUsQ0FBQyxFQUFFLEVBQUUsc0JBQXNCLENB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RUFBb0IsRUFBRSxXQUEyQixFQUNqRCxrQkFBOEMsRUFDOUMscUJBQ0k7O0lBQ04sSUFBSSxXQUFtQixDQUFDO0lBRXhCLElBQUksa0JBQWtCLEtBQUssSUFBSSxFQUFFO1FBQy9CLGtGQUFrRjtRQUNsRixXQUFXLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDO0tBQ3ZDO1NBQU0sSUFBSSxxQkFBcUIsS0FBSyxJQUFJLEVBQUU7UUFDekMsc0ZBQXNGO1FBQ3RGLDJGQUEyRjtRQUMzRixrRUFBa0U7UUFDbEUsV0FBVyxHQUFHLHFCQUFxQixDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMxRTtTQUFNO1FBQ0wsd0ZBQXdGO1FBQ3hGLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0MsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUUvRCxXQUFXO1lBQ1AsaUJBQWlCLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGlCQUFpQixJQUFJLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7S0FDN0Y7SUFFRCxPQUFPO1FBQ0wsV0FBVztRQUNYLGNBQWMsRUFBRSxNQUFBLGtCQUFrQixhQUFsQixrQkFBa0IsdUJBQWxCLGtCQUFrQixDQUFFLE9BQU8sbUNBQUksSUFBSTtLQUNwRCxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7QWJzb2x1dGVGc1BhdGgsIFBhdGhNYW5pcHVsYXRpb24sIFJlYWRvbmx5RmlsZVN5c3RlbX0gZnJvbSAnLi4vLi4vLi4vc3JjL25ndHNjL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi8uLi9zcmMvbmd0c2MvbG9nZ2luZyc7XG5pbXBvcnQge3BhcnNlU3RhdGVtZW50Rm9yVW1kTW9kdWxlfSBmcm9tICcuLi9ob3N0L3VtZF9ob3N0JztcbmltcG9ydCB7cmVzb2x2ZUZpbGVXaXRoUG9zdGZpeGVzfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7TmdjY0NvbmZpZ3VyYXRpb24sIE5nY2NFbnRyeVBvaW50Q29uZmlnfSBmcm9tICcuL2NvbmZpZ3VyYXRpb24nO1xuXG4vKipcbiAqIFRoZSBwb3NzaWJsZSB2YWx1ZXMgZm9yIHRoZSBmb3JtYXQgb2YgYW4gZW50cnktcG9pbnQuXG4gKi9cbmV4cG9ydCB0eXBlIEVudHJ5UG9pbnRGb3JtYXQgPSAnZXNtNSd8J2VzbTIwMTUnfCd1bWQnfCdjb21tb25qcyc7XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgYW4gZW50cnktcG9pbnQsIGluY2x1ZGluZyBwYXRoc1xuICogdG8gZWFjaCBvZiB0aGUgcG9zc2libGUgZW50cnktcG9pbnQgZm9ybWF0cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbnRyeVBvaW50IGV4dGVuZHMgSnNvbk9iamVjdCB7XG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgZW50cnktcG9pbnQgKGUuZy4gYEBhbmd1bGFyL2NvcmVgIG9yIGBAYW5ndWxhci9jb21tb24vaHR0cGApLiAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKiBUaGUgcGF0aCB0byB0aGlzIGVudHJ5IHBvaW50LiAqL1xuICBwYXRoOiBBYnNvbHV0ZUZzUGF0aDtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRoYXQgY29udGFpbnMgdGhpcyBlbnRyeS1wb2ludCAoZS5nLiBgQGFuZ3VsYXIvY29yZWAgb3JcbiAgICogYEBhbmd1bGFyL2NvbW1vbmApLlxuICAgKi9cbiAgcGFja2FnZU5hbWU6IHN0cmluZztcbiAgLyoqIFRoZSBwYXRoIHRvIHRoZSBwYWNrYWdlIHRoYXQgY29udGFpbnMgdGhpcyBlbnRyeS1wb2ludC4gKi9cbiAgcGFja2FnZVBhdGg6IEFic29sdXRlRnNQYXRoO1xuICAvKiogVGhlIHBhcnNlZCBwYWNrYWdlLmpzb24gZmlsZSBmb3IgdGhpcyBlbnRyeS1wb2ludC4gKi9cbiAgcGFja2FnZUpzb246IEVudHJ5UG9pbnRQYWNrYWdlSnNvbjtcbiAgLyoqIFRoZSBwYXRoIHRvIGEgdHlwaW5ncyAoLmQudHMpIGZpbGUgZm9yIHRoaXMgZW50cnktcG9pbnQuICovXG4gIHR5cGluZ3M6IEFic29sdXRlRnNQYXRoO1xuICAvKiogSXMgdGhpcyBFbnRyeVBvaW50IGNvbXBpbGVkIHdpdGggdGhlIEFuZ3VsYXIgVmlldyBFbmdpbmUgY29tcGlsZXI/ICovXG4gIGNvbXBpbGVkQnlBbmd1bGFyOiBib29sZWFuO1xuICAvKiogU2hvdWxkIG5nY2MgaWdub3JlIG1pc3NpbmcgZGVwZW5kZW5jaWVzIGFuZCBwcm9jZXNzIHRoaXMgZW50cnlwb2ludCBhbnl3YXk/ICovXG4gIGlnbm9yZU1pc3NpbmdEZXBlbmRlbmNpZXM6IGJvb2xlYW47XG4gIC8qKiBTaG91bGQgbmdjYyBnZW5lcmF0ZSBkZWVwIHJlLWV4cG9ydHMgZm9yIHRoaXMgZW50cnlwb2ludD8gKi9cbiAgZ2VuZXJhdGVEZWVwUmVleHBvcnRzOiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBKc29uUHJpbWl0aXZlID0gc3RyaW5nfG51bWJlcnxib29sZWFufG51bGw7XG5leHBvcnQgdHlwZSBKc29uVmFsdWUgPSBKc29uUHJpbWl0aXZlfEpzb25BcnJheXxKc29uT2JqZWN0fHVuZGVmaW5lZDtcbmV4cG9ydCBpbnRlcmZhY2UgSnNvbkFycmF5IGV4dGVuZHMgQXJyYXk8SnNvblZhbHVlPiB7fVxuZXhwb3J0IGludGVyZmFjZSBKc29uT2JqZWN0IHtcbiAgW2tleTogc3RyaW5nXTogSnNvblZhbHVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhY2thZ2VKc29uRm9ybWF0UHJvcGVydGllc01hcCB7XG4gIGJyb3dzZXI/OiBzdHJpbmc7XG4gIGZlc20yMDE1Pzogc3RyaW5nO1xuICBmZXNtNT86IHN0cmluZztcbiAgZXMyMDE1Pzogc3RyaW5nOyAgLy8gaWYgZXhpc3RzIHRoZW4gaXQgaXMgYWN0dWFsbHkgRkVTTTIwMTVcbiAgZXNtMjAxNT86IHN0cmluZztcbiAgZXNtNT86IHN0cmluZztcbiAgbWFpbj86IHN0cmluZzsgICAgIC8vIFVNRFxuICBtb2R1bGU/OiBzdHJpbmc7ICAgLy8gaWYgZXhpc3RzIHRoZW4gaXQgaXMgYWN0dWFsbHkgRkVTTTVcbiAgdHlwZXM/OiBzdHJpbmc7ICAgIC8vIFN5bm9ueW1vdXMgdG8gYHR5cGluZ3NgIHByb3BlcnR5IC0gc2VlIGh0dHBzOi8vYml0Lmx5LzJPZ1dwMkhcbiAgdHlwaW5ncz86IHN0cmluZzsgIC8vIFR5cGVTY3JpcHQgLmQudHMgZmlsZXNcbn1cblxuZXhwb3J0IHR5cGUgUGFja2FnZUpzb25Gb3JtYXRQcm9wZXJ0aWVzID0ga2V5b2YgUGFja2FnZUpzb25Gb3JtYXRQcm9wZXJ0aWVzTWFwO1xuXG4vKipcbiAqIFRoZSBwcm9wZXJ0aWVzIHRoYXQgbWF5IGJlIGxvYWRlZCBmcm9tIHRoZSBgcGFja2FnZS5qc29uYCBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudHJ5UG9pbnRQYWNrYWdlSnNvbiBleHRlbmRzIEpzb25PYmplY3QsIFBhY2thZ2VKc29uRm9ybWF0UHJvcGVydGllc01hcCB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmVyc2lvbj86IHN0cmluZztcbiAgc2NyaXB0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIF9fcHJvY2Vzc2VkX2J5X2l2eV9uZ2NjX18/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufVxuXG5leHBvcnQgdHlwZSBFbnRyeVBvaW50SnNvblByb3BlcnR5ID0gRXhjbHVkZTxQYWNrYWdlSnNvbkZvcm1hdFByb3BlcnRpZXMsICd0eXBlcyd8J3R5cGluZ3MnPjtcbi8vIFdlIG5lZWQgdG8ga2VlcCB0aGUgZWxlbWVudHMgb2YgdGhpcyBjb25zdCBhbmQgdGhlIGBFbnRyeVBvaW50SnNvblByb3BlcnR5YCB0eXBlIGluIHN5bmMuXG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0ZPUk1BVF9QUk9QRVJUSUVTOiBFbnRyeVBvaW50SnNvblByb3BlcnR5W10gPVxuICAgIFsnZmVzbTIwMTUnLCAnZmVzbTUnLCAnZXMyMDE1JywgJ2VzbTIwMTUnLCAnZXNtNScsICdtYWluJywgJ21vZHVsZScsICdicm93c2VyJ107XG5cblxuLyoqXG4gKiBUaGUgcGF0aCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW50cnktcG9pbnQsIGkuZS4gdGhlcmUgaXMgbm8gcGFja2FnZS5qc29uIGF0IHRoZSBwYXRoIGFuZCB0aGVyZVxuICogaXMgbm8gY29uZmlnIHRvIGZvcmNlIGFuIGVudHJ5LXBvaW50LlxuICovXG5leHBvcnQgY29uc3QgTk9fRU5UUllfUE9JTlQgPSAnbm8tZW50cnktcG9pbnQnO1xuXG4vKipcbiAqIFRoZSBwYXRoIHJlcHJlc2VudHMgYW4gZW50cnktcG9pbnQgdGhhdCBpcyBgaWdub3JlZGAgYnkgYW4gbmdjYyBjb25maWcuXG4gKi9cbmV4cG9ydCBjb25zdCBJR05PUkVEX0VOVFJZX1BPSU5UID0gJ2lnbm9yZWQtZW50cnktcG9pbnQnO1xuXG4vKipcbiAqIFRoZSBwYXRoIGhhcyBhIHBhY2thZ2UuanNvbiwgYnV0IGl0IGlzIG5vdCBhIHZhbGlkIGVudHJ5LXBvaW50IGZvciBuZ2NjIHByb2Nlc3NpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBJTkNPTVBBVElCTEVfRU5UUllfUE9JTlQgPSAnaW5jb21wYXRpYmxlLWVudHJ5LXBvaW50JztcblxuLyoqXG4gKiBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgYGdldEVudHJ5UG9pbnRJbmZvKClgLlxuICpcbiAqIFRoaXMgd2lsbCBiZSBhbiBgRW50cnlQb2ludGAgb2JqZWN0IGlmIGFuIEFuZ3VsYXIgZW50cnktcG9pbnQgd2FzIGlkZW50aWZpZWQ7XG4gKiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhIGZsYWcgaW5kaWNhdGluZyBvbmUgb2Y6XG4gKiAqIE5PX0VOVFJZX1BPSU5UIC0gdGhlIHBhdGggaXMgbm90IGFuIGVudHJ5LXBvaW50IG9yIG5nY2MgaXMgY29uZmlndXJlZCB0byBpZ25vcmUgaXRcbiAqICogSU5DT01QQVRJQkxFX0VOVFJZX1BPSU5UIC0gdGhlIHBhdGggd2FzIGEgbm9uLXByb2Nlc3NhYmxlIGVudHJ5LXBvaW50IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkXG4gKiBmb3Igc3ViLWVudHJ5LXBvaW50c1xuICovXG5leHBvcnQgdHlwZSBHZXRFbnRyeVBvaW50UmVzdWx0ID1cbiAgICBFbnRyeVBvaW50fHR5cGVvZiBJR05PUkVEX0VOVFJZX1BPSU5UfHR5cGVvZiBJTkNPTVBBVElCTEVfRU5UUllfUE9JTlR8dHlwZW9mIE5PX0VOVFJZX1BPSU5UO1xuXG5cbi8qKlxuICogVHJ5IHRvIGNyZWF0ZSBhbiBlbnRyeS1wb2ludCBmcm9tIHRoZSBnaXZlbiBwYXRocyBhbmQgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gcGFja2FnZVBhdGggdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGNvbnRhaW5pbmcgbnBtIHBhY2thZ2VcbiAqIEBwYXJhbSBlbnRyeVBvaW50UGF0aCB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgcG90ZW50aWFsIGVudHJ5LXBvaW50LlxuICogQHJldHVybnNcbiAqIC0gQW4gZW50cnktcG9pbnQgaWYgaXQgaXMgdmFsaWQgYW5kIG5vdCBpZ25vcmVkLlxuICogLSBgTk9fRU5UUllfUE9JTlRgIHdoZW4gdGhlcmUgaXMgbm8gcGFja2FnZS5qc29uIGF0IHRoZSBwYXRoIGFuZCB0aGVyZSBpcyBubyBjb25maWcgdG8gZm9yY2UgYW5cbiAqICAgZW50cnktcG9pbnQsXG4gKiAtIGBJR05PUkVEX0VOVFJZX1BPSU5UYCB3aGVuIHRoZSBlbnRyeS1wb2ludCBpcyBpZ25vcmVkIGJ5IGFuIG5nY2MgY29uZmlnLlxuICogLSBgSU5DT01QQVRJQkxFX0VOVFJZX1BPSU5UYCB3aGVuIHRoZXJlIGlzIGEgcGFja2FnZS5qc29uIGJ1dCBpdCBpcyBub3QgYSB2YWxpZCBBbmd1bGFyIGNvbXBpbGVkXG4gKiAgIGVudHJ5LXBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW50cnlQb2ludEluZm8oXG4gICAgZnM6IFJlYWRvbmx5RmlsZVN5c3RlbSwgY29uZmlnOiBOZ2NjQ29uZmlndXJhdGlvbiwgbG9nZ2VyOiBMb2dnZXIsIHBhY2thZ2VQYXRoOiBBYnNvbHV0ZUZzUGF0aCxcbiAgICBlbnRyeVBvaW50UGF0aDogQWJzb2x1dGVGc1BhdGgpOiBHZXRFbnRyeVBvaW50UmVzdWx0IHtcbiAgY29uc3QgcGFja2FnZVBhY2thZ2VKc29uUGF0aCA9IGZzLnJlc29sdmUocGFja2FnZVBhdGgsICdwYWNrYWdlLmpzb24nKTtcbiAgY29uc3QgZW50cnlQb2ludFBhY2thZ2VKc29uUGF0aCA9IGZzLnJlc29sdmUoZW50cnlQb2ludFBhdGgsICdwYWNrYWdlLmpzb24nKTtcbiAgY29uc3QgbG9hZGVkUGFja2FnZVBhY2thZ2VKc29uID0gbG9hZFBhY2thZ2VKc29uKGZzLCBwYWNrYWdlUGFja2FnZUpzb25QYXRoKTtcbiAgY29uc3QgbG9hZGVkRW50cnlQb2ludFBhY2thZ2VKc29uID0gKHBhY2thZ2VQYWNrYWdlSnNvblBhdGggPT09IGVudHJ5UG9pbnRQYWNrYWdlSnNvblBhdGgpID9cbiAgICAgIGxvYWRlZFBhY2thZ2VQYWNrYWdlSnNvbiA6XG4gICAgICBsb2FkUGFja2FnZUpzb24oZnMsIGVudHJ5UG9pbnRQYWNrYWdlSnNvblBhdGgpO1xuICBjb25zdCB7cGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9ufSA9IGdldFBhY2thZ2VOYW1lQW5kVmVyc2lvbihcbiAgICAgIGZzLCBwYWNrYWdlUGF0aCwgbG9hZGVkUGFja2FnZVBhY2thZ2VKc29uLCBsb2FkZWRFbnRyeVBvaW50UGFja2FnZUpzb24pO1xuXG4gIGNvbnN0IHBhY2thZ2VDb25maWcgPSBjb25maWcuZ2V0UGFja2FnZUNvbmZpZyhwYWNrYWdlTmFtZSwgcGFja2FnZVBhdGgsIHBhY2thZ2VWZXJzaW9uKTtcbiAgY29uc3QgZW50cnlQb2ludENvbmZpZyA9IHBhY2thZ2VDb25maWcuZW50cnlQb2ludHMuZ2V0KGVudHJ5UG9pbnRQYXRoKTtcbiAgbGV0IGVudHJ5UG9pbnRQYWNrYWdlSnNvbjogRW50cnlQb2ludFBhY2thZ2VKc29uO1xuXG4gIGlmIChlbnRyeVBvaW50Q29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIWZzLmV4aXN0cyhlbnRyeVBvaW50UGFja2FnZUpzb25QYXRoKSkge1xuICAgICAgLy8gTm8gYHBhY2thZ2UuanNvbmAgYW5kIG5vIGNvbmZpZy5cbiAgICAgIHJldHVybiBOT19FTlRSWV9QT0lOVDtcbiAgICB9IGVsc2UgaWYgKGxvYWRlZEVudHJ5UG9pbnRQYWNrYWdlSnNvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gYHBhY2thZ2UuanNvbmAgZXhpc3RzIGJ1dCBjb3VsZCBub3QgYmUgcGFyc2VkIGFuZCB0aGVyZSBpcyBubyByZWRlZW1pbmcgY29uZmlnLlxuICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byByZWFkIGVudHJ5IHBvaW50IGluZm8gZnJvbSBpbnZhbGlkICdwYWNrYWdlLmpzb24nIGZpbGU6ICR7XG4gICAgICAgICAgZW50cnlQb2ludFBhY2thZ2VKc29uUGF0aH1gKTtcblxuICAgICAgcmV0dXJuIElOQ09NUEFUSUJMRV9FTlRSWV9QT0lOVDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnlQb2ludFBhY2thZ2VKc29uID0gbG9hZGVkRW50cnlQb2ludFBhY2thZ2VKc29uO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbnRyeVBvaW50Q29uZmlnLmlnbm9yZSA9PT0gdHJ1ZSkge1xuICAgIC8vIEV4cGxpY2l0bHkgaWdub3JlZCBlbnRyeS1wb2ludC5cbiAgICByZXR1cm4gSUdOT1JFRF9FTlRSWV9QT0lOVDtcbiAgfSBlbHNlIHtcbiAgICBlbnRyeVBvaW50UGFja2FnZUpzb24gPSBtZXJnZUNvbmZpZ0FuZFBhY2thZ2VKc29uKFxuICAgICAgICBmcywgbG9hZGVkRW50cnlQb2ludFBhY2thZ2VKc29uLCBlbnRyeVBvaW50Q29uZmlnLCBwYWNrYWdlUGF0aCwgZW50cnlQb2ludFBhdGgpO1xuICB9XG5cbiAgY29uc3QgdHlwaW5ncyA9IGVudHJ5UG9pbnRQYWNrYWdlSnNvbi50eXBpbmdzIHx8IGVudHJ5UG9pbnRQYWNrYWdlSnNvbi50eXBlcyB8fFxuICAgICAgZ3Vlc3NUeXBpbmdzRnJvbVBhY2thZ2VKc29uKGZzLCBlbnRyeVBvaW50UGF0aCwgZW50cnlQb2ludFBhY2thZ2VKc29uKTtcbiAgaWYgKHR5cGVvZiB0eXBpbmdzICE9PSAnc3RyaW5nJykge1xuICAgIC8vIE1pc3NpbmcgdGhlIHJlcXVpcmVkIGB0eXBpbmdzYCBwcm9wZXJ0eVxuICAgIHJldHVybiBJTkNPTVBBVElCTEVfRU5UUllfUE9JTlQ7XG4gIH1cblxuICAvLyBBbiBlbnRyeS1wb2ludCBpcyBhc3N1bWVkIHRvIGJlIGNvbXBpbGVkIGJ5IEFuZ3VsYXIgaWYgdGhlcmUgaXMgZWl0aGVyOlxuICAvLyAqIGEgYG1ldGFkYXRhLmpzb25gIGZpbGUgbmV4dCB0byB0aGUgdHlwaW5ncyBlbnRyeS1wb2ludFxuICAvLyAqIGEgY3VzdG9tIGNvbmZpZyBmb3IgdGhpcyBlbnRyeS1wb2ludFxuICBjb25zdCBtZXRhZGF0YVBhdGggPVxuICAgICAgZnMucmVzb2x2ZShlbnRyeVBvaW50UGF0aCwgdHlwaW5ncy5yZXBsYWNlKC9cXC5kXFwudHMkLywgJycpICsgJy5tZXRhZGF0YS5qc29uJyk7XG4gIGNvbnN0IGNvbXBpbGVkQnlBbmd1bGFyID0gZW50cnlQb2ludENvbmZpZyAhPT0gdW5kZWZpbmVkIHx8IGZzLmV4aXN0cyhtZXRhZGF0YVBhdGgpO1xuXG4gIGNvbnN0IGVudHJ5UG9pbnRJbmZvOiBFbnRyeVBvaW50ID0ge1xuICAgIG5hbWU6IGVudHJ5UG9pbnRQYWNrYWdlSnNvbi5uYW1lLFxuICAgIHBhdGg6IGVudHJ5UG9pbnRQYXRoLFxuICAgIHBhY2thZ2VOYW1lLFxuICAgIHBhY2thZ2VQYXRoLFxuICAgIHBhY2thZ2VKc29uOiBlbnRyeVBvaW50UGFja2FnZUpzb24sXG4gICAgdHlwaW5nczogZnMucmVzb2x2ZShlbnRyeVBvaW50UGF0aCwgdHlwaW5ncyksXG4gICAgY29tcGlsZWRCeUFuZ3VsYXIsXG4gICAgaWdub3JlTWlzc2luZ0RlcGVuZGVuY2llczpcbiAgICAgICAgZW50cnlQb2ludENvbmZpZyAhPT0gdW5kZWZpbmVkID8gISFlbnRyeVBvaW50Q29uZmlnLmlnbm9yZU1pc3NpbmdEZXBlbmRlbmNpZXMgOiBmYWxzZSxcbiAgICBnZW5lcmF0ZURlZXBSZWV4cG9ydHM6XG4gICAgICAgIGVudHJ5UG9pbnRDb25maWcgIT09IHVuZGVmaW5lZCA/ICEhZW50cnlQb2ludENvbmZpZy5nZW5lcmF0ZURlZXBSZWV4cG9ydHMgOiBmYWxzZSxcbiAgfTtcblxuICByZXR1cm4gZW50cnlQb2ludEluZm87XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VudHJ5UG9pbnQocmVzdWx0OiBHZXRFbnRyeVBvaW50UmVzdWx0KTogcmVzdWx0IGlzIEVudHJ5UG9pbnQge1xuICByZXR1cm4gcmVzdWx0ICE9PSBOT19FTlRSWV9QT0lOVCAmJiByZXN1bHQgIT09IElOQ09NUEFUSUJMRV9FTlRSWV9QT0lOVCAmJlxuICAgICAgcmVzdWx0ICE9PSBJR05PUkVEX0VOVFJZX1BPSU5UO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBwYWNrYWdlLmpzb24gcHJvcGVydHkgaW50byBhbiBlbnRyeS1wb2ludCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjb252ZXJ0IHRvIGEgZm9ybWF0LlxuICogQHJldHVybnMgQW4gZW50cnktcG9pbnQgZm9ybWF0IG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgbWF0Y2ggdGhlIGdpdmVuIHByb3BlcnR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW50cnlQb2ludEZvcm1hdChcbiAgICBmczogUmVhZG9ubHlGaWxlU3lzdGVtLCBlbnRyeVBvaW50OiBFbnRyeVBvaW50LFxuICAgIHByb3BlcnR5OiBFbnRyeVBvaW50SnNvblByb3BlcnR5KTogRW50cnlQb2ludEZvcm1hdHx1bmRlZmluZWQge1xuICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnZmVzbTIwMTUnOlxuICAgICAgcmV0dXJuICdlc20yMDE1JztcbiAgICBjYXNlICdmZXNtNSc6XG4gICAgICByZXR1cm4gJ2VzbTUnO1xuICAgIGNhc2UgJ2VzMjAxNSc6XG4gICAgICByZXR1cm4gJ2VzbTIwMTUnO1xuICAgIGNhc2UgJ2VzbTIwMTUnOlxuICAgICAgcmV0dXJuICdlc20yMDE1JztcbiAgICBjYXNlICdlc201JzpcbiAgICAgIHJldHVybiAnZXNtNSc7XG4gICAgY2FzZSAnYnJvd3Nlcic6XG4gICAgICBjb25zdCBicm93c2VyRmlsZSA9IGVudHJ5UG9pbnQucGFja2FnZUpzb25bJ2Jyb3dzZXInXTtcbiAgICAgIGlmICh0eXBlb2YgYnJvd3NlckZpbGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc25pZmZNb2R1bGVGb3JtYXQoZnMsIGZzLmpvaW4oZW50cnlQb2ludC5wYXRoLCBicm93c2VyRmlsZSkpO1xuICAgIGNhc2UgJ21haW4nOlxuICAgICAgY29uc3QgbWFpbkZpbGUgPSBlbnRyeVBvaW50LnBhY2thZ2VKc29uWydtYWluJ107XG4gICAgICBpZiAobWFpbkZpbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNuaWZmTW9kdWxlRm9ybWF0KGZzLCBmcy5qb2luKGVudHJ5UG9pbnQucGF0aCwgbWFpbkZpbGUpKTtcbiAgICBjYXNlICdtb2R1bGUnOlxuICAgICAgY29uc3QgbW9kdWxlRmlsZVBhdGggPSBlbnRyeVBvaW50LnBhY2thZ2VKc29uWydtb2R1bGUnXTtcbiAgICAgIC8vIEFzIG9mIHZlcnNpb24gMTAsIHRoZSBgbW9kdWxlYCBwcm9wZXJ0eSBpbiBgcGFja2FnZS5qc29uYCBzaG91bGQgcG9pbnQgdG9cbiAgICAgIC8vIHRoZSBFU00yMDE1IGZvcm1hdCBvdXRwdXQgYXMgcGVyIEFuZ3VsYXIgUGFja2FnZSBmb3JtYXQgc3BlY2lmaWNhdGlvbi4gVGhpc1xuICAgICAgLy8gbWVhbnMgdGhhdCB0aGUgYG1vZHVsZWAgcHJvcGVydHkgY2FwdHVyZXMgbXVsdGlwbGUgZm9ybWF0cywgYXMgb2xkIGxpYnJhcmllc1xuICAgICAgLy8gYnVpbHQgd2l0aCB0aGUgb2xkIEFQRiBjYW4gc3RpbGwgYmUgcHJvY2Vzc2VkLiBXZSBkZXRlY3QgdGhlIGZvcm1hdCBieSBjaGVja2luZ1xuICAgICAgLy8gdGhlIHBhdGhzIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgcGVyIEFQRiBzcGVjaWZpY2F0aW9uLlxuICAgICAgaWYgKHR5cGVvZiBtb2R1bGVGaWxlUGF0aCA9PT0gJ3N0cmluZycgJiYgbW9kdWxlRmlsZVBhdGguaW5jbHVkZXMoJ2VzbTIwMTUnKSkge1xuICAgICAgICByZXR1cm4gYGVzbTIwMTVgO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdlc201JztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBKU09OIGZyb20gYSBgcGFja2FnZS5qc29uYCBmaWxlLlxuICogQHBhcmFtIHBhY2thZ2VKc29uUGF0aCB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZS5cbiAqIEByZXR1cm5zIEpTT04gZnJvbSB0aGUgYHBhY2thZ2UuanNvbmAgZmlsZSBpZiBpdCBpcyB2YWxpZCwgYG51bGxgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gbG9hZFBhY2thZ2VKc29uKFxuICAgIGZzOiBSZWFkb25seUZpbGVTeXN0ZW0sIHBhY2thZ2VKc29uUGF0aDogQWJzb2x1dGVGc1BhdGgpOiBFbnRyeVBvaW50UGFja2FnZUpzb258bnVsbCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZnMucmVhZEZpbGUocGFja2FnZUpzb25QYXRoKSkgYXMgRW50cnlQb2ludFBhY2thZ2VKc29uO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbmlmZk1vZHVsZUZvcm1hdChcbiAgICBmczogUmVhZG9ubHlGaWxlU3lzdGVtLCBzb3VyY2VGaWxlUGF0aDogQWJzb2x1dGVGc1BhdGgpOiBFbnRyeVBvaW50Rm9ybWF0fHVuZGVmaW5lZCB7XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IHJlc29sdmVGaWxlV2l0aFBvc3RmaXhlcyhmcywgc291cmNlRmlsZVBhdGgsIFsnJywgJy5qcycsICcvaW5kZXguanMnXSk7XG4gIGlmIChyZXNvbHZlZFBhdGggPT09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qgc291cmNlRmlsZSA9XG4gICAgICB0cy5jcmVhdGVTb3VyY2VGaWxlKHNvdXJjZUZpbGVQYXRoLCBmcy5yZWFkRmlsZShyZXNvbHZlZFBhdGgpLCB0cy5TY3JpcHRUYXJnZXQuRVM1KTtcbiAgaWYgKHNvdXJjZUZpbGUuc3RhdGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0cy5pc0V4dGVybmFsTW9kdWxlKHNvdXJjZUZpbGUpKSB7XG4gICAgcmV0dXJuICdlc201JztcbiAgfSBlbHNlIGlmIChwYXJzZVN0YXRlbWVudEZvclVtZE1vZHVsZShzb3VyY2VGaWxlLnN0YXRlbWVudHNbMF0pICE9PSBudWxsKSB7XG4gICAgcmV0dXJuICd1bWQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnY29tbW9uanMnO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnQW5kUGFja2FnZUpzb24oXG4gICAgZnM6IFBhdGhNYW5pcHVsYXRpb24sIGVudHJ5UG9pbnRQYWNrYWdlSnNvbjogRW50cnlQb2ludFBhY2thZ2VKc29ufG51bGwsXG4gICAgZW50cnlQb2ludENvbmZpZzogTmdjY0VudHJ5UG9pbnRDb25maWcsIHBhY2thZ2VQYXRoOiBBYnNvbHV0ZUZzUGF0aCxcbiAgICBlbnRyeVBvaW50UGF0aDogQWJzb2x1dGVGc1BhdGgpOiBFbnRyeVBvaW50UGFja2FnZUpzb24ge1xuICBpZiAoZW50cnlQb2ludFBhY2thZ2VKc29uICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHsuLi5lbnRyeVBvaW50UGFja2FnZUpzb24sIC4uLmVudHJ5UG9pbnRDb25maWcub3ZlcnJpZGV9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbWUgPSBgJHtmcy5iYXNlbmFtZShwYWNrYWdlUGF0aCl9LyR7ZnMucmVsYXRpdmUocGFja2FnZVBhdGgsIGVudHJ5UG9pbnRQYXRoKX1gO1xuICAgIHJldHVybiB7bmFtZSwgLi4uZW50cnlQb2ludENvbmZpZy5vdmVycmlkZX07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ3Vlc3NUeXBpbmdzRnJvbVBhY2thZ2VKc29uKFxuICAgIGZzOiBSZWFkb25seUZpbGVTeXN0ZW0sIGVudHJ5UG9pbnRQYXRoOiBBYnNvbHV0ZUZzUGF0aCxcbiAgICBlbnRyeVBvaW50UGFja2FnZUpzb246IEVudHJ5UG9pbnRQYWNrYWdlSnNvbik6IEFic29sdXRlRnNQYXRofG51bGwge1xuICBmb3IgKGNvbnN0IHByb3Agb2YgU1VQUE9SVEVEX0ZPUk1BVF9QUk9QRVJUSUVTKSB7XG4gICAgY29uc3QgZmllbGQgPSBlbnRyeVBvaW50UGFja2FnZUpzb25bcHJvcF07XG4gICAgaWYgKHR5cGVvZiBmaWVsZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFNvbWUgY3JhenkgcGFja2FnZXMgaGF2ZSB0aGluZ3MgbGlrZSBhcnJheXMgaW4gdGhlc2UgZmllbGRzIVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0aXZlVHlwaW5nc1BhdGggPSBmaWVsZC5yZXBsYWNlKC9cXC5qcyQvLCAnLmQudHMnKTtcbiAgICBjb25zdCB0eXBpbmdzUGF0aCA9IGZzLnJlc29sdmUoZW50cnlQb2ludFBhdGgsIHJlbGF0aXZlVHlwaW5nc1BhdGgpO1xuICAgIGlmIChmcy5leGlzdHModHlwaW5nc1BhdGgpKSB7XG4gICAgICByZXR1cm4gdHlwaW5nc1BhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgb3IgaW5mZXIgdGhlIG5hbWUgYW5kIHZlcnNpb24gb2YgYSBwYWNrYWdlLlxuICpcbiAqIC0gVGhlIG5hbWUgaXMgY29tcHV0ZWQgYmFzZWQgb24gdGhlIGBuYW1lYCBwcm9wZXJ0eSBvZiB0aGUgcGFja2FnZSdzIG9yIHRoZSBlbnRyeS1wb2ludCdzXG4gKiAgIGBwYWNrYWdlLmpzb25gIGZpbGUgKGlmIGF2YWlsYWJsZSkgb3IgaW5mZXJyZWQgZnJvbSB0aGUgcGFja2FnZSdzIHBhdGguXG4gKiAtIFRoZSB2ZXJzaW9uIGlzIHJlYWQgb2ZmIG9mIHRoZSBgdmVyc2lvbmAgcHJvcGVydHkgb2YgdGhlIHBhY2thZ2UncyBgcGFja2FnZS5qc29uYCBmaWxlIChpZlxuICogICBhdmFpbGFibGUpLlxuICpcbiAqIEBwYXJhbSBmcyBUaGUgZmlsZS1zeXN0ZW0gdG8gdXNlIGZvciBwcm9jZXNzaW5nIGBwYWNrYWdlUGF0aGAuXG4gKiBAcGFyYW0gcGFja2FnZVBhdGggdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIHBhY2thZ2UuXG4gKiBAcGFyYW0gcGFja2FnZVBhY2thZ2VKc29uIHRoZSBwYXJzZWQgYHBhY2thZ2UuanNvbmAgb2YgdGhlIHBhY2thZ2UgKGlmIGF2YWlsYWJsZSkuXG4gKiBAcGFyYW0gZW50cnlQb2ludFBhY2thZ2VKc29uIHRoZSBwYXJzZWQgYHBhY2thZ2UuanNvbmAgb2YgYW4gZW50cnktcG9pbnQgKGlmIGF2YWlsYWJsZSkuXG4gKiBAcmV0dXJucyB0aGUgY29tcHV0ZWQgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgcGFja2FnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFja2FnZU5hbWVBbmRWZXJzaW9uKFxuICAgIGZzOiBQYXRoTWFuaXB1bGF0aW9uLCBwYWNrYWdlUGF0aDogQWJzb2x1dGVGc1BhdGgsXG4gICAgcGFja2FnZVBhY2thZ2VKc29uOiBFbnRyeVBvaW50UGFja2FnZUpzb258bnVsbCxcbiAgICBlbnRyeVBvaW50UGFja2FnZUpzb246IEVudHJ5UG9pbnRQYWNrYWdlSnNvbnxcbiAgICBudWxsKToge3BhY2thZ2VOYW1lOiBzdHJpbmcsIHBhY2thZ2VWZXJzaW9uOiBzdHJpbmd8bnVsbH0ge1xuICBsZXQgcGFja2FnZU5hbWU6IHN0cmluZztcblxuICBpZiAocGFja2FnZVBhY2thZ2VKc29uICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHZhbGlkIGBwYWNrYWdlLmpzb25gIGZvciB0aGUgcGFja2FnZTogR2V0IHRoZSBwYWNrYWdlIG5hbWUgZnJvbSB0aGF0LlxuICAgIHBhY2thZ2VOYW1lID0gcGFja2FnZVBhY2thZ2VKc29uLm5hbWU7XG4gIH0gZWxzZSBpZiAoZW50cnlQb2ludFBhY2thZ2VKc29uICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHZhbGlkIGBwYWNrYWdlLmpzb25gIGZvciB0aGUgZW50cnktcG9pbnQ6IEdldCB0aGUgcGFja2FnZSBuYW1lIGZyb20gdGhhdC5cbiAgICAvLyBUaGlzIG1pZ2h0IGJlIGEgc2Vjb25kYXJ5IGVudHJ5LXBvaW50LCBzbyBtYWtlIHN1cmUgd2Ugb25seSBrZWVwIHRoZSBtYWluIHBhY2thZ2UncyBuYW1lXG4gICAgLy8gKGUuZy4gb25seSBrZWVwIGBAYW5ndWxhci9jb21tb25gIGZyb20gYEBhbmd1bGFyL2NvbW1vbi9odHRwYCkuXG4gICAgcGFja2FnZU5hbWUgPSAvXig/OkBbXi9dK1xcLyk/W14vXSovLmV4ZWMoZW50cnlQb2ludFBhY2thZ2VKc29uLm5hbWUpIVswXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBkb24ndCBoYXZlIGEgdmFsaWQgYHBhY2thZ2UuanNvbmA6IEluZmVyIHRoZSBwYWNrYWdlIG5hbWUgZnJvbSB0aGUgcGFja2FnZSdzIHBhdGguXG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmcy5iYXNlbmFtZShwYWNrYWdlUGF0aCk7XG4gICAgY29uc3Qgc2Vjb25kTGFzdFNlZ21lbnQgPSBmcy5iYXNlbmFtZShmcy5kaXJuYW1lKHBhY2thZ2VQYXRoKSk7XG5cbiAgICBwYWNrYWdlTmFtZSA9XG4gICAgICAgIHNlY29uZExhc3RTZWdtZW50LnN0YXJ0c1dpdGgoJ0AnKSA/IGAke3NlY29uZExhc3RTZWdtZW50fS8ke2xhc3RTZWdtZW50fWAgOiBsYXN0U2VnbWVudDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFja2FnZU5hbWUsXG4gICAgcGFja2FnZVZlcnNpb246IHBhY2thZ2VQYWNrYWdlSnNvbj8udmVyc2lvbiA/PyBudWxsLFxuICB9O1xufVxuIl19