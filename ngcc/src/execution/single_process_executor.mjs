/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __awaiter } from "tslib";
export class SingleProcessorExecutorBase {
    constructor(logger, createTaskCompletedCallback) {
        this.logger = logger;
        this.createTaskCompletedCallback = createTaskCompletedCallback;
    }
    doExecute(analyzeEntryPoints, createCompileFn) {
        this.logger.debug(`Running ngcc on ${this.constructor.name}.`);
        const taskQueue = analyzeEntryPoints();
        const onTaskCompleted = this.createTaskCompletedCallback(taskQueue);
        const compile = createCompileFn(() => { }, onTaskCompleted);
        // Process all tasks.
        this.logger.debug('Processing tasks...');
        const startTime = Date.now();
        while (!taskQueue.allTasksCompleted) {
            const task = taskQueue.getNextTask();
            compile(task);
            taskQueue.markAsCompleted(task);
        }
        const duration = Math.round((Date.now() - startTime) / 1000);
        this.logger.debug(`Processed tasks in ${duration}s.`);
    }
}
/**
 * An `Executor` that processes all tasks serially and completes synchronously.
 */
export class SingleProcessExecutorSync extends SingleProcessorExecutorBase {
    constructor(logger, lockFile, createTaskCompletedCallback) {
        super(logger, createTaskCompletedCallback);
        this.lockFile = lockFile;
    }
    execute(analyzeEntryPoints, createCompileFn) {
        this.lockFile.lock(() => this.doExecute(analyzeEntryPoints, createCompileFn));
    }
}
/**
 * An `Executor` that processes all tasks serially, but still completes asynchronously.
 */
export class SingleProcessExecutorAsync extends SingleProcessorExecutorBase {
    constructor(logger, lockFile, createTaskCompletedCallback) {
        super(logger, createTaskCompletedCallback);
        this.lockFile = lockFile;
    }
    execute(analyzeEntryPoints, createCompileFn) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.lockFile.lock(() => __awaiter(this, void 0, void 0, function* () { return this.doExecute(analyzeEntryPoints, createCompileFn); }));
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xlX3Byb2Nlc3NfZXhlY3V0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvbmdjYy9zcmMvZXhlY3V0aW9uL3NpbmdsZV9wcm9jZXNzX2V4ZWN1dG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7QUFTSCxNQUFNLE9BQWdCLDJCQUEyQjtJQUMvQyxZQUNZLE1BQWMsRUFBVSwyQkFBd0Q7UUFBaEYsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUFVLGdDQUEyQixHQUEzQiwyQkFBMkIsQ0FBNkI7SUFBRyxDQUFDO0lBRWhHLFNBQVMsQ0FBQyxrQkFBd0MsRUFBRSxlQUFnQztRQUVsRixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBRS9ELE1BQU0sU0FBUyxHQUFHLGtCQUFrQixFQUFFLENBQUM7UUFDdkMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxHQUFHLEVBQUUsR0FBRSxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFM0QscUJBQXFCO1FBQ3JCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDekMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTdCLE9BQU8sQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEVBQUU7WUFDbkMsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLFdBQVcsRUFBRyxDQUFDO1lBQ3RDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNkLFNBQVMsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDakM7UUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHNCQUFzQixRQUFRLElBQUksQ0FBQyxDQUFDO0lBQ3hELENBQUM7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLHlCQUEwQixTQUFRLDJCQUEyQjtJQUN4RSxZQUNJLE1BQWMsRUFBVSxRQUFvQixFQUM1QywyQkFBd0Q7UUFDMUQsS0FBSyxDQUFDLE1BQU0sRUFBRSwyQkFBMkIsQ0FBQyxDQUFDO1FBRmpCLGFBQVEsR0FBUixRQUFRLENBQVk7SUFHaEQsQ0FBQztJQUNELE9BQU8sQ0FBQyxrQkFBd0MsRUFBRSxlQUFnQztRQUNoRixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUM7SUFDaEYsQ0FBQztDQUNGO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsMkJBQTJCO0lBQ3pFLFlBQ0ksTUFBYyxFQUFVLFFBQXFCLEVBQzdDLDJCQUF3RDtRQUMxRCxLQUFLLENBQUMsTUFBTSxFQUFFLDJCQUEyQixDQUFDLENBQUM7UUFGakIsYUFBUSxHQUFSLFFBQVEsQ0FBYTtJQUdqRCxDQUFDO0lBQ0ssT0FBTyxDQUFDLGtCQUF3QyxFQUFFLGVBQWdDOztZQUV0RixNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQVMsRUFBRSxnREFBQyxPQUFBLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsZUFBZSxDQUFDLENBQUEsR0FBQSxDQUFDLENBQUM7UUFDNUYsQ0FBQztLQUFBO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uLy4uL3NyYy9uZ3RzYy9sb2dnaW5nJztcbmltcG9ydCB7QXN5bmNMb2NrZXJ9IGZyb20gJy4uL2xvY2tpbmcvYXN5bmNfbG9ja2VyJztcbmltcG9ydCB7U3luY0xvY2tlcn0gZnJvbSAnLi4vbG9ja2luZy9zeW5jX2xvY2tlcic7XG5cbmltcG9ydCB7QW5hbHl6ZUVudHJ5UG9pbnRzRm4sIENyZWF0ZUNvbXBpbGVGbiwgRXhlY3V0b3J9IGZyb20gJy4vYXBpJztcbmltcG9ydCB7Q3JlYXRlVGFza0NvbXBsZXRlZENhbGxiYWNrfSBmcm9tICcuL3Rhc2tzL2FwaSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaW5nbGVQcm9jZXNzb3JFeGVjdXRvckJhc2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgbG9nZ2VyOiBMb2dnZXIsIHByaXZhdGUgY3JlYXRlVGFza0NvbXBsZXRlZENhbGxiYWNrOiBDcmVhdGVUYXNrQ29tcGxldGVkQ2FsbGJhY2spIHt9XG5cbiAgZG9FeGVjdXRlKGFuYWx5emVFbnRyeVBvaW50czogQW5hbHl6ZUVudHJ5UG9pbnRzRm4sIGNyZWF0ZUNvbXBpbGVGbjogQ3JlYXRlQ29tcGlsZUZuKTpcbiAgICAgIHZvaWR8UHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYFJ1bm5pbmcgbmdjYyBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX0uYCk7XG5cbiAgICBjb25zdCB0YXNrUXVldWUgPSBhbmFseXplRW50cnlQb2ludHMoKTtcbiAgICBjb25zdCBvblRhc2tDb21wbGV0ZWQgPSB0aGlzLmNyZWF0ZVRhc2tDb21wbGV0ZWRDYWxsYmFjayh0YXNrUXVldWUpO1xuICAgIGNvbnN0IGNvbXBpbGUgPSBjcmVhdGVDb21waWxlRm4oKCkgPT4ge30sIG9uVGFza0NvbXBsZXRlZCk7XG5cbiAgICAvLyBQcm9jZXNzIGFsbCB0YXNrcy5cbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnUHJvY2Vzc2luZyB0YXNrcy4uLicpO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICB3aGlsZSAoIXRhc2tRdWV1ZS5hbGxUYXNrc0NvbXBsZXRlZCkge1xuICAgICAgY29uc3QgdGFzayA9IHRhc2tRdWV1ZS5nZXROZXh0VGFzaygpITtcbiAgICAgIGNvbXBpbGUodGFzayk7XG4gICAgICB0YXNrUXVldWUubWFya0FzQ29tcGxldGVkKHRhc2spO1xuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwKTtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgUHJvY2Vzc2VkIHRhc2tzIGluICR7ZHVyYXRpb259cy5gKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGBFeGVjdXRvcmAgdGhhdCBwcm9jZXNzZXMgYWxsIHRhc2tzIHNlcmlhbGx5IGFuZCBjb21wbGV0ZXMgc3luY2hyb25vdXNseS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbmdsZVByb2Nlc3NFeGVjdXRvclN5bmMgZXh0ZW5kcyBTaW5nbGVQcm9jZXNzb3JFeGVjdXRvckJhc2UgaW1wbGVtZW50cyBFeGVjdXRvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgbG9nZ2VyOiBMb2dnZXIsIHByaXZhdGUgbG9ja0ZpbGU6IFN5bmNMb2NrZXIsXG4gICAgICBjcmVhdGVUYXNrQ29tcGxldGVkQ2FsbGJhY2s6IENyZWF0ZVRhc2tDb21wbGV0ZWRDYWxsYmFjaykge1xuICAgIHN1cGVyKGxvZ2dlciwgY3JlYXRlVGFza0NvbXBsZXRlZENhbGxiYWNrKTtcbiAgfVxuICBleGVjdXRlKGFuYWx5emVFbnRyeVBvaW50czogQW5hbHl6ZUVudHJ5UG9pbnRzRm4sIGNyZWF0ZUNvbXBpbGVGbjogQ3JlYXRlQ29tcGlsZUZuKTogdm9pZCB7XG4gICAgdGhpcy5sb2NrRmlsZS5sb2NrKCgpID0+IHRoaXMuZG9FeGVjdXRlKGFuYWx5emVFbnRyeVBvaW50cywgY3JlYXRlQ29tcGlsZUZuKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBgRXhlY3V0b3JgIHRoYXQgcHJvY2Vzc2VzIGFsbCB0YXNrcyBzZXJpYWxseSwgYnV0IHN0aWxsIGNvbXBsZXRlcyBhc3luY2hyb25vdXNseS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbmdsZVByb2Nlc3NFeGVjdXRvckFzeW5jIGV4dGVuZHMgU2luZ2xlUHJvY2Vzc29yRXhlY3V0b3JCYXNlIGltcGxlbWVudHMgRXhlY3V0b3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIGxvZ2dlcjogTG9nZ2VyLCBwcml2YXRlIGxvY2tGaWxlOiBBc3luY0xvY2tlcixcbiAgICAgIGNyZWF0ZVRhc2tDb21wbGV0ZWRDYWxsYmFjazogQ3JlYXRlVGFza0NvbXBsZXRlZENhbGxiYWNrKSB7XG4gICAgc3VwZXIobG9nZ2VyLCBjcmVhdGVUYXNrQ29tcGxldGVkQ2FsbGJhY2spO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGUoYW5hbHl6ZUVudHJ5UG9pbnRzOiBBbmFseXplRW50cnlQb2ludHNGbiwgY3JlYXRlQ29tcGlsZUZuOiBDcmVhdGVDb21waWxlRm4pOlxuICAgICAgUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5sb2NrRmlsZS5sb2NrKGFzeW5jICgpID0+IHRoaXMuZG9FeGVjdXRlKGFuYWx5emVFbnRyeVBvaW50cywgY3JlYXRlQ29tcGlsZUZuKSk7XG4gIH1cbn1cbiJdfQ==