/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/src/ngtsc/metadata/src/resolver", ["require", "exports", "tslib", "@angular/compiler", "path", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    /**
     * resolver.ts implements partial computation of expressions, resolving expressions to static
     * values where possible and returning a `DynamicValue` signal when not.
     */
    var compiler_1 = require("@angular/compiler");
    var path = require("path");
    var ts = require("typescript");
    var TS_DTS_EXTENSION = /(\.d)?\.ts$/;
    /**
     * Represents a value which cannot be determined statically.
     *
     * Use `isDynamicValue` to determine whether a `ResolvedValue` is a `DynamicValue`.
     */
    var DynamicValue = /** @class */ (function () {
        function DynamicValue() {
            /**
             * This is needed so the "is DynamicValue" assertion of `isDynamicValue` actually has meaning.
             *
             * Otherwise, "is DynamicValue" is akin to "is {}" which doesn't trigger narrowing.
             */
            this._isDynamic = true;
        }
        return DynamicValue;
    }());
    exports.DynamicValue = DynamicValue;
    /**
     * An internal flyweight for `DynamicValue`. Eventually the dynamic value will carry information
     * on the location of the node that could not be statically computed.
     */
    var DYNAMIC_VALUE = new DynamicValue();
    /**
     * Used to test whether a `ResolvedValue` is a `DynamicValue`.
     */
    function isDynamicValue(value) {
        return value === DYNAMIC_VALUE;
    }
    exports.isDynamicValue = isDynamicValue;
    /**
     * A reference to a `ts.Node`.
     *
     * For example, if an expression evaluates to a function or class definition, it will be returned
     * as a `Reference` (assuming references are allowed in evaluation).
     */
    var Reference = /** @class */ (function () {
        function Reference(node) {
            this.node = node;
        }
        return Reference;
    }());
    exports.Reference = Reference;
    /**
     * A reference to a node only, without any ability to get an `Expression` representing that node.
     *
     * This is used for returning references to things like method declarations, which are not directly
     * referenceable.
     */
    var NodeReference = /** @class */ (function (_super) {
        tslib_1.__extends(NodeReference, _super);
        function NodeReference(node, moduleName) {
            var _this = _super.call(this, node) || this;
            _this.moduleName = moduleName;
            return _this;
        }
        NodeReference.prototype.toExpression = function (context) { return null; };
        NodeReference.prototype.withIdentifier = function (identifier) { return this; };
        return NodeReference;
    }(Reference));
    exports.NodeReference = NodeReference;
    /**
     * A reference to a node which has a `ts.Identifier` and can be resolved to an `Expression`.
     *
     * Imports generated by `ResolvedReference`s are always relative.
     */
    var ResolvedReference = /** @class */ (function (_super) {
        tslib_1.__extends(ResolvedReference, _super);
        function ResolvedReference(node, identifier) {
            var _this = _super.call(this, node) || this;
            _this.identifier = identifier;
            _this.expressable = true;
            return _this;
        }
        ResolvedReference.prototype.toExpression = function (context) {
            if (ts.getOriginalNode(context) === ts.getOriginalNode(this.identifier).getSourceFile()) {
                return new compiler_1.WrappedNodeExpr(this.identifier);
            }
            else {
                // Relative import from context -> this.node.getSourceFile().
                // TODO(alxhub): investigate the impact of multiple source roots here.
                // TODO(alxhub): investigate the need to map such paths via the Host for proper g3 support.
                var relative = path.posix.relative(path.dirname(context.fileName), this.node.getSourceFile().fileName)
                    .replace(TS_DTS_EXTENSION, '');
                // path.relative() does not include the leading './'.
                if (!relative.startsWith('.')) {
                    relative = "./" + relative;
                }
                // path.relative() returns the empty string (converted to './' above) if the two paths are the
                // same.
                if (relative === './') {
                    // Same file after all.
                    return new compiler_1.WrappedNodeExpr(this.identifier);
                }
                else {
                    return new compiler_1.ExternalExpr(new compiler_1.ExternalReference(relative, this.identifier.text));
                }
            }
        };
        ResolvedReference.prototype.withIdentifier = function (identifier) {
            return new ResolvedReference(this.node, identifier);
        };
        return ResolvedReference;
    }(Reference));
    exports.ResolvedReference = ResolvedReference;
    /**
     * A reference to a node which has a `ts.Identifer` and an expected absolute module name.
     *
     * An `AbsoluteReference` can be resolved to an `Expression`, and if that expression is an import
     * the module specifier will be an absolute module name, not a relative path.
     */
    var AbsoluteReference = /** @class */ (function (_super) {
        tslib_1.__extends(AbsoluteReference, _super);
        function AbsoluteReference(node, identifier, moduleName, symbolName) {
            var _this = _super.call(this, node) || this;
            _this.identifier = identifier;
            _this.moduleName = moduleName;
            _this.symbolName = symbolName;
            _this.expressable = true;
            return _this;
        }
        AbsoluteReference.prototype.toExpression = function (context) {
            if (ts.getOriginalNode(context) === ts.getOriginalNode(this.identifier).getSourceFile()) {
                return new compiler_1.WrappedNodeExpr(this.identifier);
            }
            else {
                return new compiler_1.ExternalExpr(new compiler_1.ExternalReference(this.moduleName, this.symbolName));
            }
        };
        AbsoluteReference.prototype.withIdentifier = function (identifier) {
            return new AbsoluteReference(this.node, identifier, this.moduleName, this.symbolName);
        };
        return AbsoluteReference;
    }(Reference));
    exports.AbsoluteReference = AbsoluteReference;
    /**
     * Statically resolve the given `ts.Expression` into a `ResolvedValue`.
     *
     * @param node the expression to statically resolve if possible
     * @param checker a `ts.TypeChecker` used to understand the expression
     * @param foreignFunctionResolver a function which will be used whenever a "foreign function" is
     * encountered. A foreign function is a function which has no body - usually the result of calling
     * a function declared in another library's .d.ts file. In these cases, the foreignFunctionResolver
     * will be called with the function's declaration, and can optionally return a `ts.Expression`
     * (possibly extracted from the foreign function's type signature) which will be used as the result
     * of the call.
     * @returns a `ResolvedValue` representing the resolved value
     */
    function staticallyResolve(node, host, checker, foreignFunctionResolver) {
        return new StaticInterpreter(host, checker).visit(node, {
            absoluteModuleName: null,
            scope: new Map(), foreignFunctionResolver: foreignFunctionResolver,
        });
    }
    exports.staticallyResolve = staticallyResolve;
    function literalBinaryOp(op) {
        return { op: op, literal: true };
    }
    function referenceBinaryOp(op) {
        return { op: op, literal: false };
    }
    var BINARY_OPERATORS = new Map([
        [ts.SyntaxKind.PlusToken, literalBinaryOp(function (a, b) { return a + b; })],
        [ts.SyntaxKind.MinusToken, literalBinaryOp(function (a, b) { return a - b; })],
        [ts.SyntaxKind.AsteriskToken, literalBinaryOp(function (a, b) { return a * b; })],
        [ts.SyntaxKind.SlashToken, literalBinaryOp(function (a, b) { return a / b; })],
        [ts.SyntaxKind.PercentToken, literalBinaryOp(function (a, b) { return a % b; })],
        [ts.SyntaxKind.AmpersandToken, literalBinaryOp(function (a, b) { return a & b; })],
        [ts.SyntaxKind.BarToken, literalBinaryOp(function (a, b) { return a | b; })],
        [ts.SyntaxKind.CaretToken, literalBinaryOp(function (a, b) { return a ^ b; })],
        [ts.SyntaxKind.LessThanToken, literalBinaryOp(function (a, b) { return a < b; })],
        [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp(function (a, b) { return a <= b; })],
        [ts.SyntaxKind.GreaterThanToken, literalBinaryOp(function (a, b) { return a > b; })],
        [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp(function (a, b) { return a >= b; })],
        [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp(function (a, b) { return a << b; })],
        [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp(function (a, b) { return a >> b; })],
        [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp(function (a, b) { return a >>> b; })],
        [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp(function (a, b) { return Math.pow(a, b); })],
        [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp(function (a, b) { return a && b; })],
        [ts.SyntaxKind.BarBarToken, referenceBinaryOp(function (a, b) { return a || b; })]
    ]);
    var UNARY_OPERATORS = new Map([
        [ts.SyntaxKind.TildeToken, function (a) { return ~a; }], [ts.SyntaxKind.MinusToken, function (a) { return -a; }],
        [ts.SyntaxKind.PlusToken, function (a) { return +a; }], [ts.SyntaxKind.ExclamationToken, function (a) { return !a; }]
    ]);
    var StaticInterpreter = /** @class */ (function () {
        function StaticInterpreter(host, checker) {
            this.host = host;
            this.checker = checker;
        }
        StaticInterpreter.prototype.visit = function (node, context) {
            return this.visitExpression(node, context);
        };
        StaticInterpreter.prototype.visitExpression = function (node, context) {
            if (node.kind === ts.SyntaxKind.TrueKeyword) {
                return true;
            }
            else if (node.kind === ts.SyntaxKind.FalseKeyword) {
                return false;
            }
            else if (ts.isStringLiteral(node)) {
                return node.text;
            }
            else if (ts.isNoSubstitutionTemplateLiteral(node)) {
                return node.text;
            }
            else if (ts.isTemplateExpression(node)) {
                return this.visitTemplateExpression(node, context);
            }
            else if (ts.isNumericLiteral(node)) {
                return parseFloat(node.text);
            }
            else if (ts.isObjectLiteralExpression(node)) {
                return this.visitObjectLiteralExpression(node, context);
            }
            else if (ts.isIdentifier(node)) {
                return this.visitIdentifier(node, context);
            }
            else if (ts.isPropertyAccessExpression(node)) {
                return this.visitPropertyAccessExpression(node, context);
            }
            else if (ts.isCallExpression(node)) {
                return this.visitCallExpression(node, context);
            }
            else if (ts.isConditionalExpression(node)) {
                return this.visitConditionalExpression(node, context);
            }
            else if (ts.isPrefixUnaryExpression(node)) {
                return this.visitPrefixUnaryExpression(node, context);
            }
            else if (ts.isBinaryExpression(node)) {
                return this.visitBinaryExpression(node, context);
            }
            else if (ts.isArrayLiteralExpression(node)) {
                return this.visitArrayLiteralExpression(node, context);
            }
            else if (ts.isParenthesizedExpression(node)) {
                return this.visitParenthesizedExpression(node, context);
            }
            else if (ts.isElementAccessExpression(node)) {
                return this.visitElementAccessExpression(node, context);
            }
            else if (ts.isAsExpression(node)) {
                return this.visitExpression(node.expression, context);
            }
            else if (ts.isNonNullExpression(node)) {
                return this.visitExpression(node.expression, context);
            }
            else if (isPossibleClassDeclaration(node) && this.host.isClass(node)) {
                return this.visitDeclaration(node, context);
            }
            else {
                return DYNAMIC_VALUE;
            }
        };
        StaticInterpreter.prototype.visitArrayLiteralExpression = function (node, context) {
            var array = [];
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                if (ts.isSpreadElement(element)) {
                    var spread = this.visitExpression(element.expression, context);
                    if (isDynamicValue(spread)) {
                        return DYNAMIC_VALUE;
                    }
                    if (!Array.isArray(spread)) {
                        throw new Error("Unexpected value in spread expression: " + spread);
                    }
                    array.push.apply(array, tslib_1.__spread(spread));
                }
                else {
                    var result = this.visitExpression(element, context);
                    if (isDynamicValue(result)) {
                        return DYNAMIC_VALUE;
                    }
                    array.push(result);
                }
            }
            return array;
        };
        StaticInterpreter.prototype.visitObjectLiteralExpression = function (node, context) {
            var map = new Map();
            for (var i = 0; i < node.properties.length; i++) {
                var property = node.properties[i];
                if (ts.isPropertyAssignment(property)) {
                    var name_1 = this.stringNameFromPropertyName(property.name, context);
                    // Check whether the name can be determined statically.
                    if (name_1 === undefined) {
                        return DYNAMIC_VALUE;
                    }
                    map.set(name_1, this.visitExpression(property.initializer, context));
                }
                else if (ts.isShorthandPropertyAssignment(property)) {
                    var symbol = this.checker.getShorthandAssignmentValueSymbol(property);
                    if (symbol === undefined || symbol.valueDeclaration === undefined) {
                        return DYNAMIC_VALUE;
                    }
                    map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));
                }
                else if (ts.isSpreadAssignment(property)) {
                    var spread = this.visitExpression(property.expression, context);
                    if (isDynamicValue(spread)) {
                        return DYNAMIC_VALUE;
                    }
                    if (!(spread instanceof Map)) {
                        throw new Error("Unexpected value in spread assignment: " + spread);
                    }
                    spread.forEach(function (value, key) { return map.set(key, value); });
                }
                else {
                    return DYNAMIC_VALUE;
                }
            }
            return map;
        };
        StaticInterpreter.prototype.visitTemplateExpression = function (node, context) {
            var pieces = [node.head.text];
            for (var i = 0; i < node.templateSpans.length; i++) {
                var span = node.templateSpans[i];
                var value = this.visit(span.expression, context);
                if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' ||
                    value == null) {
                    pieces.push("" + value);
                }
                else {
                    return DYNAMIC_VALUE;
                }
                pieces.push(span.literal.text);
            }
            return pieces.join('');
        };
        StaticInterpreter.prototype.visitIdentifier = function (node, context) {
            var decl = this.host.getDeclarationOfIdentifier(node);
            if (decl === null) {
                return DYNAMIC_VALUE;
            }
            var result = this.visitDeclaration(decl.node, tslib_1.__assign({}, context, { absoluteModuleName: decl.viaModule || context.absoluteModuleName }));
            if (result instanceof Reference) {
                return result.withIdentifier(node);
            }
            else {
                return result;
            }
        };
        StaticInterpreter.prototype.visitDeclaration = function (node, context) {
            if (this.host.isClass(node)) {
                return this.getReference(node, context);
            }
            else if (ts.isVariableDeclaration(node)) {
                if (!node.initializer) {
                    return undefined;
                }
                return this.visitExpression(node.initializer, context);
            }
            else if (ts.isParameter(node) && context.scope.has(node)) {
                return context.scope.get(node);
            }
            else if (ts.isExportAssignment(node)) {
                return this.visitExpression(node.expression, context);
            }
            else if (ts.isSourceFile(node)) {
                return this.visitSourceFile(node, context);
            }
            else {
                return this.getReference(node, context);
            }
        };
        StaticInterpreter.prototype.visitElementAccessExpression = function (node, context) {
            var lhs = this.visitExpression(node.expression, context);
            if (node.argumentExpression === undefined) {
                throw new Error("Expected argument in ElementAccessExpression");
            }
            if (isDynamicValue(lhs)) {
                return DYNAMIC_VALUE;
            }
            var rhs = this.visitExpression(node.argumentExpression, context);
            if (isDynamicValue(rhs)) {
                return DYNAMIC_VALUE;
            }
            if (typeof rhs !== 'string' && typeof rhs !== 'number') {
                throw new Error("ElementAccessExpression index should be string or number, got " + typeof rhs + ": " + rhs);
            }
            return this.accessHelper(lhs, rhs, context);
        };
        StaticInterpreter.prototype.visitPropertyAccessExpression = function (node, context) {
            var lhs = this.visitExpression(node.expression, context);
            var rhs = node.name.text;
            // TODO: handle reference to class declaration.
            if (isDynamicValue(lhs)) {
                return DYNAMIC_VALUE;
            }
            return this.accessHelper(lhs, rhs, context);
        };
        StaticInterpreter.prototype.visitSourceFile = function (node, context) {
            var _this = this;
            var declarations = this.host.getExportsOfModule(node);
            if (declarations === null) {
                return DYNAMIC_VALUE;
            }
            var map = new Map();
            declarations.forEach(function (decl, name) {
                var value = _this.visitDeclaration(decl.node, tslib_1.__assign({}, context, { absoluteModuleName: decl.viaModule || context.absoluteModuleName }));
                map.set(name, value);
            });
            return map;
        };
        StaticInterpreter.prototype.accessHelper = function (lhs, rhs, context) {
            var strIndex = "" + rhs;
            if (lhs instanceof Map) {
                if (lhs.has(strIndex)) {
                    return lhs.get(strIndex);
                }
                else {
                    throw new Error("Invalid map access: [" + Array.from(lhs.keys()) + "] dot " + rhs);
                }
            }
            else if (Array.isArray(lhs)) {
                if (rhs === 'length') {
                    return lhs.length;
                }
                if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {
                    return DYNAMIC_VALUE;
                }
                if (rhs < 0 || rhs >= lhs.length) {
                    throw new Error("Index out of bounds: " + rhs + " vs " + lhs.length);
                }
                return lhs[rhs];
            }
            else if (lhs instanceof Reference) {
                var ref = lhs.node;
                if (isPossibleClassDeclaration(ref) && this.host.isClass(ref)) {
                    var absoluteModuleName = context.absoluteModuleName;
                    if (lhs instanceof NodeReference || lhs instanceof AbsoluteReference) {
                        absoluteModuleName = lhs.moduleName || absoluteModuleName;
                    }
                    var value = undefined;
                    var member = this.host.getMembersOfClass(ref).find(function (member) { return member.isStatic && member.name === strIndex; });
                    if (member !== undefined) {
                        if (member.value !== null) {
                            value = this.visitExpression(member.value, context);
                        }
                        else if (member.implementation !== null) {
                            value = new NodeReference(member.implementation, absoluteModuleName);
                        }
                        else if (member.node) {
                            value = new NodeReference(member.node, absoluteModuleName);
                        }
                    }
                    return value;
                }
            }
            throw new Error("Invalid dot property access: " + lhs + " dot " + rhs);
        };
        StaticInterpreter.prototype.visitCallExpression = function (node, context) {
            var _this = this;
            var lhs = this.visitExpression(node.expression, context);
            if (!(lhs instanceof Reference)) {
                throw new Error("attempting to call something that is not a function: " + lhs);
            }
            else if (!isFunctionOrMethodDeclaration(lhs.node)) {
                throw new Error("calling something that is not a function declaration? " + ts.SyntaxKind[lhs.node.kind] + " (" + node.getText() + ")");
            }
            var fn = lhs.node;
            // If the function is foreign (declared through a d.ts file), attempt to resolve it with the
            // foreignFunctionResolver, if one is specified.
            if (fn.body === undefined) {
                var expr = null;
                if (context.foreignFunctionResolver) {
                    expr = context.foreignFunctionResolver(fn);
                }
                if (expr === null) {
                    throw new Error("could not resolve foreign function declaration");
                }
                // If the function is declared in a different file, resolve the foreign function expression
                // using the absolute module name of that file (if any).
                var absoluteModuleName = context.absoluteModuleName;
                if (lhs instanceof NodeReference || lhs instanceof AbsoluteReference) {
                    absoluteModuleName = lhs.moduleName || absoluteModuleName;
                }
                return this.visitExpression(expr, tslib_1.__assign({}, context, { absoluteModuleName: absoluteModuleName }));
            }
            var body = fn.body;
            if (body.statements.length !== 1 || !ts.isReturnStatement(body.statements[0])) {
                throw new Error('Function body must have a single return statement only.');
            }
            var ret = body.statements[0];
            var newScope = new Map();
            fn.parameters.forEach(function (param, index) {
                var value = undefined;
                if (index < node.arguments.length) {
                    var arg = node.arguments[index];
                    value = _this.visitExpression(arg, context);
                }
                if (value === undefined && param.initializer !== undefined) {
                    value = _this.visitExpression(param.initializer, context);
                }
                newScope.set(param, value);
            });
            return ret.expression !== undefined ?
                this.visitExpression(ret.expression, tslib_1.__assign({}, context, { scope: newScope })) :
                undefined;
        };
        StaticInterpreter.prototype.visitConditionalExpression = function (node, context) {
            var condition = this.visitExpression(node.condition, context);
            if (isDynamicValue(condition)) {
                return condition;
            }
            if (condition) {
                return this.visitExpression(node.whenTrue, context);
            }
            else {
                return this.visitExpression(node.whenFalse, context);
            }
        };
        StaticInterpreter.prototype.visitPrefixUnaryExpression = function (node, context) {
            var operatorKind = node.operator;
            if (!UNARY_OPERATORS.has(operatorKind)) {
                throw new Error("Unsupported prefix unary operator: " + ts.SyntaxKind[operatorKind]);
            }
            var op = UNARY_OPERATORS.get(operatorKind);
            var value = this.visitExpression(node.operand, context);
            return isDynamicValue(value) ? DYNAMIC_VALUE : op(value);
        };
        StaticInterpreter.prototype.visitBinaryExpression = function (node, context) {
            var tokenKind = node.operatorToken.kind;
            if (!BINARY_OPERATORS.has(tokenKind)) {
                throw new Error("Unsupported binary operator: " + ts.SyntaxKind[tokenKind]);
            }
            var opRecord = BINARY_OPERATORS.get(tokenKind);
            var lhs, rhs;
            if (opRecord.literal) {
                lhs = literal(this.visitExpression(node.left, context));
                rhs = literal(this.visitExpression(node.right, context));
            }
            else {
                lhs = this.visitExpression(node.left, context);
                rhs = this.visitExpression(node.right, context);
            }
            return isDynamicValue(lhs) || isDynamicValue(rhs) ? DYNAMIC_VALUE : opRecord.op(lhs, rhs);
        };
        StaticInterpreter.prototype.visitParenthesizedExpression = function (node, context) {
            return this.visitExpression(node.expression, context);
        };
        StaticInterpreter.prototype.stringNameFromPropertyName = function (node, context) {
            if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {
                return node.text;
            }
            else { // ts.ComputedPropertyName
                var literal_1 = this.visitExpression(node.expression, context);
                return typeof literal_1 === 'string' ? literal_1 : undefined;
            }
        };
        StaticInterpreter.prototype.getReference = function (node, context) {
            var id = identifierOfDeclaration(node);
            if (id === undefined) {
                throw new Error("Don't know how to refer to " + ts.SyntaxKind[node.kind]);
            }
            if (context.absoluteModuleName !== null) {
                // TODO(alxhub): investigate whether this can get symbol names wrong in the event of
                // re-exports under different names.
                return new AbsoluteReference(node, id, context.absoluteModuleName, id.text);
            }
            else {
                return new ResolvedReference(node, id);
            }
        };
        return StaticInterpreter;
    }());
    function isFunctionOrMethodDeclaration(node) {
        return ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) ||
            ts.isFunctionExpression(node);
    }
    function literal(value) {
        if (value === null || value === undefined || typeof value === 'string' ||
            typeof value === 'number' || typeof value === 'boolean') {
            return value;
        }
        if (isDynamicValue(value)) {
            return DYNAMIC_VALUE;
        }
        throw new Error("Value " + value + " is not literal and cannot be used in this context.");
    }
    function identifierOfDeclaration(decl) {
        if (ts.isClassDeclaration(decl)) {
            return decl.name;
        }
        else if (ts.isFunctionDeclaration(decl)) {
            return decl.name;
        }
        else if (ts.isVariableDeclaration(decl) && ts.isIdentifier(decl.name)) {
            return decl.name;
        }
        else if (ts.isShorthandPropertyAssignment(decl)) {
            return decl.name;
        }
        else {
            return undefined;
        }
    }
    function isPossibleClassDeclaration(node) {
        return ts.isClassDeclaration(node) || ts.isVariableDeclaration(node);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvc3JjL25ndHNjL21ldGFkYXRhL3NyYy9yZXNvbHZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7SUFFSDs7O09BR0c7SUFFSCw4Q0FBK0Y7SUFDL0YsMkJBQTZCO0lBQzdCLCtCQUFpQztJQUlqQyxJQUFNLGdCQUFnQixHQUFHLGFBQWEsQ0FBQztJQUV2Qzs7OztPQUlHO0lBQ0g7UUFBQTtZQUNFOzs7O2VBSUc7WUFDSyxlQUFVLEdBQUcsSUFBSSxDQUFDO1FBQzVCLENBQUM7UUFBRCxtQkFBQztJQUFELENBQUMsQUFQRCxJQU9DO0lBUFksb0NBQVk7SUFTekI7OztPQUdHO0lBQ0gsSUFBTSxhQUFhLEdBQWlCLElBQUksWUFBWSxFQUFFLENBQUM7SUFFdkQ7O09BRUc7SUFDSCx3QkFBK0IsS0FBVTtRQUN2QyxPQUFPLEtBQUssS0FBSyxhQUFhLENBQUM7SUFDakMsQ0FBQztJQUZELHdDQUVDO0lBa0NEOzs7OztPQUtHO0lBQ0g7UUFDRSxtQkFBcUIsSUFBYTtZQUFiLFNBQUksR0FBSixJQUFJLENBQVM7UUFBRyxDQUFDO1FBaUJ4QyxnQkFBQztJQUFELENBQUMsQUFsQkQsSUFrQkM7SUFsQnFCLDhCQUFTO0lBb0IvQjs7Ozs7T0FLRztJQUNIO1FBQW1DLHlDQUFTO1FBQzFDLHVCQUFZLElBQWEsRUFBVyxVQUF1QjtZQUEzRCxZQUErRCxrQkFBTSxJQUFJLENBQUMsU0FBRztZQUF6QyxnQkFBVSxHQUFWLFVBQVUsQ0FBYTs7UUFBaUIsQ0FBQztRQUU3RSxvQ0FBWSxHQUFaLFVBQWEsT0FBc0IsSUFBVSxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFM0Qsc0NBQWMsR0FBZCxVQUFlLFVBQXlCLElBQW1CLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FB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SUFBSSxDQUFDO1NBQ2xCO2FBQU0sSUFBSSxFQUFFLENBQUMsNkJBQTZCLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDakQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ2xCO2FBQU07WUFDTCxPQUFPLFNBQVMsQ0FBQztTQUNsQjtJQUNILENBQUM7SUFFRCxvQ0FBb0MsSUFBYTtRQUMvQyxPQUFPLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiByZXNvbHZlci50cyBpbXBsZW1lbnRzIHBhcnRpYWwgY29tcHV0YXRpb24gb2YgZXhwcmVzc2lvbnMsIHJlc29sdmluZyBleHByZXNzaW9ucyB0byBzdGF0aWNcbiAqIHZhbHVlcyB3aGVyZSBwb3NzaWJsZSBhbmQgcmV0dXJuaW5nIGEgYER5bmFtaWNWYWx1ZWAgc2lnbmFsIHdoZW4gbm90LlxuICovXG5cbmltcG9ydCB7RXhwcmVzc2lvbiwgRXh0ZXJuYWxFeHByLCBFeHRlcm5hbFJlZmVyZW5jZSwgV3JhcHBlZE5vZGVFeHByfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7Q2xhc3NNZW1iZXJLaW5kLCBSZWZsZWN0aW9uSG9zdH0gZnJvbSAnLi4vLi4vaG9zdCc7XG5cbmNvbnN0IFRTX0RUU19FWFRFTlNJT04gPSAvKFxcLmQpP1xcLnRzJC87XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHZhbHVlIHdoaWNoIGNhbm5vdCBiZSBkZXRlcm1pbmVkIHN0YXRpY2FsbHkuXG4gKlxuICogVXNlIGBpc0R5bmFtaWNWYWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBgUmVzb2x2ZWRWYWx1ZWAgaXMgYSBgRHluYW1pY1ZhbHVlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNWYWx1ZSB7XG4gIC8qKlxuICAgKiBUaGlzIGlzIG5lZWRlZCBzbyB0aGUgXCJpcyBEeW5hbWljVmFsdWVcIiBhc3NlcnRpb24gb2YgYGlzRHluYW1pY1ZhbHVlYCBhY3R1YWxseSBoYXMgbWVhbmluZy5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBcImlzIER5bmFtaWNWYWx1ZVwiIGlzIGFraW4gdG8gXCJpcyB7fVwiIHdoaWNoIGRvZXNuJ3QgdHJpZ2dlciBuYXJyb3dpbmcuXG4gICAqL1xuICBwcml2YXRlIF9pc0R5bmFtaWMgPSB0cnVlO1xufVxuXG4vKipcbiAqIEFuIGludGVybmFsIGZseXdlaWdodCBmb3IgYER5bmFtaWNWYWx1ZWAuIEV2ZW50dWFsbHkgdGhlIGR5bmFtaWMgdmFsdWUgd2lsbCBjYXJyeSBpbmZvcm1hdGlvblxuICogb24gdGhlIGxvY2F0aW9uIG9mIHRoZSBub2RlIHRoYXQgY291bGQgbm90IGJlIHN0YXRpY2FsbHkgY29tcHV0ZWQuXG4gKi9cbmNvbnN0IERZTkFNSUNfVkFMVUU6IER5bmFtaWNWYWx1ZSA9IG5ldyBEeW5hbWljVmFsdWUoKTtcblxuLyoqXG4gKiBVc2VkIHRvIHRlc3Qgd2hldGhlciBhIGBSZXNvbHZlZFZhbHVlYCBpcyBhIGBEeW5hbWljVmFsdWVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljVmFsdWUodmFsdWU6IGFueSk6IHZhbHVlIGlzIER5bmFtaWNWYWx1ZSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gRFlOQU1JQ19WQUxVRTtcbn1cblxuLyoqXG4gKiBBIHZhbHVlIHJlc3VsdGluZyBmcm9tIHN0YXRpYyByZXNvbHV0aW9uLlxuICpcbiAqIFRoaXMgY291bGQgYmUgYSBwcmltaXRpdmUsIGNvbGxlY3Rpb24gdHlwZSwgcmVmZXJlbmNlIHRvIGEgYHRzLk5vZGVgIHRoYXQgZGVjbGFyZXMgYVxuICogbm9uLXByaW1pdGl2ZSB2YWx1ZSwgb3IgYSBzcGVjaWFsIGBEeW5hbWljVmFsdWVgIHR5cGUgd2hpY2ggaW5kaWNhdGVzIHRoZSB2YWx1ZSB3YXMgbm90XG4gKiBhdmFpbGFibGUgc3RhdGljYWxseS5cbiAqL1xuZXhwb3J0IHR5cGUgUmVzb2x2ZWRWYWx1ZSA9IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkIHwgUmVmZXJlbmNlIHxcbiAgICBSZXNvbHZlZFZhbHVlQXJyYXkgfCBSZXNvbHZlZFZhbHVlTWFwIHwgRHluYW1pY1ZhbHVlO1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIGBSZXNvbHZlZFZhbHVlYHMuXG4gKlxuICogVGhpcyBpcyBhIHJlaWZpZWQgdHlwZSB0byBhbGxvdyB0aGUgY2lyY3VsYXIgcmVmZXJlbmNlIG9mIGBSZXNvbHZlZFZhbHVlYCAtPiBgUmVzb2x2ZWRWYWx1ZUFycmF5YFxuICogLT5cbiAqIGBSZXNvbHZlZFZhbHVlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFZhbHVlQXJyYXkgZXh0ZW5kcyBBcnJheTxSZXNvbHZlZFZhbHVlPiB7fVxuXG4vKipcbiAqIEEgbWFwIG9mIHN0cmluZ3MgdG8gYFJlc29sdmVkVmFsdWVgcy5cbiAqXG4gKiBUaGlzIGlzIGEgcmVpZmllZCB0eXBlIHRvIGFsbG93IHRoZSBjaXJjdWxhciByZWZlcmVuY2Ugb2YgYFJlc29sdmVkVmFsdWVgIC0+IGBSZXNvbHZlZFZhbHVlTWFwYCAtPlxuICogYFJlc29sdmVkVmFsdWVgLlxuICovIGV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRWYWx1ZU1hcCBleHRlbmRzIE1hcDxzdHJpbmcsIFJlc29sdmVkVmFsdWU+IHt9XG5cbi8qKlxuICogVHJhY2tzIHRoZSBzY29wZSBvZiBhIGZ1bmN0aW9uIGJvZHksIHdoaWNoIGluY2x1ZGVzIGBSZXNvbHZlZFZhbHVlYHMgZm9yIHRoZSBwYXJhbWV0ZXJzIG9mIHRoYXRcbiAqIGJvZHkuXG4gKi9cbnR5cGUgU2NvcGUgPSBNYXA8dHMuUGFyYW1ldGVyRGVjbGFyYXRpb24sIFJlc29sdmVkVmFsdWU+O1xuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgYHRzLk5vZGVgLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBhbiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIGZ1bmN0aW9uIG9yIGNsYXNzIGRlZmluaXRpb24sIGl0IHdpbGwgYmUgcmV0dXJuZWRcbiAqIGFzIGEgYFJlZmVyZW5jZWAgKGFzc3VtaW5nIHJlZmVyZW5jZXMgYXJlIGFsbG93ZWQgaW4gZXZhbHVhdGlvbikuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWZlcmVuY2Uge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBub2RlOiB0cy5Ob2RlKSB7fVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGFuIGBFeHByZXNzaW9uYCBjYW4gYmUgZ2VuZXJhdGVkIHdoaWNoIHJlZmVyZW5jZXMgdGhlIG5vZGUuXG4gICAqL1xuICAvLyBUT0RPKGlzc3VlLzI0NTcxKTogcmVtb3ZlICchJy5cbiAgcmVhZG9ubHkgZXhwcmVzc2FibGUgITogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gYEV4cHJlc3Npb25gIHJlcHJlc2VudGluZyB0aGlzIHR5cGUsIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnaXZlbiBTb3VyY2VGaWxlLlxuICAgKlxuICAgKiBUaGlzIGNvdWxkIGJlIGEgbG9jYWwgdmFyaWFibGUgcmVmZXJlbmNlLCBpZiB0aGUgc3ltYm9sIGlzIGltcG9ydGVkLCBvciBpdCBjb3VsZCBiZSBhIG5ld1xuICAgKiBpbXBvcnQgaWYgbmVlZGVkLlxuICAgKi9cbiAgYWJzdHJhY3QgdG9FeHByZXNzaW9uKGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUpOiBFeHByZXNzaW9ufG51bGw7XG5cbiAgYWJzdHJhY3Qgd2l0aElkZW50aWZpZXIoaWRlbnRpZmllcjogdHMuSWRlbnRpZmllcik6IFJlZmVyZW5jZTtcbn1cblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIG5vZGUgb25seSwgd2l0aG91dCBhbnkgYWJpbGl0eSB0byBnZXQgYW4gYEV4cHJlc3Npb25gIHJlcHJlc2VudGluZyB0aGF0IG5vZGUuXG4gKlxuICogVGhpcyBpcyB1c2VkIGZvciByZXR1cm5pbmcgcmVmZXJlbmNlcyB0byB0aGluZ3MgbGlrZSBtZXRob2QgZGVjbGFyYXRpb25zLCB3aGljaCBhcmUgbm90IGRpcmVjdGx5XG4gKiByZWZlcmVuY2VhYmxlLlxuICovXG5leHBvcnQgY2xhc3MgTm9kZVJlZmVyZW5jZSBleHRlbmRzIFJlZmVyZW5jZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGU6IHRzLk5vZGUsIHJlYWRvbmx5IG1vZHVsZU5hbWU6IHN0cmluZ3xudWxsKSB7IHN1cGVyKG5vZGUpOyB9XG5cbiAgdG9FeHByZXNzaW9uKGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUpOiBudWxsIHsgcmV0dXJuIG51bGw7IH1cblxuICB3aXRoSWRlbnRpZmllcihpZGVudGlmaWVyOiB0cy5JZGVudGlmaWVyKTogTm9kZVJlZmVyZW5jZSB7IHJldHVybiB0aGlzOyB9XG59XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYSBub2RlIHdoaWNoIGhhcyBhIGB0cy5JZGVudGlmaWVyYCBhbmQgY2FuIGJlIHJlc29sdmVkIHRvIGFuIGBFeHByZXNzaW9uYC5cbiAqXG4gKiBJbXBvcnRzIGdlbmVyYXRlZCBieSBgUmVzb2x2ZWRSZWZlcmVuY2VgcyBhcmUgYWx3YXlzIHJlbGF0aXZlLlxuICovXG5leHBvcnQgY2xhc3MgUmVzb2x2ZWRSZWZlcmVuY2UgZXh0ZW5kcyBSZWZlcmVuY2Uge1xuICBjb25zdHJ1Y3Rvcihub2RlOiB0cy5Ob2RlLCBwcm90ZWN0ZWQgaWRlbnRpZmllcjogdHMuSWRlbnRpZmllcikgeyBzdXBlcihub2RlKTsgfVxuXG4gIHJlYWRvbmx5IGV4cHJlc3NhYmxlID0gdHJ1ZTtcblxuICB0b0V4cHJlc3Npb24oY29udGV4dDogdHMuU291cmNlRmlsZSk6IEV4cHJlc3Npb24ge1xuICAgIGlmICh0cy5nZXRPcmlnaW5hbE5vZGUoY29udGV4dCkgPT09IHRzLmdldE9yaWdpbmFsTm9kZSh0aGlzLmlkZW50aWZpZXIpLmdldFNvdXJjZUZpbGUoKSkge1xuICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIodGhpcy5pZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVsYXRpdmUgaW1wb3J0IGZyb20gY29udGV4dCAtPiB0aGlzLm5vZGUuZ2V0U291cmNlRmlsZSgpLlxuICAgICAgLy8gVE9ETyhhbHhodWIpOiBpbnZlc3RpZ2F0ZSB0aGUgaW1wYWN0IG9mIG11bHRpcGxlIHNvdXJjZSByb290cyBoZXJlLlxuICAgICAgLy8gVE9ETyhhbHhodWIpOiBpbnZlc3RpZ2F0ZSB0aGUgbmVlZCB0byBtYXAgc3VjaCBwYXRocyB2aWEgdGhlIEhvc3QgZm9yIHByb3BlciBnMyBzdXBwb3J0LlxuICAgICAgbGV0IHJlbGF0aXZlID1cbiAgICAgICAgICBwYXRoLnBvc2l4LnJlbGF0aXZlKHBhdGguZGlybmFtZShjb250ZXh0LmZpbGVOYW1lKSwgdGhpcy5ub2RlLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZSlcbiAgICAgICAgICAgICAgLnJlcGxhY2UoVFNfRFRTX0VYVEVOU0lPTiwgJycpO1xuXG4gICAgICAvLyBwYXRoLnJlbGF0aXZlKCkgZG9lcyBub3QgaW5jbHVkZSB0aGUgbGVhZGluZyAnLi8nLlxuICAgICAgaWYgKCFyZWxhdGl2ZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmVsYXRpdmUgPSBgLi8ke3JlbGF0aXZlfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhdGgucmVsYXRpdmUoKSByZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcgKGNvbnZlcnRlZCB0byAnLi8nIGFib3ZlKSBpZiB0aGUgdHdvIHBhdGhzIGFyZSB0aGVcbiAgICAgIC8vIHNhbWUuXG4gICAgICBpZiAocmVsYXRpdmUgPT09ICcuLycpIHtcbiAgICAgICAgLy8gU2FtZSBmaWxlIGFmdGVyIGFsbC5cbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIodGhpcy5pZGVudGlmaWVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKG5ldyBFeHRlcm5hbFJlZmVyZW5jZShyZWxhdGl2ZSwgdGhpcy5pZGVudGlmaWVyLnRleHQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aXRoSWRlbnRpZmllcihpZGVudGlmaWVyOiB0cy5JZGVudGlmaWVyKTogUmVzb2x2ZWRSZWZlcmVuY2Uge1xuICAgIHJldHVybiBuZXcgUmVzb2x2ZWRSZWZlcmVuY2UodGhpcy5ub2RlLCBpZGVudGlmaWVyKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgbm9kZSB3aGljaCBoYXMgYSBgdHMuSWRlbnRpZmVyYCBhbmQgYW4gZXhwZWN0ZWQgYWJzb2x1dGUgbW9kdWxlIG5hbWUuXG4gKlxuICogQW4gYEFic29sdXRlUmVmZXJlbmNlYCBjYW4gYmUgcmVzb2x2ZWQgdG8gYW4gYEV4cHJlc3Npb25gLCBhbmQgaWYgdGhhdCBleHByZXNzaW9uIGlzIGFuIGltcG9ydFxuICogdGhlIG1vZHVsZSBzcGVjaWZpZXIgd2lsbCBiZSBhbiBhYnNvbHV0ZSBtb2R1bGUgbmFtZSwgbm90IGEgcmVsYXRpdmUgcGF0aC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFic29sdXRlUmVmZXJlbmNlIGV4dGVuZHMgUmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBub2RlOiB0cy5Ob2RlLCBwcml2YXRlIGlkZW50aWZpZXI6IHRzLklkZW50aWZpZXIsIHJlYWRvbmx5IG1vZHVsZU5hbWU6IHN0cmluZyxcbiAgICAgIHByaXZhdGUgc3ltYm9sTmFtZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobm9kZSk7XG4gIH1cblxuICByZWFkb25seSBleHByZXNzYWJsZSA9IHRydWU7XG5cbiAgdG9FeHByZXNzaW9uKGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUpOiBFeHByZXNzaW9uIHtcbiAgICBpZiAodHMuZ2V0T3JpZ2luYWxOb2RlKGNvbnRleHQpID09PSB0cy5nZXRPcmlnaW5hbE5vZGUodGhpcy5pZGVudGlmaWVyKS5nZXRTb3VyY2VGaWxlKCkpIHtcbiAgICAgIHJldHVybiBuZXcgV3JhcHBlZE5vZGVFeHByKHRoaXMuaWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKG5ldyBFeHRlcm5hbFJlZmVyZW5jZSh0aGlzLm1vZHVsZU5hbWUsIHRoaXMuc3ltYm9sTmFtZSkpO1xuICAgIH1cbiAgfVxuXG4gIHdpdGhJZGVudGlmaWVyKGlkZW50aWZpZXI6IHRzLklkZW50aWZpZXIpOiBBYnNvbHV0ZVJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVJlZmVyZW5jZSh0aGlzLm5vZGUsIGlkZW50aWZpZXIsIHRoaXMubW9kdWxlTmFtZSwgdGhpcy5zeW1ib2xOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIFN0YXRpY2FsbHkgcmVzb2x2ZSB0aGUgZ2l2ZW4gYHRzLkV4cHJlc3Npb25gIGludG8gYSBgUmVzb2x2ZWRWYWx1ZWAuXG4gKlxuICogQHBhcmFtIG5vZGUgdGhlIGV4cHJlc3Npb24gdG8gc3RhdGljYWxseSByZXNvbHZlIGlmIHBvc3NpYmxlXG4gKiBAcGFyYW0gY2hlY2tlciBhIGB0cy5UeXBlQ2hlY2tlcmAgdXNlZCB0byB1bmRlcnN0YW5kIHRoZSBleHByZXNzaW9uXG4gKiBAcGFyYW0gZm9yZWlnbkZ1bmN0aW9uUmVzb2x2ZXIgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHVzZWQgd2hlbmV2ZXIgYSBcImZvcmVpZ24gZnVuY3Rpb25cIiBpc1xuICogZW5jb3VudGVyZWQuIEEgZm9yZWlnbiBmdW5jdGlvbiBpcyBhIGZ1bmN0aW9uIHdoaWNoIGhhcyBubyBib2R5IC0gdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcbiAqIGEgZnVuY3Rpb24gZGVjbGFyZWQgaW4gYW5vdGhlciBsaWJyYXJ5J3MgLmQudHMgZmlsZS4gSW4gdGhlc2UgY2FzZXMsIHRoZSBmb3JlaWduRnVuY3Rpb25SZXNvbHZlclxuICogd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZnVuY3Rpb24ncyBkZWNsYXJhdGlvbiwgYW5kIGNhbiBvcHRpb25hbGx5IHJldHVybiBhIGB0cy5FeHByZXNzaW9uYFxuICogKHBvc3NpYmx5IGV4dHJhY3RlZCBmcm9tIHRoZSBmb3JlaWduIGZ1bmN0aW9uJ3MgdHlwZSBzaWduYXR1cmUpIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgY2FsbC5cbiAqIEByZXR1cm5zIGEgYFJlc29sdmVkVmFsdWVgIHJlcHJlc2VudGluZyB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRpY2FsbHlSZXNvbHZlKFxuICAgIG5vZGU6IHRzLkV4cHJlc3Npb24sIGhvc3Q6IFJlZmxlY3Rpb25Ib3N0LCBjaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICBmb3JlaWduRnVuY3Rpb25SZXNvbHZlcj86IChub2RlOiB0cy5GdW5jdGlvbkRlY2xhcmF0aW9uIHwgdHMuTWV0aG9kRGVjbGFyYXRpb24pID0+XG4gICAgICAgIHRzLkV4cHJlc3Npb24gfCBudWxsKTogUmVzb2x2ZWRWYWx1ZSB7XG4gIHJldHVybiBuZXcgU3RhdGljSW50ZXJwcmV0ZXIoaG9zdCwgY2hlY2tlcikudmlzaXQobm9kZSwge1xuICAgIGFic29sdXRlTW9kdWxlTmFtZTogbnVsbCxcbiAgICBzY29wZTogbmV3IE1hcDx0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbiwgUmVzb2x2ZWRWYWx1ZT4oKSwgZm9yZWlnbkZ1bmN0aW9uUmVzb2x2ZXIsXG4gIH0pO1xufVxuXG5pbnRlcmZhY2UgQmluYXJ5T3BlcmF0b3JEZWYge1xuICBsaXRlcmFsOiBib29sZWFuO1xuICBvcDogKGE6IGFueSwgYjogYW55KSA9PiBSZXNvbHZlZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBsaXRlcmFsQmluYXJ5T3Aob3A6IChhOiBhbnksIGI6IGFueSkgPT4gYW55KTogQmluYXJ5T3BlcmF0b3JEZWYge1xuICByZXR1cm4ge29wLCBsaXRlcmFsOiB0cnVlfTtcbn1cblxuZnVuY3Rpb24gcmVmZXJlbmNlQmluYXJ5T3Aob3A6IChhOiBhbnksIGI6IGFueSkgPT4gYW55KTogQmluYXJ5T3BlcmF0b3JEZWYge1xuICByZXR1cm4ge29wLCBsaXRlcmFsOiBmYWxzZX07XG59XG5cbmNvbnN0IEJJTkFSWV9PUEVSQVRPUlMgPSBuZXcgTWFwPHRzLlN5bnRheEtpbmQsIEJpbmFyeU9wZXJhdG9yRGVmPihbXG4gIFt0cy5TeW50YXhLaW5kLlBsdXNUb2tlbiwgbGl0ZXJhbEJpbmFyeU9wKChhLCBiKSA9PiBhICsgYildLFxuICBbdHMuU3ludGF4S2luZC5NaW51c1Rva2VuLCBsaXRlcmFsQmluYXJ5T3AoKGEsIGIpID0+IGEgLSBiKV0sXG4gIFt0cy5TeW50YXhLaW5kLkFzdGVyaXNrVG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSAqIGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuU2xhc2hUb2tlbiwgbGl0ZXJhbEJpbmFyeU9wKChhLCBiKSA9PiBhIC8gYildLFxuICBbdHMuU3ludGF4S2luZC5QZXJjZW50VG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSAlIGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuQW1wZXJzYW5kVG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSAmIGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuQmFyVG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSB8IGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuQ2FyZXRUb2tlbiwgbGl0ZXJhbEJpbmFyeU9wKChhLCBiKSA9PiBhIF4gYildLFxuICBbdHMuU3ludGF4S2luZC5MZXNzVGhhblRva2VuLCBsaXRlcmFsQmluYXJ5T3AoKGEsIGIpID0+IGEgPCBiKV0sXG4gIFt0cy5TeW50YXhLaW5kLkxlc3NUaGFuRXF1YWxzVG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSA8PSBiKV0sXG4gIFt0cy5TeW50YXhLaW5kLkdyZWF0ZXJUaGFuVG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSA+IGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuR3JlYXRlclRoYW5FcXVhbHNUb2tlbiwgbGl0ZXJhbEJpbmFyeU9wKChhLCBiKSA9PiBhID49IGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuTGVzc1RoYW5MZXNzVGhhblRva2VuLCBsaXRlcmFsQmluYXJ5T3AoKGEsIGIpID0+IGEgPDwgYildLFxuICBbdHMuU3ludGF4S2luZC5HcmVhdGVyVGhhbkdyZWF0ZXJUaGFuVG9rZW4sIGxpdGVyYWxCaW5hcnlPcCgoYSwgYikgPT4gYSA+PiBiKV0sXG4gIFt0cy5TeW50YXhLaW5kLkdyZWF0ZXJUaGFuR3JlYXRlclRoYW5HcmVhdGVyVGhhblRva2VuLCBsaXRlcmFsQmluYXJ5T3AoKGEsIGIpID0+IGEgPj4+IGIpXSxcbiAgW3RzLlN5bnRheEtpbmQuQXN0ZXJpc2tBc3Rlcmlza1Rva2VuLCBsaXRlcmFsQmluYXJ5T3AoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKV0sXG4gIFt0cy5TeW50YXhLaW5kLkFtcGVyc2FuZEFtcGVyc2FuZFRva2VuLCByZWZlcmVuY2VCaW5hcnlPcCgoYSwgYikgPT4gYSAmJiBiKV0sXG4gIFt0cy5TeW50YXhLaW5kLkJhckJhclRva2VuLCByZWZlcmVuY2VCaW5hcnlPcCgoYSwgYikgPT4gYSB8fCBiKV1cbl0pO1xuXG5jb25zdCBVTkFSWV9PUEVSQVRPUlMgPSBuZXcgTWFwPHRzLlN5bnRheEtpbmQsIChhOiBhbnkpID0+IGFueT4oW1xuICBbdHMuU3ludGF4S2luZC5UaWxkZVRva2VuLCBhID0+IH5hXSwgW3RzLlN5bnRheEtpbmQuTWludXNUb2tlbiwgYSA9PiAtYV0sXG4gIFt0cy5TeW50YXhLaW5kLlBsdXNUb2tlbiwgYSA9PiArYV0sIFt0cy5TeW50YXhLaW5kLkV4Y2xhbWF0aW9uVG9rZW4sIGEgPT4gIWFdXG5dKTtcblxuaW50ZXJmYWNlIENvbnRleHQge1xuICBhYnNvbHV0ZU1vZHVsZU5hbWU6IHN0cmluZ3xudWxsO1xuICBzY29wZTogU2NvcGU7XG4gIGZvcmVpZ25GdW5jdGlvblJlc29sdmVyP1xuICAgICAgKG5vZGU6IHRzLkZ1bmN0aW9uRGVjbGFyYXRpb258dHMuTWV0aG9kRGVjbGFyYXRpb258dHMuRnVuY3Rpb25FeHByZXNzaW9uKTogdHMuRXhwcmVzc2lvbnxudWxsO1xufVxuXG5jbGFzcyBTdGF0aWNJbnRlcnByZXRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaG9zdDogUmVmbGVjdGlvbkhvc3QsIHByaXZhdGUgY2hlY2tlcjogdHMuVHlwZUNoZWNrZXIpIHt9XG5cbiAgdmlzaXQobm9kZTogdHMuRXhwcmVzc2lvbiwgY29udGV4dDogQ29udGV4dCk6IFJlc29sdmVkVmFsdWUge1xuICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRFeHByZXNzaW9uKG5vZGU6IHRzLkV4cHJlc3Npb24sIGNvbnRleHQ6IENvbnRleHQpOiBSZXNvbHZlZFZhbHVlIHtcbiAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLlRydWVLZXl3b3JkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUua2luZCA9PT0gdHMuU3ludGF4S2luZC5GYWxzZUtleXdvcmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzU3RyaW5nTGl0ZXJhbChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgICB9IGVsc2UgaWYgKHRzLmlzTm9TdWJzdGl0dXRpb25UZW1wbGF0ZUxpdGVyYWwobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnRleHQ7XG4gICAgfSBlbHNlIGlmICh0cy5pc1RlbXBsYXRlRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0cy5pc051bWVyaWNMaXRlcmFsKG5vZGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLnRleHQpO1xuICAgIH0gZWxzZSBpZiAodHMuaXNPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzSWRlbnRpZmllcihub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRJZGVudGlmaWVyKG5vZGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodHMuaXNDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRDYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdENvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzUHJlZml4VW5hcnlFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdFByZWZpeFVuYXJ5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzQmluYXJ5RXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRCaW5hcnlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodHMuaXNBcnJheUxpdGVyYWxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdEFycmF5TGl0ZXJhbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0cy5pc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodHMuaXNFbGVtZW50QWNjZXNzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRFbGVtZW50QWNjZXNzRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzQXNFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzTm9uTnVsbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAoaXNQb3NzaWJsZUNsYXNzRGVjbGFyYXRpb24obm9kZSkgJiYgdGhpcy5ob3N0LmlzQ2xhc3Mobm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0RGVjbGFyYXRpb24obm9kZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEWU5BTUlDX1ZBTFVFO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRBcnJheUxpdGVyYWxFeHByZXNzaW9uKG5vZGU6IHRzLkFycmF5TGl0ZXJhbEV4cHJlc3Npb24sIGNvbnRleHQ6IENvbnRleHQpOlxuICAgICAgUmVzb2x2ZWRWYWx1ZSB7XG4gICAgY29uc3QgYXJyYXk6IFJlc29sdmVkVmFsdWVBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGUuZWxlbWVudHNbaV07XG4gICAgICBpZiAodHMuaXNTcHJlYWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZCA9IHRoaXMudmlzaXRFeHByZXNzaW9uKGVsZW1lbnQuZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgIGlmIChpc0R5bmFtaWNWYWx1ZShzcHJlYWQpKSB7XG4gICAgICAgICAgcmV0dXJuIERZTkFNSUNfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNwcmVhZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgaW4gc3ByZWFkIGV4cHJlc3Npb246ICR7c3ByZWFkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXkucHVzaCguLi5zcHJlYWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy52aXNpdEV4cHJlc3Npb24oZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgIGlmIChpc0R5bmFtaWNWYWx1ZShyZXN1bHQpKSB7XG4gICAgICAgICAgcmV0dXJuIERZTkFNSUNfVkFMVUU7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheS5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRPYmplY3RMaXRlcmFsRXhwcmVzc2lvbihub2RlOiB0cy5PYmplY3RMaXRlcmFsRXhwcmVzc2lvbiwgY29udGV4dDogQ29udGV4dCk6XG4gICAgICBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCBtYXA6IFJlc29sdmVkVmFsdWVNYXAgPSBuZXcgTWFwPHN0cmluZywgUmVzb2x2ZWRWYWx1ZT4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBub2RlLnByb3BlcnRpZXNbaV07XG4gICAgICBpZiAodHMuaXNQcm9wZXJ0eUFzc2lnbm1lbnQocHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnN0cmluZ05hbWVGcm9tUHJvcGVydHlOYW1lKHByb3BlcnR5Lm5hbWUsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIG5hbWUgY2FuIGJlIGRldGVybWluZWQgc3RhdGljYWxseS5cbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBEWU5BTUlDX1ZBTFVFO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwLnNldChuYW1lLCB0aGlzLnZpc2l0RXhwcmVzc2lvbihwcm9wZXJ0eS5pbml0aWFsaXplciwgY29udGV4dCkpO1xuICAgICAgfSBlbHNlIGlmICh0cy5pc1Nob3J0aGFuZFByb3BlcnR5QXNzaWdubWVudChwcm9wZXJ0eSkpIHtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy5jaGVja2VyLmdldFNob3J0aGFuZEFzc2lnbm1lbnRWYWx1ZVN5bWJvbChwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChzeW1ib2wgPT09IHVuZGVmaW5lZCB8fCBzeW1ib2wudmFsdWVEZWNsYXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIERZTkFNSUNfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgbWFwLnNldChwcm9wZXJ0eS5uYW1lLnRleHQsIHRoaXMudmlzaXREZWNsYXJhdGlvbihzeW1ib2wudmFsdWVEZWNsYXJhdGlvbiwgY29udGV4dCkpO1xuICAgICAgfSBlbHNlIGlmICh0cy5pc1NwcmVhZEFzc2lnbm1lbnQocHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZCA9IHRoaXMudmlzaXRFeHByZXNzaW9uKHByb3BlcnR5LmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICBpZiAoaXNEeW5hbWljVmFsdWUoc3ByZWFkKSkge1xuICAgICAgICAgIHJldHVybiBEWU5BTUlDX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNwcmVhZCBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgaW4gc3ByZWFkIGFzc2lnbm1lbnQ6ICR7c3ByZWFkfWApO1xuICAgICAgICB9XG4gICAgICAgIHNwcmVhZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBtYXAuc2V0KGtleSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBEWU5BTUlDX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgcHJpdmF0ZSB2aXNpdFRlbXBsYXRlRXhwcmVzc2lvbihub2RlOiB0cy5UZW1wbGF0ZUV4cHJlc3Npb24sIGNvbnRleHQ6IENvbnRleHQpOiBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCBwaWVjZXM6IHN0cmluZ1tdID0gW25vZGUuaGVhZC50ZXh0XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUudGVtcGxhdGVTcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3BhbiA9IG5vZGUudGVtcGxhdGVTcGFuc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aXNpdChzcGFuLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcGllY2VzLnB1c2goYCR7dmFsdWV9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRFlOQU1JQ19WQUxVRTtcbiAgICAgIH1cbiAgICAgIHBpZWNlcy5wdXNoKHNwYW4ubGl0ZXJhbC50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBpZWNlcy5qb2luKCcnKTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRJZGVudGlmaWVyKG5vZGU6IHRzLklkZW50aWZpZXIsIGNvbnRleHQ6IENvbnRleHQpOiBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCBkZWNsID0gdGhpcy5ob3N0LmdldERlY2xhcmF0aW9uT2ZJZGVudGlmaWVyKG5vZGUpO1xuICAgIGlmIChkZWNsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gRFlOQU1JQ19WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy52aXNpdERlY2xhcmF0aW9uKFxuICAgICAgICBkZWNsLm5vZGUsIHsuLi5jb250ZXh0LCBhYnNvbHV0ZU1vZHVsZU5hbWU6IGRlY2wudmlhTW9kdWxlIHx8IGNvbnRleHQuYWJzb2x1dGVNb2R1bGVOYW1lfSk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC53aXRoSWRlbnRpZmllcihub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZpc2l0RGVjbGFyYXRpb24obm9kZTogdHMuRGVjbGFyYXRpb24sIGNvbnRleHQ6IENvbnRleHQpOiBSZXNvbHZlZFZhbHVlIHtcbiAgICBpZiAodGhpcy5ob3N0LmlzQ2xhc3Mobm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJlZmVyZW5jZShub2RlLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgaWYgKCFub2RlLmluaXRpYWxpemVyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS5pbml0aWFsaXplciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0cy5pc1BhcmFtZXRlcihub2RlKSAmJiBjb250ZXh0LnNjb3BlLmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuc2NvcGUuZ2V0KG5vZGUpICE7XG4gICAgfSBlbHNlIGlmICh0cy5pc0V4cG9ydEFzc2lnbm1lbnQobm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodHMuaXNTb3VyY2VGaWxlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdFNvdXJjZUZpbGUobm9kZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJlZmVyZW5jZShub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZpc2l0RWxlbWVudEFjY2Vzc0V4cHJlc3Npb24obm9kZTogdHMuRWxlbWVudEFjY2Vzc0V4cHJlc3Npb24sIGNvbnRleHQ6IENvbnRleHQpOlxuICAgICAgUmVzb2x2ZWRWYWx1ZSB7XG4gICAgY29uc3QgbGhzID0gdGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICBpZiAobm9kZS5hcmd1bWVudEV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcmd1bWVudCBpbiBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbmApO1xuICAgIH1cbiAgICBpZiAoaXNEeW5hbWljVmFsdWUobGhzKSkge1xuICAgICAgcmV0dXJuIERZTkFNSUNfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IHJocyA9IHRoaXMudmlzaXRFeHByZXNzaW9uKG5vZGUuYXJndW1lbnRFeHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICBpZiAoaXNEeW5hbWljVmFsdWUocmhzKSkge1xuICAgICAgcmV0dXJuIERZTkFNSUNfVkFMVUU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmhzICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcmhzICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFbGVtZW50QWNjZXNzRXhwcmVzc2lvbiBpbmRleCBzaG91bGQgYmUgc3RyaW5nIG9yIG51bWJlciwgZ290ICR7dHlwZW9mIHJoc306ICR7cmhzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFjY2Vzc0hlbHBlcihsaHMsIHJocywgY29udGV4dCk7XG4gIH1cblxuICBwcml2YXRlIHZpc2l0UHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKG5vZGU6IHRzLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiwgY29udGV4dDogQ29udGV4dCk6XG4gICAgICBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCBsaHMgPSB0aGlzLnZpc2l0RXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIGNvbnN0IHJocyA9IG5vZGUubmFtZS50ZXh0O1xuICAgIC8vIFRPRE86IGhhbmRsZSByZWZlcmVuY2UgdG8gY2xhc3MgZGVjbGFyYXRpb24uXG4gICAgaWYgKGlzRHluYW1pY1ZhbHVlKGxocykpIHtcbiAgICAgIHJldHVybiBEWU5BTUlDX1ZBTFVFO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFjY2Vzc0hlbHBlcihsaHMsIHJocywgY29udGV4dCk7XG4gIH1cblxuICBwcml2YXRlIHZpc2l0U291cmNlRmlsZShub2RlOiB0cy5Tb3VyY2VGaWxlLCBjb250ZXh0OiBDb250ZXh0KTogUmVzb2x2ZWRWYWx1ZSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gdGhpcy5ob3N0LmdldEV4cG9ydHNPZk1vZHVsZShub2RlKTtcbiAgICBpZiAoZGVjbGFyYXRpb25zID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gRFlOQU1JQ19WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcDxzdHJpbmcsIFJlc29sdmVkVmFsdWU+KCk7XG4gICAgZGVjbGFyYXRpb25zLmZvckVhY2goKGRlY2wsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aXNpdERlY2xhcmF0aW9uKGRlY2wubm9kZSwge1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBhYnNvbHV0ZU1vZHVsZU5hbWU6IGRlY2wudmlhTW9kdWxlIHx8IGNvbnRleHQuYWJzb2x1dGVNb2R1bGVOYW1lLFxuICAgICAgfSk7XG4gICAgICBtYXAuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgcHJpdmF0ZSBhY2Nlc3NIZWxwZXIobGhzOiBSZXNvbHZlZFZhbHVlLCByaHM6IHN0cmluZ3xudW1iZXIsIGNvbnRleHQ6IENvbnRleHQpOiBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCBzdHJJbmRleCA9IGAke3Joc31gO1xuICAgIGlmIChsaHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGlmIChsaHMuaGFzKHN0ckluZGV4KSkge1xuICAgICAgICByZXR1cm4gbGhzLmdldChzdHJJbmRleCkgITtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtYXAgYWNjZXNzOiBbJHtBcnJheS5mcm9tKGxocy5rZXlzKCkpfV0gZG90ICR7cmhzfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShsaHMpKSB7XG4gICAgICBpZiAocmhzID09PSAnbGVuZ3RoJykge1xuICAgICAgICByZXR1cm4gbGhzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmhzICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihyaHMpKSB7XG4gICAgICAgIHJldHVybiBEWU5BTUlDX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKHJocyA8IDAgfHwgcmhzID49IGxocy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleCBvdXQgb2YgYm91bmRzOiAke3Joc30gdnMgJHtsaHMubGVuZ3RofWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxoc1tyaHNdO1xuICAgIH0gZWxzZSBpZiAobGhzIGluc3RhbmNlb2YgUmVmZXJlbmNlKSB7XG4gICAgICBjb25zdCByZWYgPSBsaHMubm9kZTtcbiAgICAgIGlmIChpc1Bvc3NpYmxlQ2xhc3NEZWNsYXJhdGlvbihyZWYpICYmIHRoaXMuaG9zdC5pc0NsYXNzKHJlZikpIHtcbiAgICAgICAgbGV0IGFic29sdXRlTW9kdWxlTmFtZSA9IGNvbnRleHQuYWJzb2x1dGVNb2R1bGVOYW1lO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgTm9kZVJlZmVyZW5jZSB8fCBsaHMgaW5zdGFuY2VvZiBBYnNvbHV0ZVJlZmVyZW5jZSkge1xuICAgICAgICAgIGFic29sdXRlTW9kdWxlTmFtZSA9IGxocy5tb2R1bGVOYW1lIHx8IGFic29sdXRlTW9kdWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWU6IFJlc29sdmVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuaG9zdC5nZXRNZW1iZXJzT2ZDbGFzcyhyZWYpLmZpbmQoXG4gICAgICAgICAgICBtZW1iZXIgPT4gbWVtYmVyLmlzU3RhdGljICYmIG1lbWJlci5uYW1lID09PSBzdHJJbmRleCk7XG4gICAgICAgIGlmIChtZW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChtZW1iZXIudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52aXNpdEV4cHJlc3Npb24obWVtYmVyLnZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5pbXBsZW1lbnRhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTm9kZVJlZmVyZW5jZShtZW1iZXIuaW1wbGVtZW50YXRpb24sIGFic29sdXRlTW9kdWxlTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZW1iZXIubm9kZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTm9kZVJlZmVyZW5jZShtZW1iZXIubm9kZSwgYWJzb2x1dGVNb2R1bGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZG90IHByb3BlcnR5IGFjY2VzczogJHtsaHN9IGRvdCAke3Joc31gKTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRDYWxsRXhwcmVzc2lvbihub2RlOiB0cy5DYWxsRXhwcmVzc2lvbiwgY29udGV4dDogQ29udGV4dCk6IFJlc29sdmVkVmFsdWUge1xuICAgIGNvbnN0IGxocyA9IHRoaXMudmlzaXRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgaWYgKCEobGhzIGluc3RhbmNlb2YgUmVmZXJlbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdHRlbXB0aW5nIHRvIGNhbGwgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgZnVuY3Rpb246ICR7bGhzfWApO1xuICAgIH0gZWxzZSBpZiAoIWlzRnVuY3Rpb25Pck1ldGhvZERlY2xhcmF0aW9uKGxocy5ub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBjYWxsaW5nIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uPyAke3RzLlN5bnRheEtpbmRbbGhzLm5vZGUua2luZF19ICgke25vZGUuZ2V0VGV4dCgpfSlgKTtcbiAgICB9XG5cbiAgICBjb25zdCBmbiA9IGxocy5ub2RlO1xuXG4gICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGlzIGZvcmVpZ24gKGRlY2xhcmVkIHRocm91Z2ggYSBkLnRzIGZpbGUpLCBhdHRlbXB0IHRvIHJlc29sdmUgaXQgd2l0aCB0aGVcbiAgICAvLyBmb3JlaWduRnVuY3Rpb25SZXNvbHZlciwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICBpZiAoZm4uYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZXhwcjogdHMuRXhwcmVzc2lvbnxudWxsID0gbnVsbDtcbiAgICAgIGlmIChjb250ZXh0LmZvcmVpZ25GdW5jdGlvblJlc29sdmVyKSB7XG4gICAgICAgIGV4cHIgPSBjb250ZXh0LmZvcmVpZ25GdW5jdGlvblJlc29sdmVyKGZuKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHByID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY291bGQgbm90IHJlc29sdmUgZm9yZWlnbiBmdW5jdGlvbiBkZWNsYXJhdGlvbmApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gaXMgZGVjbGFyZWQgaW4gYSBkaWZmZXJlbnQgZmlsZSwgcmVzb2x2ZSB0aGUgZm9yZWlnbiBmdW5jdGlvbiBleHByZXNzaW9uXG4gICAgICAvLyB1c2luZyB0aGUgYWJzb2x1dGUgbW9kdWxlIG5hbWUgb2YgdGhhdCBmaWxlIChpZiBhbnkpLlxuICAgICAgbGV0IGFic29sdXRlTW9kdWxlTmFtZTogc3RyaW5nfG51bGwgPSBjb250ZXh0LmFic29sdXRlTW9kdWxlTmFtZTtcbiAgICAgIGlmIChsaHMgaW5zdGFuY2VvZiBOb2RlUmVmZXJlbmNlIHx8IGxocyBpbnN0YW5jZW9mIEFic29sdXRlUmVmZXJlbmNlKSB7XG4gICAgICAgIGFic29sdXRlTW9kdWxlTmFtZSA9IGxocy5tb2R1bGVOYW1lIHx8IGFic29sdXRlTW9kdWxlTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGV4cHIsIHsuLi5jb250ZXh0LCBhYnNvbHV0ZU1vZHVsZU5hbWV9KTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gZm4uYm9keTtcbiAgICBpZiAoYm9keS5zdGF0ZW1lbnRzLmxlbmd0aCAhPT0gMSB8fCAhdHMuaXNSZXR1cm5TdGF0ZW1lbnQoYm9keS5zdGF0ZW1lbnRzWzBdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBib2R5IG11c3QgaGF2ZSBhIHNpbmdsZSByZXR1cm4gc3RhdGVtZW50IG9ubHkuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGJvZHkuc3RhdGVtZW50c1swXSBhcyB0cy5SZXR1cm5TdGF0ZW1lbnQ7XG5cbiAgICBjb25zdCBuZXdTY29wZTogU2NvcGUgPSBuZXcgTWFwPHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uLCBSZXNvbHZlZFZhbHVlPigpO1xuICAgIGZuLnBhcmFtZXRlcnMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICBsZXQgdmFsdWU6IFJlc29sdmVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5kZXggPCBub2RlLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYXJnID0gbm9kZS5hcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB2YWx1ZSA9IHRoaXMudmlzaXRFeHByZXNzaW9uKGFyZywgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwYXJhbS5pbml0aWFsaXplciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy52aXNpdEV4cHJlc3Npb24ocGFyYW0uaW5pdGlhbGl6ZXIsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgbmV3U2NvcGUuc2V0KHBhcmFtLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0LmV4cHJlc3Npb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRoaXMudmlzaXRFeHByZXNzaW9uKHJldC5leHByZXNzaW9uLCB7Li4uY29udGV4dCwgc2NvcGU6IG5ld1Njb3BlfSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIHZpc2l0Q29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGU6IHRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiwgY29udGV4dDogQ29udGV4dCk6XG4gICAgICBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCBjb25kaXRpb24gPSB0aGlzLnZpc2l0RXhwcmVzc2lvbihub2RlLmNvbmRpdGlvbiwgY29udGV4dCk7XG4gICAgaWYgKGlzRHluYW1pY1ZhbHVlKGNvbmRpdGlvbikpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb247XG4gICAgfVxuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKG5vZGUud2hlblRydWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS53aGVuRmFsc2UsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRQcmVmaXhVbmFyeUV4cHJlc3Npb24obm9kZTogdHMuUHJlZml4VW5hcnlFeHByZXNzaW9uLCBjb250ZXh0OiBDb250ZXh0KTpcbiAgICAgIFJlc29sdmVkVmFsdWUge1xuICAgIGNvbnN0IG9wZXJhdG9yS2luZCA9IG5vZGUub3BlcmF0b3I7XG4gICAgaWYgKCFVTkFSWV9PUEVSQVRPUlMuaGFzKG9wZXJhdG9yS2luZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJlZml4IHVuYXJ5IG9wZXJhdG9yOiAke3RzLlN5bnRheEtpbmRbb3BlcmF0b3JLaW5kXX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcCA9IFVOQVJZX09QRVJBVE9SUy5nZXQob3BlcmF0b3JLaW5kKSAhO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS5vcGVyYW5kLCBjb250ZXh0KTtcbiAgICByZXR1cm4gaXNEeW5hbWljVmFsdWUodmFsdWUpID8gRFlOQU1JQ19WQUxVRSA6IG9wKHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgdmlzaXRCaW5hcnlFeHByZXNzaW9uKG5vZGU6IHRzLkJpbmFyeUV4cHJlc3Npb24sIGNvbnRleHQ6IENvbnRleHQpOiBSZXNvbHZlZFZhbHVlIHtcbiAgICBjb25zdCB0b2tlbktpbmQgPSBub2RlLm9wZXJhdG9yVG9rZW4ua2luZDtcbiAgICBpZiAoIUJJTkFSWV9PUEVSQVRPUlMuaGFzKHRva2VuS2luZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYmluYXJ5IG9wZXJhdG9yOiAke3RzLlN5bnRheEtpbmRbdG9rZW5LaW5kXX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcFJlY29yZCA9IEJJTkFSWV9PUEVSQVRPUlMuZ2V0KHRva2VuS2luZCkgITtcbiAgICBsZXQgbGhzOiBSZXNvbHZlZFZhbHVlLCByaHM6IFJlc29sdmVkVmFsdWU7XG4gICAgaWYgKG9wUmVjb3JkLmxpdGVyYWwpIHtcbiAgICAgIGxocyA9IGxpdGVyYWwodGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS5sZWZ0LCBjb250ZXh0KSk7XG4gICAgICByaHMgPSBsaXRlcmFsKHRoaXMudmlzaXRFeHByZXNzaW9uKG5vZGUucmlnaHQsIGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGhzID0gdGhpcy52aXNpdEV4cHJlc3Npb24obm9kZS5sZWZ0LCBjb250ZXh0KTtcbiAgICAgIHJocyA9IHRoaXMudmlzaXRFeHByZXNzaW9uKG5vZGUucmlnaHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpc0R5bmFtaWNWYWx1ZShsaHMpIHx8IGlzRHluYW1pY1ZhbHVlKHJocykgPyBEWU5BTUlDX1ZBTFVFIDogb3BSZWNvcmQub3AobGhzLCByaHMpO1xuICB9XG5cbiAgcHJpdmF0ZSB2aXNpdFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGU6IHRzLlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCBjb250ZXh0OiBDb250ZXh0KTpcbiAgICAgIFJlc29sdmVkVmFsdWUge1xuICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdHJpbmdOYW1lRnJvbVByb3BlcnR5TmFtZShub2RlOiB0cy5Qcm9wZXJ0eU5hbWUsIGNvbnRleHQ6IENvbnRleHQpOiBzdHJpbmd8dW5kZWZpbmVkIHtcbiAgICBpZiAodHMuaXNJZGVudGlmaWVyKG5vZGUpIHx8IHRzLmlzU3RyaW5nTGl0ZXJhbChub2RlKSB8fCB0cy5pc051bWVyaWNMaXRlcmFsKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7ICAvLyB0cy5Db21wdXRlZFByb3BlcnR5TmFtZVxuICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMudmlzaXRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICByZXR1cm4gdHlwZW9mIGxpdGVyYWwgPT09ICdzdHJpbmcnID8gbGl0ZXJhbCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldFJlZmVyZW5jZShub2RlOiB0cy5EZWNsYXJhdGlvbiwgY29udGV4dDogQ29udGV4dCk6IFJlZmVyZW5jZSB7XG4gICAgY29uc3QgaWQgPSBpZGVudGlmaWVyT2ZEZWNsYXJhdGlvbihub2RlKTtcbiAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb24ndCBrbm93IGhvdyB0byByZWZlciB0byAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX1gKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYWJzb2x1dGVNb2R1bGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPKGFseGh1Yik6IGludmVzdGlnYXRlIHdoZXRoZXIgdGhpcyBjYW4gZ2V0IHN5bWJvbCBuYW1lcyB3cm9uZyBpbiB0aGUgZXZlbnQgb2ZcbiAgICAgIC8vIHJlLWV4cG9ydHMgdW5kZXIgZGlmZmVyZW50IG5hbWVzLlxuICAgICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVJlZmVyZW5jZShub2RlLCBpZCwgY29udGV4dC5hYnNvbHV0ZU1vZHVsZU5hbWUsIGlkLnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlc29sdmVkUmVmZXJlbmNlKG5vZGUsIGlkKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbk9yTWV0aG9kRGVjbGFyYXRpb24obm9kZTogdHMuTm9kZSk6IG5vZGUgaXMgdHMuRnVuY3Rpb25EZWNsYXJhdGlvbnxcbiAgICB0cy5NZXRob2REZWNsYXJhdGlvbnx0cy5GdW5jdGlvbkV4cHJlc3Npb24ge1xuICByZXR1cm4gdHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpIHx8IHRzLmlzTWV0aG9kRGVjbGFyYXRpb24obm9kZSkgfHxcbiAgICAgIHRzLmlzRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlOiBSZXNvbHZlZFZhbHVlKTogYW55IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNEeW5hbWljVmFsdWUodmFsdWUpKSB7XG4gICAgcmV0dXJuIERZTkFNSUNfVkFMVUU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSAke3ZhbHVlfSBpcyBub3QgbGl0ZXJhbCBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdGhpcyBjb250ZXh0LmApO1xufVxuXG5mdW5jdGlvbiBpZGVudGlmaWVyT2ZEZWNsYXJhdGlvbihkZWNsOiB0cy5EZWNsYXJhdGlvbik6IHRzLklkZW50aWZpZXJ8dW5kZWZpbmVkIHtcbiAgaWYgKHRzLmlzQ2xhc3NEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgIHJldHVybiBkZWNsLm5hbWU7XG4gIH0gZWxzZSBpZiAodHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgcmV0dXJuIGRlY2wubmFtZTtcbiAgfSBlbHNlIGlmICh0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbCkgJiYgdHMuaXNJZGVudGlmaWVyKGRlY2wubmFtZSkpIHtcbiAgICByZXR1cm4gZGVjbC5uYW1lO1xuICB9IGVsc2UgaWYgKHRzLmlzU2hvcnRoYW5kUHJvcGVydHlBc3NpZ25tZW50KGRlY2wpKSB7XG4gICAgcmV0dXJuIGRlY2wubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUG9zc2libGVDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IHRzLk5vZGUpOiBub2RlIGlzIHRzLkRlY2xhcmF0aW9uIHtcbiAgcmV0dXJuIHRzLmlzQ2xhc3NEZWNsYXJhdGlvbihub2RlKSB8fCB0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSk7XG59XG4iXX0=