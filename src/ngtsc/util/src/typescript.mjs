/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const TS = /\.tsx?$/i;
const D_TS = /\.d\.ts$/i;
import * as ts from 'typescript';
import { getFileSystem } from '../../file_system';
export function isSymbolWithValueDeclaration(symbol) {
    // If there is a value declaration set, then the `declarations` property is never undefined. We
    // still check for the property to exist as this matches with the type that `symbol` is narrowed
    // to.
    return symbol != null && symbol.valueDeclaration !== undefined &&
        symbol.declarations !== undefined;
}
export function isDtsPath(filePath) {
    return D_TS.test(filePath);
}
export function isNonDeclarationTsPath(filePath) {
    return TS.test(filePath) && !D_TS.test(filePath);
}
export function isFromDtsFile(node) {
    let sf = node.getSourceFile();
    if (sf === undefined) {
        sf = ts.getOriginalNode(node).getSourceFile();
    }
    return sf !== undefined && sf.isDeclarationFile;
}
export function nodeNameForError(node) {
    if (node.name !== undefined && ts.isIdentifier(node.name)) {
        return node.name.text;
    }
    else {
        const kind = ts.SyntaxKind[node.kind];
        const { line, character } = ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());
        return `${kind}@${line}:${character}`;
    }
}
export function getSourceFile(node) {
    // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,
    // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the
    // original node instead (which works).
    const directSf = node.getSourceFile();
    return directSf !== undefined ? directSf : ts.getOriginalNode(node).getSourceFile();
}
export function getSourceFileOrNull(program, fileName) {
    return program.getSourceFile(fileName) || null;
}
export function getTokenAtPosition(sf, pos) {
    // getTokenAtPosition is part of TypeScript's private API.
    return ts.getTokenAtPosition(sf, pos);
}
export function identifierOfNode(decl) {
    if (decl.name !== undefined && ts.isIdentifier(decl.name)) {
        return decl.name;
    }
    else {
        return null;
    }
}
export function isDeclaration(node) {
    return isValueDeclaration(node) || isTypeDeclaration(node);
}
export function isValueDeclaration(node) {
    return ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) ||
        ts.isVariableDeclaration(node);
}
export function isTypeDeclaration(node) {
    return ts.isEnumDeclaration(node) || ts.isTypeAliasDeclaration(node) ||
        ts.isInterfaceDeclaration(node);
}
export function isNamedDeclaration(node) {
    const namedNode = node;
    return namedNode.name !== undefined && ts.isIdentifier(namedNode.name);
}
export function isExported(node) {
    let topLevel = node;
    if (ts.isVariableDeclaration(node) && ts.isVariableDeclarationList(node.parent)) {
        topLevel = node.parent.parent;
    }
    return topLevel.modifiers !== undefined &&
        topLevel.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword);
}
export function getRootDirs(host, options) {
    const rootDirs = [];
    const cwd = host.getCurrentDirectory();
    const fs = getFileSystem();
    if (options.rootDirs !== undefined) {
        rootDirs.push(...options.rootDirs);
    }
    else if (options.rootDir !== undefined) {
        rootDirs.push(options.rootDir);
    }
    else {
        rootDirs.push(cwd);
    }
    // In Windows the above might not always return posix separated paths
    // See:
    // https://github.com/Microsoft/TypeScript/blob/3f7357d37f66c842d70d835bc925ec2a873ecfec/src/compiler/sys.ts#L650
    // Also compiler options might be set via an API which doesn't normalize paths
    return rootDirs.map(rootDir => fs.resolve(cwd, host.getCanonicalFileName(rootDir)));
}
export function nodeDebugInfo(node) {
    const sf = getSourceFile(node);
    const { line, character } = ts.getLineAndCharacterOfPosition(sf, node.pos);
    return `[${sf.fileName}: ${ts.SyntaxKind[node.kind]} @ ${line}:${character}]`;
}
/**
 * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.
 *
 * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.
 * Otherwise it will fallback on the `ts.ResolveModuleName()` function.
 */
export function resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache) {
    if (compilerHost.resolveModuleNames) {
        return compilerHost.resolveModuleNames([moduleName], containingFile, undefined, // reusedNames
        undefined, // redirectedReference
        compilerOptions)[0];
    }
    else {
        return ts
            .resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache !== null ? moduleResolutionCache : undefined)
            .resolvedModule;
    }
}
/** Returns true if the node is an assignment expression. */
export function isAssignment(node) {
    return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;
}
/**
 * Obtains the non-redirected source file for `sf`.
 */
export function toUnredirectedSourceFile(sf) {
    const redirectInfo = sf.redirectInfo;
    if (redirectInfo === undefined) {
        return sf;
    }
    return redirectInfo.unredirected;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvdXRpbC9zcmMvdHlwZXNjcmlwdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUM7QUFDdEIsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDO0FBRXpCLE9BQU8sS0FBSyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2pDLE9BQU8sRUFBaUIsYUFBYSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFXaEUsTUFBTSxVQUFVLDRCQUE0QixDQUFDLE1BQ1M7SUFDcEQsK0ZBQStGO0lBQy9GLGdHQUFnRztJQUNoRyxNQUFNO0lBQ04sT0FBTyxNQUFNLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTO1FBQzFELE1BQU0sQ0FBQyxZQUFZLEtBQUssU0FBUyxDQUFDO0FBQ3hDLENBQUM7QUFFRCxNQUFNLFVBQVUsU0FBUyxDQUFDLFFBQWdCO0lBQ3hDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLFFBQWdCO0lBQ3JELE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbkQsQ0FBQztBQUVELE1BQU0sVUFBVSxhQUFhLENBQUMsSUFBYTtJQUN6QyxJQUFJLEVBQUUsR0FBNEIsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZELElBQUksRUFBRSxLQUFLLFNBQVMsRUFBRTtRQUNwQixFQUFFLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztLQUMvQztJ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Q0FBQztBQUM5RixDQUFDO0FBd0JEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLHdCQUF3QixDQUFDLEVBQWlCO0lBQ3hELE1BQU0sWUFBWSxHQUFJLEVBQTJCLENBQUMsWUFBWSxDQUFDO0lBQy9ELElBQUksWUFBWSxLQUFLLFNBQVMsRUFBRTtRQUM5QixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBQ0QsT0FBTyxZQUFZLENBQUMsWUFBWSxDQUFDO0FBQ25DLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuY29uc3QgVFMgPSAvXFwudHN4PyQvaTtcbmNvbnN0IERfVFMgPSAvXFwuZFxcLnRzJC9pO1xuXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7QWJzb2x1dGVGc1BhdGgsIGdldEZpbGVTeXN0ZW19IGZyb20gJy4uLy4uL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7RGVjbGFyYXRpb25Ob2RlfSBmcm9tICcuLi8uLi9yZWZsZWN0aW9uJztcblxuLyoqXG4gKiBUeXBlIGRlc2NyaWJpbmcgYSBzeW1ib2wgdGhhdCBpcyBndWFyYW50ZWVkIHRvIGhhdmUgYSB2YWx1ZSBkZWNsYXJhdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgU3ltYm9sV2l0aFZhbHVlRGVjbGFyYXRpb24gPSB0cy5TeW1ib2wme1xuICB2YWx1ZURlY2xhcmF0aW9uOiB0cy5EZWNsYXJhdGlvbjtcbiAgZGVjbGFyYXRpb25zOiB0cy5EZWNsYXJhdGlvbltdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3ltYm9sV2l0aFZhbHVlRGVjbGFyYXRpb24oc3ltYm9sOiB0cy5TeW1ib2x8bnVsbHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCk6IHN5bWJvbCBpcyBTeW1ib2xXaXRoVmFsdWVEZWNsYXJhdGlvbiB7XG4gIC8vIElmIHRoZXJlIGlzIGEgdmFsdWUgZGVjbGFyYXRpb24gc2V0LCB0aGVuIHRoZSBgZGVjbGFyYXRpb25zYCBwcm9wZXJ0eSBpcyBuZXZlciB1bmRlZmluZWQuIFdlXG4gIC8vIHN0aWxsIGNoZWNrIGZvciB0aGUgcHJvcGVydHkgdG8gZXhpc3QgYXMgdGhpcyBtYXRjaGVzIHdpdGggdGhlIHR5cGUgdGhhdCBgc3ltYm9sYCBpcyBuYXJyb3dlZFxuICAvLyB0by5cbiAgcmV0dXJuIHN5bWJvbCAhPSBudWxsICYmIHN5bWJvbC52YWx1ZURlY2xhcmF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHN5bWJvbC5kZWNsYXJhdGlvbnMgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHRzUGF0aChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBEX1RTLnRlc3QoZmlsZVBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb25EZWNsYXJhdGlvblRzUGF0aChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBUUy50ZXN0KGZpbGVQYXRoKSAmJiAhRF9UUy50ZXN0KGZpbGVQYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnJvbUR0c0ZpbGUobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICBsZXQgc2Y6IHRzLlNvdXJjZUZpbGV8dW5kZWZpbmVkID0gbm9kZS5nZXRTb3VyY2VGaWxlKCk7XG4gIGlmIChzZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2YgPSB0cy5nZXRPcmlnaW5hbE5vZGUobm9kZSkuZ2V0U291cmNlRmlsZSgpO1xuICB9XG4gIHJldHVybiBzZiAhPT0gdW5kZWZpbmVkICYmIHNmLmlzRGVjbGFyYXRpb25GaWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZU5hbWVGb3JFcnJvcihub2RlOiB0cy5Ob2RlJntuYW1lPzogdHMuTm9kZX0pOiBzdHJpbmcge1xuICBpZiAobm9kZS5uYW1lICE9PSB1bmRlZmluZWQgJiYgdHMuaXNJZGVudGlmaWVyKG5vZGUubmFtZSkpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lLnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qga2luZCA9IHRzLlN5bnRheEtpbmRbbm9kZS5raW5kXTtcbiAgICBjb25zdCB7bGluZSwgY2hhcmFjdGVyfSA9XG4gICAgICAgIHRzLmdldExpbmVBbmRDaGFyYWN0ZXJPZlBvc2l0aW9uKG5vZGUuZ2V0U291cmNlRmlsZSgpLCBub2RlLmdldFN0YXJ0KCkpO1xuICAgIHJldHVybiBgJHtraW5kfUAke2xpbmV9OiR7Y2hhcmFjdGVyfWA7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvdXJjZUZpbGUobm9kZTogdHMuTm9kZSk6IHRzLlNvdXJjZUZpbGUge1xuICAvLyBJbiBjZXJ0YWluIHRyYW5zZm9ybWF0aW9uIGNvbnRleHRzLCBgdHMuTm9kZS5nZXRTb3VyY2VGaWxlKClgIGNhbiBhY3R1YWxseSByZXR1cm4gYHVuZGVmaW5lZGAsXG4gIC8vIGRlc3BpdGUgdGhlIHR5cGUgc2lnbmF0dXJlIG5vdCBhbGxvd2luZyBpdC4gSW4gdGhhdCBldmVudCwgZ2V0IHRoZSBgdHMuU291cmNlRmlsZWAgdmlhIHRoZVxuICAvLyBvcmlnaW5hbCBub2RlIGluc3RlYWQgKHdoaWNoIHdvcmtzKS5cbiAgY29uc3QgZGlyZWN0U2YgPSBub2RlLmdldFNvdXJjZUZpbGUoKSBhcyB0cy5Tb3VyY2VGaWxlIHwgdW5kZWZpbmVkO1xuICByZXR1cm4gZGlyZWN0U2YgIT09IHVuZGVmaW5lZCA/IGRpcmVjdFNmIDogdHMuZ2V0T3JpZ2luYWxOb2RlKG5vZGUpLmdldFNvdXJjZUZpbGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvdXJjZUZpbGVPck51bGwocHJvZ3JhbTogdHMuUHJvZ3JhbSwgZmlsZU5hbWU6IEFic29sdXRlRnNQYXRoKTogdHMuU291cmNlRmlsZXxcbiAgICBudWxsIHtcbiAgcmV0dXJuIHByb2dyYW0uZ2V0U291cmNlRmlsZShmaWxlTmFtZSkgfHwgbnVsbDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5BdFBvc2l0aW9uKHNmOiB0cy5Tb3VyY2VGaWxlLCBwb3M6IG51bWJlcik6IHRzLk5vZGUge1xuICAvLyBnZXRUb2tlbkF0UG9zaXRpb24gaXMgcGFydCBvZiBUeXBlU2NyaXB0J3MgcHJpdmF0ZSBBUEkuXG4gIHJldHVybiAodHMgYXMgYW55KS5nZXRUb2tlbkF0UG9zaXRpb24oc2YsIHBvcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmaWVyT2ZOb2RlKGRlY2w6IHRzLk5vZGUme25hbWU/OiB0cy5Ob2RlfSk6IHRzLklkZW50aWZpZXJ8bnVsbCB7XG4gIGlmIChkZWNsLm5hbWUgIT09IHVuZGVmaW5lZCAmJiB0cy5pc0lkZW50aWZpZXIoZGVjbC5uYW1lKSkge1xuICAgIHJldHVybiBkZWNsLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVjbGFyYXRpb24obm9kZTogdHMuTm9kZSk6IG5vZGUgaXMgdHMuRGVjbGFyYXRpb24ge1xuICByZXR1cm4gaXNWYWx1ZURlY2xhcmF0aW9uKG5vZGUpIHx8IGlzVHlwZURlY2xhcmF0aW9uKG5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWx1ZURlY2xhcmF0aW9uKG5vZGU6IHRzLk5vZGUpOiBub2RlIGlzIHRzLkNsYXNzRGVjbGFyYXRpb258XG4gICAgdHMuRnVuY3Rpb25EZWNsYXJhdGlvbnx0cy5WYXJpYWJsZURlY2xhcmF0aW9uIHtcbiAgcmV0dXJuIHRzLmlzQ2xhc3NEZWNsYXJhdGlvbihub2RlKSB8fCB0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkgfHxcbiAgICAgIHRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZURlY2xhcmF0aW9uKG5vZGU6IHRzLk5vZGUpOiBub2RlIGlzIHRzLkVudW1EZWNsYXJhdGlvbnxcbiAgICB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbnx0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiB7XG4gIHJldHVybiB0cy5pc0VudW1EZWNsYXJhdGlvbihub2RlKSB8fCB0cy5pc1R5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUpIHx8XG4gICAgICB0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lZERlY2xhcmF0aW9uKG5vZGU6IHRzLk5vZGUpOiBub2RlIGlzIHRzLkRlY2xhcmF0aW9uJntuYW1lOiB0cy5JZGVudGlmaWVyfSB7XG4gIGNvbnN0IG5hbWVkTm9kZSA9IG5vZGUgYXMge25hbWU/OiB0cy5JZGVudGlmaWVyfTtcbiAgcmV0dXJuIG5hbWVkTm9kZS5uYW1lICE9PSB1bmRlZmluZWQgJiYgdHMuaXNJZGVudGlmaWVyKG5hbWVkTm9kZS5uYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXhwb3J0ZWQobm9kZTogRGVjbGFyYXRpb25Ob2RlKTogYm9vbGVhbiB7XG4gIGxldCB0b3BMZXZlbDogdHMuTm9kZSA9IG5vZGU7XG4gIGlmICh0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSkgJiYgdHMuaXNWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChub2RlLnBhcmVudCkpIHtcbiAgICB0b3BMZXZlbCA9IG5vZGUucGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gdG9wTGV2ZWwubW9kaWZpZXJzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHRvcExldmVsLm1vZGlmaWVycy5zb21lKG1vZGlmaWVyID0+IG1vZGlmaWVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRXhwb3J0S2V5d29yZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290RGlycyhcbiAgICBob3N0OiBQaWNrPHRzLkNvbXBpbGVySG9zdCwgJ2dldEN1cnJlbnREaXJlY3RvcnknfCdnZXRDYW5vbmljYWxGaWxlTmFtZSc+LFxuICAgIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyk6IEFic29sdXRlRnNQYXRoW10ge1xuICBjb25zdCByb290RGlyczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgY3dkID0gaG9zdC5nZXRDdXJyZW50RGlyZWN0b3J5KCk7XG4gIGNvbnN0IGZzID0gZ2V0RmlsZVN5c3RlbSgpO1xuICBpZiAob3B0aW9ucy5yb290RGlycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm9vdERpcnMucHVzaCguLi5vcHRpb25zLnJvb3REaXJzKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnJvb3REaXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJvb3REaXJzLnB1c2gob3B0aW9ucy5yb290RGlyKTtcbiAgfSBlbHNlIHtcbiAgICByb290RGlycy5wdXNoKGN3ZCk7XG4gIH1cblxuICAvLyBJbiBXaW5kb3dzIHRoZSBhYm92ZSBtaWdodCBub3QgYWx3YXlzIHJldHVybiBwb3NpeCBzZXBhcmF0ZWQgcGF0aHNcbiAgLy8gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvYmxvYi8zZjczNTdkMzdmNjZjODQyZDcwZDgzNWJjOTI1ZWMyYTg3M2VjZmVjL3NyYy9jb21waWxlci9zeXMudHMjTDY1MFxuICAvLyBBbHNvIGNvbXBpbGVyIG9wdGlvbnMgbWlnaHQgYmUgc2V0IHZpYSBhbiBBUEkgd2hpY2ggZG9lc24ndCBub3JtYWxpemUgcGF0aHNcbiAgcmV0dXJuIHJvb3REaXJzLm1hcChyb290RGlyID0+IGZzLnJlc29sdmUoY3dkLCBob3N0LmdldENhbm9uaWNhbEZpbGVOYW1lKHJvb3REaXIpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlRGVidWdJbmZvKG5vZGU6IHRzLk5vZGUpOiBzdHJpbmcge1xuICBjb25zdCBzZiA9IGdldFNvdXJjZUZpbGUobm9kZSk7XG4gIGNvbnN0IHtsaW5lLCBjaGFyYWN0ZXJ9ID0gdHMuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oc2YsIG5vZGUucG9zKTtcbiAgcmV0dXJuIGBbJHtzZi5maWxlTmFtZX06ICR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfSBAICR7bGluZX06JHtjaGFyYWN0ZXJ9XWA7XG59XG5cbi8qKlxuICogUmVzb2x2ZSB0aGUgc3BlY2lmaWVkIGBtb2R1bGVOYW1lYCB1c2luZyB0aGUgZ2l2ZW4gYGNvbXBpbGVyT3B0aW9uc2AgYW5kIGBjb21waWxlckhvc3RgLlxuICpcbiAqIFRoaXMgaGVscGVyIHdpbGwgYXR0ZW1wdCB0byB1c2UgdGhlIGBDb21waWxlckhvc3QucmVzb2x2ZU1vZHVsZU5hbWVzKClgIG1ldGhvZCBpZiBhdmFpbGFibGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCBmYWxsYmFjayBvbiB0aGUgYHRzLlJlc29sdmVNb2R1bGVOYW1lKClgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZU5hbWUoXG4gICAgbW9kdWxlTmFtZTogc3RyaW5nLCBjb250YWluaW5nRmlsZTogc3RyaW5nLCBjb21waWxlck9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyxcbiAgICBjb21waWxlckhvc3Q6IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0JlBpY2s8dHMuQ29tcGlsZXJIb3N0LCAncmVzb2x2ZU1vZHVsZU5hbWVzJz4sXG4gICAgbW9kdWxlUmVzb2x1dGlvbkNhY2hlOiB0cy5Nb2R1bGVSZXNvbHV0aW9uQ2FjaGV8bnVsbCk6IHRzLlJlc29sdmVkTW9kdWxlfHVuZGVmaW5lZCB7XG4gIGlmIChjb21waWxlckhvc3QucmVzb2x2ZU1vZHVsZU5hbWVzKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVySG9zdC5yZXNvbHZlTW9kdWxlTmFtZXMoXG4gICAgICAgIFttb2R1bGVOYW1lXSwgY29udGFpbmluZ0ZpbGUsXG4gICAgICAgIHVuZGVmaW5lZCwgIC8vIHJldXNlZE5hbWVzXG4gICAgICAgIHVuZGVmaW5lZCwgIC8vIHJlZGlyZWN0ZWRSZWZlcmVuY2VcbiAgICAgICAgY29tcGlsZXJPcHRpb25zKVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHNcbiAgICAgICAgLnJlc29sdmVNb2R1bGVOYW1lKFxuICAgICAgICAgICAgbW9kdWxlTmFtZSwgY29udGFpbmluZ0ZpbGUsIGNvbXBpbGVyT3B0aW9ucywgY29tcGlsZXJIb3N0LFxuICAgICAgICAgICAgbW9kdWxlUmVzb2x1dGlvbkNhY2hlICE9PSBudWxsID8gbW9kdWxlUmVzb2x1dGlvbkNhY2hlIDogdW5kZWZpbmVkKVxuICAgICAgICAucmVzb2x2ZWRNb2R1bGU7XG4gIH1cbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3NpZ25tZW50KG5vZGU6IHRzLk5vZGUpOiBub2RlIGlzIHRzLkJpbmFyeUV4cHJlc3Npb24ge1xuICByZXR1cm4gdHMuaXNCaW5hcnlFeHByZXNzaW9uKG5vZGUpICYmIG5vZGUub3BlcmF0b3JUb2tlbi5raW5kID09PSB0cy5TeW50YXhLaW5kLkVxdWFsc1Rva2VuO1xufVxuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUga2V5cyBgS2AgZm9ybSBhIHN1YnNldCBvZiB0aGUga2V5cyBvZiBgVGAuXG4gKi9cbmV4cG9ydCB0eXBlIFN1YnNldE9mS2V5czxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBLO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHR5cGUgYFRgLCB3aXRoIGEgdHJhbnNmb3JtYXRpb24gYXBwbGllZCB0aGF0IHR1cm5zIGFsbCBtZXRob2RzIChldmVuIG9wdGlvbmFsXG4gKiBvbmVzKSBpbnRvIHJlcXVpcmVkIGZpZWxkcyAod2hpY2ggbWF5IGJlIGB1bmRlZmluZWRgLCBpZiB0aGUgbWV0aG9kIHdhcyBvcHRpb25hbCkuXG4gKi9cbmV4cG9ydCB0eXBlIFJlcXVpcmVkRGVsZWdhdGlvbnM8VD4gPSB7XG4gIFtNIGluIGtleW9mIFJlcXVpcmVkPFQ+XTogVFtNXTtcbn07XG5cbi8qKlxuICogU291cmNlIGZpbGVzIG1heSBiZWNvbWUgcmVkaXJlY3RzIHRvIG90aGVyIHNvdXJjZSBmaWxlcyB3aGVuIHRoZWlyIHBhY2thZ2UgbmFtZSBhbmQgdmVyc2lvbiBhcmVcbiAqIGlkZW50aWNhbC4gVHlwZVNjcmlwdCBjcmVhdGVzIGEgcHJveHkgc291cmNlIGZpbGUgZm9yIHN1Y2ggc291cmNlIGZpbGVzIHdoaWNoIGhhcyBhbiBpbnRlcm5hbFxuICogYHJlZGlyZWN0SW5mb2AgcHJvcGVydHkgdGhhdCByZWZlcnMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLlxuICovXG5pbnRlcmZhY2UgUmVkaXJlY3RlZFNvdXJjZUZpbGUgZXh0ZW5kcyB0cy5Tb3VyY2VGaWxlIHtcbiAgcmVkaXJlY3RJbmZvPzoge3VucmVkaXJlY3RlZDogdHMuU291cmNlRmlsZTt9O1xufVxuXG4vKipcbiAqIE9idGFpbnMgdGhlIG5vbi1yZWRpcmVjdGVkIHNvdXJjZSBmaWxlIGZvciBgc2ZgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VbnJlZGlyZWN0ZWRTb3VyY2VGaWxlKHNmOiB0cy5Tb3VyY2VGaWxlKTogdHMuU291cmNlRmlsZSB7XG4gIGNvbnN0IHJlZGlyZWN0SW5mbyA9IChzZiBhcyBSZWRpcmVjdGVkU291cmNlRmlsZSkucmVkaXJlY3RJbmZvO1xuICBpZiAocmVkaXJlY3RJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2Y7XG4gIH1cbiAgcmV0dXJuIHJlZGlyZWN0SW5mby51bnJlZGlyZWN0ZWQ7XG59XG4iXX0=