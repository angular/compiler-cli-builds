/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
import { getTokenAtPosition } from '../../util/src/typescript';
import { hasIgnoreForDiagnosticsMarker, readSpanComment } from './comments';
import { checkIfClassIsExported } from './ts_util';
import { TypeParameterEmitter } from './type_parameter_emitter';
/**
 * Indicates whether a particular component requires an inline type check block.
 *
 * This is not a boolean state as inlining might only be required to get the best possible
 * type-checking, but the component could theoretically still be checked without it.
 */
export var TcbInliningRequirement;
(function (TcbInliningRequirement) {
    /**
     * There is no way to type check this component without inlining.
     */
    TcbInliningRequirement[TcbInliningRequirement["MustInline"] = 0] = "MustInline";
    /**
     * Inlining should be used due to the component's generic bounds, but a non-inlining fallback
     * method can be used if that's not possible.
     */
    TcbInliningRequirement[TcbInliningRequirement["ShouldInlineForGenericBounds"] = 1] = "ShouldInlineForGenericBounds";
    /**
     * There is no requirement for this component's TCB to be inlined.
     */
    TcbInliningRequirement[TcbInliningRequirement["None"] = 2] = "None";
})(TcbInliningRequirement || (TcbInliningRequirement = {}));
export function requiresInlineTypeCheckBlock(node, usedPipes, reflector) {
    // In order to qualify for a declared TCB (not inline) two conditions must be met:
    // 1) the class must be exported
    // 2) it must not have contextual generic type bounds
    if (!checkIfClassIsExported(node)) {
        // Condition 1 is false, the class is not exported.
        return TcbInliningRequirement.MustInline;
    }
    else if (!checkIfGenericTypeBoundsAreContextFree(node, reflector)) {
        // Condition 2 is false, the class has constrained generic types. It should be checked with an
        // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.
        return TcbInliningRequirement.ShouldInlineForGenericBounds;
    }
    else if (Array.from(usedPipes.values())
        .some(pipeRef => !checkIfClassIsExported(pipeRef.node))) {
        // If one of the pipes used by the component is not exported, a non-inline TCB will not be able
        // to import it, so this requires an inline TCB.
        return TcbInliningRequirement.MustInline;
    }
    else {
        return TcbInliningRequirement.None;
    }
}
/** Maps a shim position back to a template location. */
export function getTemplateMapping(shimSf, position, resolver, isDiagnosticRequest) {
    const node = getTokenAtPosition(shimSf, position);
    const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);
    if (sourceLocation === null) {
        return null;
    }
    const mapping = resolver.getSourceMapping(sourceLocation.id);
    const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);
    if (span === null) {
        return null;
    }
    // TODO(atscott): Consider adding a context span by walking up from `node` until we get a
    // different span.
    return { sourceLocation, templateSourceMapping: mapping, span };
}
export function findTypeCheckBlock(file, id, isDiagnosticRequest) {
    for (const stmt of file.statements) {
        if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file, isDiagnosticRequest) === id) {
            return stmt;
        }
    }
    return null;
}
/**
 * Traverses up the AST starting from the given node to extract the source location from comments
 * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore
 * marker comment is found up the tree (and this is part of a diagnostic request), this function
 * returns null.
 */
export function findSourceLocation(node, sourceFile, isDiagnosticsRequest) {
    // Search for comments until the TCB's function declaration is encountered.
    while (node !== undefined && !ts.isFunctionDeclaration(node)) {
        if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {
            // There's an ignore marker on this node, so the diagnostic should not be reported.
            return null;
        }
        const span = readSpanComment(node, sourceFile);
        if (span !== null) {
            // Once the positional information has been extracted, search further up the TCB to extract
            // the unique id that is attached with the TCB's function declaration.
            const id = getTemplateId(node, sourceFile, isDiagnosticsRequest);
            if (id === null) {
                return null;
            }
            return { id, span };
        }
        node = node.parent;
    }
    return null;
}
function getTemplateId(node, sourceFile, isDiagnosticRequest) {
    // Walk up to the function declaration of the TCB, the file information is attached there.
    while (!ts.isFunctionDeclaration(node)) {
        if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {
            // There's an ignore marker on this node, so the diagnostic should not be reported.
            return null;
        }
        node = node.parent;
        // Bail once we have reached the root.
        if (node === undefined) {
            return null;
        }
    }
    const start = node.getFullStart();
    return ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {
        if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
            return null;
        }
        const commentText = sourceFile.text.substring(pos + 2, end - 2);
        return commentText;
    }) || null;
}
export function checkIfGenericTypeBoundsAreContextFree(node, reflector) {
    // Generic type parameters are considered context free if they can be emitted into any context.
    return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGNiX3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvc3JjL25ndHNjL3R5cGVjaGVjay9zcmMvdGNiX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBSUgsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFHakMsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFHN0QsT0FBTyxFQUFDLDZCQUE2QixFQUFFLGVBQWUsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUMxRSxPQUFPLEVBQUMsc0JBQXNCLEVBQWdDLE1BQU0sV0FBVyxDQUFDO0FBQ2hGLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBdUI5RDs7Ozs7R0FLRztBQUNILE1BQU0sQ0FBTixJQUFZLHNCQWdCWDtBQWhCRCxXQUFZLHNCQUFzQjtJQUNoQzs7T0FFRztJQUNILCtFQUFVLENBQUE7SUFFVjs7O09BR0c7SUFDSCxtSEFBNEIsQ0FBQTtJQUU1Qjs7T0FFRztJQUNILG1FQUFJLENBQUE7QUFDTixDQUFDLEVBaEJXLHNCQUFzQixLQUF0QixzQkFBc0IsUUFnQmpDO0FBRUQsTUFBTSxVQUFVLDRCQUE0QixDQUN4QyxJQUEyQyxFQUMzQyxTQUF3RSxFQUN4RSxTQUF5QjtJQUMzQixrRkFBa0Y7SUFDbEYsZ0NBQWdDO0lBQ2hDLHFEQUFxRDtJQUNyRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDakMsbURBQW1EO1FBQ25ELE9BQU8sc0JBQXNCLENBQUMsVUFBVSxDQUFDO0tBQzFDO1NBQU0sSUFBSSxDQUFDLHNDQUFzQyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsRUFBRTtRQUNuRSw4RkFBOEY7UUFDOUYsc0ZBQXNGO1FBQ3RGLE9BQU8sc0JBQXNCLENBQUMsNEJBQTRCLENB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QUUsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN0QyxJQUFJLDZCQUE2QixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxtQkFBbUIsRUFBRTtZQUMxRSxtRkFBbUY7WUFDbkYsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBRW5CLHNDQUFzQztRQUN0QyxJQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUM7U0FDYjtLQUNGO0lBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ2xDLE9BQU8sRUFBRSxDQUFDLDBCQUEwQixDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUM5RSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQixFQUFFO1lBQ2pELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNoRSxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDLENBQWUsSUFBSSxJQUFJLENBQUM7QUFDM0IsQ0FBQztBQUVELE1BQU0sVUFBVSxzQ0FBc0MsQ0FDbEQsSUFBMkMsRUFBRSxTQUF5QjtJQUN4RSwrRkFBK0Y7SUFDL0YsT0FBTyxJQUFJLG9CQUFvQixDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsU0FBUyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDNUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0Fic29sdXRlU291cmNlU3BhbiwgUGFyc2VTb3VyY2VTcGFufSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQge0NsYXNzRGVjbGFyYXRpb24sIFJlZmxlY3Rpb25Ib3N0fSBmcm9tICdAYW5ndWxhci9jb21waWxlci1jbGkvc3JjL25ndHNjL3JlZmxlY3Rpb24nO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7UmVmZXJlbmNlfSBmcm9tICcuLi8uLi9pbXBvcnRzJztcbmltcG9ydCB7Z2V0VG9rZW5BdFBvc2l0aW9ufSBmcm9tICcuLi8uLi91dGlsL3NyYy90eXBlc2NyaXB0JztcbmltcG9ydCB7RnVsbFRlbXBsYXRlTWFwcGluZywgU291cmNlTG9jYXRpb24sIFRlbXBsYXRlSWQsIFRlbXBsYXRlU291cmNlTWFwcGluZ30gZnJvbSAnLi4vYXBpJztcblxuaW1wb3J0IHtoYXNJZ25vcmVGb3JEaWFnbm9zdGljc01hcmtlciwgcmVhZFNwYW5Db21tZW50fSBmcm9tICcuL2NvbW1lbnRzJztcbmltcG9ydCB7Y2hlY2tJZkNsYXNzSXNFeHBvcnRlZCwgY2hlY2tJZkdlbmVyaWNUeXBlc0FyZVVuYm91bmR9IGZyb20gJy4vdHNfdXRpbCc7XG5pbXBvcnQge1R5cGVQYXJhbWV0ZXJFbWl0dGVyfSBmcm9tICcuL3R5cGVfcGFyYW1ldGVyX2VtaXR0ZXInO1xuXG4vKipcbiAqIEFkYXB0ZXIgaW50ZXJmYWNlIHdoaWNoIGFsbG93cyB0aGUgdGVtcGxhdGUgdHlwZS1jaGVja2luZyBkaWFnbm9zdGljcyBjb2RlIHRvIGludGVycHJldCBvZmZzZXRzXG4gKiBpbiBhIFRDQiBhbmQgbWFwIHRoZW0gYmFjayB0byBvcmlnaW5hbCBsb2NhdGlvbnMgaW4gdGhlIHRlbXBsYXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlU291cmNlUmVzb2x2ZXIge1xuICBnZXRUZW1wbGF0ZUlkKG5vZGU6IHRzLkNsYXNzRGVjbGFyYXRpb24pOiBUZW1wbGF0ZUlkO1xuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIHRlbXBsYXRlIGlkLCByZXRyaWV2ZSB0aGUgb3JpZ2luYWwgc291cmNlIG1hcHBpbmcgd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgb2Zmc2V0c1xuICAgKiBpbiB0aGUgdGVtcGxhdGUgc2hvdWxkIGJlIGludGVycHJldGVkLlxuICAgKi9cbiAgZ2V0U291cmNlTWFwcGluZyhpZDogVGVtcGxhdGVJZCk6IFRlbXBsYXRlU291cmNlTWFwcGluZztcblxuICAvKipcbiAgICogQ29udmVydCBhbiBhYnNvbHV0ZSBzb3VyY2Ugc3BhbiBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRlbXBsYXRlIGlkIGludG8gYSBmdWxsXG4gICAqIGBQYXJzZVNvdXJjZVNwYW5gLiBUaGUgcmV0dXJuZWQgcGFyc2Ugc3BhbiBoYXMgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgaW4gYWRkaXRpb24gdG8gb25seVxuICAgKiBhYnNvbHV0ZSBvZmZzZXRzIGFuZCBnaXZlcyBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHNvdXJjZS5cbiAgICovXG4gIHRvUGFyc2VTb3VyY2VTcGFuKGlkOiBUZW1wbGF0ZUlkLCBzcGFuOiBBYnNvbHV0ZVNvdXJjZVNwYW4pOiBQYXJzZVNvdXJjZVNwYW58bnVsbDtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciBhIHBhcnRpY3VsYXIgY29tcG9uZW50IHJlcXVpcmVzIGFuIGlubGluZSB0eXBlIGNoZWNrIGJsb2NrLlxuICpcbiAqIFRoaXMgaXMgbm90IGEgYm9vbGVhbiBzdGF0ZSBhcyBpbmxpbmluZyBtaWdodCBvbmx5IGJlIHJlcXVpcmVkIHRvIGdldCB0aGUgYmVzdCBwb3NzaWJsZVxuICogdHlwZS1jaGVja2luZywgYnV0IHRoZSBjb21wb25lbnQgY291bGQgdGhlb3JldGljYWxseSBzdGlsbCBiZSBjaGVja2VkIHdpdGhvdXQgaXQuXG4gKi9cbmV4cG9ydCBlbnVtIFRjYklubGluaW5nUmVxdWlyZW1lbnQge1xuICAvKipcbiAgICogVGhlcmUgaXMgbm8gd2F5IHRvIHR5cGUgY2hlY2sgdGhpcyBjb21wb25lbnQgd2l0aG91dCBpbmxpbmluZy5cbiAgICovXG4gIE11c3RJbmxpbmUsXG5cbiAgLyoqXG4gICAqIElubGluaW5nIHNob3VsZCBiZSB1c2VkIGR1ZSB0byB0aGUgY29tcG9uZW50J3MgZ2VuZXJpYyBib3VuZHMsIGJ1dCBhIG5vbi1pbmxpbmluZyBmYWxsYmFja1xuICAgKiBtZXRob2QgY2FuIGJlIHVzZWQgaWYgdGhhdCdzIG5vdCBwb3NzaWJsZS5cbiAgICovXG4gIFNob3VsZElubGluZUZvckdlbmVyaWNCb3VuZHMsXG5cbiAgLyoqXG4gICAqIFRoZXJlIGlzIG5vIHJlcXVpcmVtZW50IGZvciB0aGlzIGNvbXBvbmVudCdzIFRDQiB0byBiZSBpbmxpbmVkLlxuICAgKi9cbiAgTm9uZSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVzSW5saW5lVHlwZUNoZWNrQmxvY2soXG4gICAgbm9kZTogQ2xhc3NEZWNsYXJhdGlvbjx0cy5DbGFzc0RlY2xhcmF0aW9uPixcbiAgICB1c2VkUGlwZXM6IE1hcDxzdHJpbmcsIFJlZmVyZW5jZTxDbGFzc0RlY2xhcmF0aW9uPHRzLkNsYXNzRGVjbGFyYXRpb24+Pj4sXG4gICAgcmVmbGVjdG9yOiBSZWZsZWN0aW9uSG9zdCk6IFRjYklubGluaW5nUmVxdWlyZW1lbnQge1xuICAvLyBJbiBvcmRlciB0byBxdWFsaWZ5IGZvciBhIGRlY2xhcmVkIFRDQiAobm90IGlubGluZSkgdHdvIGNvbmRpdGlvbnMgbXVzdCBiZSBtZXQ6XG4gIC8vIDEpIHRoZSBjbGFzcyBtdXN0IGJlIGV4cG9ydGVkXG4gIC8vIDIpIGl0IG11c3Qgbm90IGhhdmUgY29udGV4dHVhbCBnZW5lcmljIHR5cGUgYm91bmRzXG4gIGlmICghY2hlY2tJZkNsYXNzSXNFeHBvcnRlZChub2RlKSkge1xuICAgIC8vIENvbmRpdGlvbiAxIGlzIGZhbHNlLCB0aGUgY2xhc3MgaXMgbm90IGV4cG9ydGVkLlxuICAgIHJldHVybiBUY2JJbmxpbmluZ1JlcXVpcmVtZW50Lk11c3RJbmxpbmU7XG4gIH0gZWxzZSBpZiAoIWNoZWNrSWZHZW5lcmljVHlwZUJvdW5kc0FyZUNvbnRleHRGcmVlKG5vZGUsIHJlZmxlY3RvcikpIHtcbiAgICAvLyBDb25kaXRpb24gMiBpcyBmYWxzZSwgdGhlIGNsYXNzIGhhcyBjb25zdHJhaW5lZCBnZW5lcmljIHR5cGVzLiBJdCBzaG91bGQgYmUgY2hlY2tlZCB3aXRoIGFuXG4gICAgLy8gaW5saW5lIFRDQiBpZiBwb3NzaWJsZSwgYnV0IGNhbiBwb3RlbnRpYWxseSB1c2UgZmFsbGJhY2tzIHRvIGF2b2lkIGlubGluaW5nIGlmIG5vdC5cbiAgICByZXR1cm4gVGNiSW5saW5pbmdSZXF1aXJlbWVudC5TaG91bGRJbmxpbmVGb3JHZW5lcmljQm91bmRzO1xuICB9IGVsc2UgaWYgKEFycmF5LmZyb20odXNlZFBpcGVzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgICAuc29tZShwaXBlUmVmID0+ICFjaGVja0lmQ2xhc3NJc0V4cG9ydGVkKHBpcGVSZWYubm9kZSkpKSB7XG4gICAgLy8gSWYgb25lIG9mIHRoZSBwaXBlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQgaXMgbm90IGV4cG9ydGVkLCBhIG5vbi1pbmxpbmUgVENCIHdpbGwgbm90IGJlIGFibGVcbiAgICAvLyB0byBpbXBvcnQgaXQsIHNvIHRoaXMgcmVxdWlyZXMgYW4gaW5saW5lIFRDQi5cbiAgICByZXR1cm4gVGNiSW5saW5pbmdSZXF1aXJlbWVudC5NdXN0SW5saW5lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBUY2JJbmxpbmluZ1JlcXVpcmVtZW50Lk5vbmU7XG4gIH1cbn1cblxuLyoqIE1hcHMgYSBzaGltIHBvc2l0aW9uIGJhY2sgdG8gYSB0ZW1wbGF0ZSBsb2NhdGlvbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZW1wbGF0ZU1hcHBpbmcoXG4gICAgc2hpbVNmOiB0cy5Tb3VyY2VGaWxlLCBwb3NpdGlvbjogbnVtYmVyLCByZXNvbHZlcjogVGVtcGxhdGVTb3VyY2VSZXNvbHZlcixcbiAgICBpc0RpYWdub3N0aWNSZXF1ZXN0OiBib29sZWFuKTogRnVsbFRlbXBsYXRlTWFwcGluZ3xudWxsIHtcbiAgY29uc3Qgbm9kZSA9IGdldFRva2VuQXRQb3NpdGlvbihzaGltU2YsIHBvc2l0aW9uKTtcbiAgY29uc3Qgc291cmNlTG9jYXRpb24gPSBmaW5kU291cmNlTG9jYXRpb24obm9kZSwgc2hpbVNmLCBpc0RpYWdub3N0aWNSZXF1ZXN0KTtcbiAgaWYgKHNvdXJjZUxvY2F0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtYXBwaW5nID0gcmVzb2x2ZXIuZ2V0U291cmNlTWFwcGluZyhzb3VyY2VMb2NhdGlvbi5pZCk7XG4gIGNvbnN0IHNwYW4gPSByZXNvbHZlci50b1BhcnNlU291cmNlU3Bhbihzb3VyY2VMb2NhdGlvbi5pZCwgc291cmNlTG9jYXRpb24uc3Bhbik7XG4gIGlmIChzcGFuID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVE9ETyhhdHNjb3R0KTogQ29uc2lkZXIgYWRkaW5nIGEgY29udGV4dCBzcGFuIGJ5IHdhbGtpbmcgdXAgZnJvbSBgbm9kZWAgdW50aWwgd2UgZ2V0IGFcbiAgLy8gZGlmZmVyZW50IHNwYW4uXG4gIHJldHVybiB7c291cmNlTG9jYXRpb24sIHRlbXBsYXRlU291cmNlTWFwcGluZzogbWFwcGluZywgc3Bhbn07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVHlwZUNoZWNrQmxvY2soXG4gICAgZmlsZTogdHMuU291cmNlRmlsZSwgaWQ6IFRlbXBsYXRlSWQsIGlzRGlhZ25vc3RpY1JlcXVlc3Q6IGJvb2xlYW4pOiB0cy5Ob2RlfG51bGwge1xuICBmb3IgKGNvbnN0IHN0bXQgb2YgZmlsZS5zdGF0ZW1lbnRzKSB7XG4gICAgaWYgKHRzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbihzdG10KSAmJiBnZXRUZW1wbGF0ZUlkKHN0bXQsIGZpbGUsIGlzRGlhZ25vc3RpY1JlcXVlc3QpID09PSBpZCkge1xuICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB1cCB0aGUgQVNUIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIG5vZGUgdG8gZXh0cmFjdCB0aGUgc291cmNlIGxvY2F0aW9uIGZyb20gY29tbWVudHNcbiAqIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgaW50byB0aGUgVENCLiBJZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdCB3aXRoaW4gYSBUQ0IsIG9yIGlmIGFuIGlnbm9yZVxuICogbWFya2VyIGNvbW1lbnQgaXMgZm91bmQgdXAgdGhlIHRyZWUgKGFuZCB0aGlzIGlzIHBhcnQgb2YgYSBkaWFnbm9zdGljIHJlcXVlc3QpLCB0aGlzIGZ1bmN0aW9uXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kU291cmNlTG9jYXRpb24oXG4gICAgbm9kZTogdHMuTm9kZSwgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgaXNEaWFnbm9zdGljc1JlcXVlc3Q6IGJvb2xlYW4pOiBTb3VyY2VMb2NhdGlvbnxudWxsIHtcbiAgLy8gU2VhcmNoIGZvciBjb21tZW50cyB1bnRpbCB0aGUgVENCJ3MgZnVuY3Rpb24gZGVjbGFyYXRpb24gaXMgZW5jb3VudGVyZWQuXG4gIHdoaWxlIChub2RlICE9PSB1bmRlZmluZWQgJiYgIXRzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSkge1xuICAgIGlmIChoYXNJZ25vcmVGb3JEaWFnbm9zdGljc01hcmtlcihub2RlLCBzb3VyY2VGaWxlKSAmJiBpc0RpYWdub3N0aWNzUmVxdWVzdCkge1xuICAgICAgLy8gVGhlcmUncyBhbiBpZ25vcmUgbWFya2VyIG9uIHRoaXMgbm9kZSwgc28gdGhlIGRpYWdub3N0aWMgc2hvdWxkIG5vdCBiZSByZXBvcnRlZC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHNwYW4gPSByZWFkU3BhbkNvbW1lbnQobm9kZSwgc291cmNlRmlsZSk7XG4gICAgaWYgKHNwYW4gIT09IG51bGwpIHtcbiAgICAgIC8vIE9uY2UgdGhlIHBvc2l0aW9uYWwgaW5mb3JtYXRpb24gaGFzIGJlZW4gZXh0cmFjdGVkLCBzZWFyY2ggZnVydGhlciB1cCB0aGUgVENCIHRvIGV4dHJhY3RcbiAgICAgIC8vIHRoZSB1bmlxdWUgaWQgdGhhdCBpcyBhdHRhY2hlZCB3aXRoIHRoZSBUQ0IncyBmdW5jdGlvbiBkZWNsYXJhdGlvbi5cbiAgICAgIGNvbnN0IGlkID0gZ2V0VGVtcGxhdGVJZChub2RlLCBzb3VyY2VGaWxlLCBpc0RpYWdub3N0aWNzUmVxdWVzdCk7XG4gICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge2lkLCBzcGFufTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGVtcGxhdGVJZChcbiAgICBub2RlOiB0cy5Ob2RlLCBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlLCBpc0RpYWdub3N0aWNSZXF1ZXN0OiBib29sZWFuKTogVGVtcGxhdGVJZHxudWxsIHtcbiAgLy8gV2FsayB1cCB0byB0aGUgZnVuY3Rpb24gZGVjbGFyYXRpb24gb2YgdGhlIFRDQiwgdGhlIGZpbGUgaW5mb3JtYXRpb24gaXMgYXR0YWNoZWQgdGhlcmUuXG4gIHdoaWxlICghdHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgaWYgKGhhc0lnbm9yZUZvckRpYWdub3N0aWNzTWFya2VyKG5vZGUsIHNvdXJjZUZpbGUpICYmIGlzRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICAgIC8vIFRoZXJlJ3MgYW4gaWdub3JlIG1hcmtlciBvbiB0aGlzIG5vZGUsIHNvIHRoZSBkaWFnbm9zdGljIHNob3VsZCBub3QgYmUgcmVwb3J0ZWQuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuXG4gICAgLy8gQmFpbCBvbmNlIHdlIGhhdmUgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGFydCA9IG5vZGUuZ2V0RnVsbFN0YXJ0KCk7XG4gIHJldHVybiB0cy5mb3JFYWNoTGVhZGluZ0NvbW1lbnRSYW5nZShzb3VyY2VGaWxlLnRleHQsIHN0YXJ0LCAocG9zLCBlbmQsIGtpbmQpID0+IHtcbiAgICBpZiAoa2luZCAhPT0gdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29tbWVudFRleHQgPSBzb3VyY2VGaWxlLnRleHQuc3Vic3RyaW5nKHBvcyArIDIsIGVuZCAtIDIpO1xuICAgIHJldHVybiBjb21tZW50VGV4dDtcbiAgfSkgYXMgVGVtcGxhdGVJZCB8fCBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZkdlbmVyaWNUeXBlQm91bmRzQXJlQ29udGV4dEZyZWUoXG4gICAgbm9kZTogQ2xhc3NEZWNsYXJhdGlvbjx0cy5DbGFzc0RlY2xhcmF0aW9uPiwgcmVmbGVjdG9yOiBSZWZsZWN0aW9uSG9zdCk6IGJvb2xlYW4ge1xuICAvLyBHZW5lcmljIHR5cGUgcGFyYW1ldGVycyBhcmUgY29uc2lkZXJlZCBjb250ZXh0IGZyZWUgaWYgdGhleSBjYW4gYmUgZW1pdHRlZCBpbnRvIGFueSBjb250ZXh0LlxuICByZXR1cm4gbmV3IFR5cGVQYXJhbWV0ZXJFbWl0dGVyKG5vZGUudHlwZVBhcmFtZXRlcnMsIHJlZmxlY3RvcikuY2FuRW1pdCgpO1xufVxuIl19