/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
import { ErrorCode, makeDiagnostic, makeRelatedInformation, ngErrorCode } from '../../diagnostics';
import { makeTemplateDiagnostic } from '../diagnostics';
export class OutOfBandDiagnosticRecorderImpl {
    constructor(resolver) {
        this.resolver = resolver;
        this._diagnostics = [];
        /**
         * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic
         * is ever produced per node.
         */
        this.recordedPipes = new Set();
    }
    get diagnostics() {
        return this._diagnostics;
    }
    missingReferenceTarget(templateId, ref) {
        const mapping = this.resolver.getSourceMapping(templateId);
        const value = ref.value.trim();
        const errorMsg = `No directive found with exportAs '${value}'.`;
        this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));
    }
    missingPipe(templateId, ast) {
        if (this.recordedPipes.has(ast)) {
            return;
        }
        const mapping = this.resolver.getSourceMapping(templateId);
        const errorMsg = `No pipe found with name '${ast.name}'.`;
        const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);
        }
        this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));
        this.recordedPipes.add(ast);
    }
    illegalAssignmentToTemplateVar(templateId, assignment, target) {
        const mapping = this.resolver.getSourceMapping(templateId);
        const errorMsg = `Cannot use variable '${assignment
            .name}' as the left-hand side of an assignment expression. Template variables are read-only.`;
        const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);
        if (sourceSpan === null) {
            throw new Error(`Assertion failure: no SourceLocation found for property binding.`);
        }
        this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, {
            text: `The variable ${assignment.name} is declared here.`,
            span: target.valueSpan || target.sourceSpan,
        }));
    }
    duplicateTemplateVar(templateId, variable, firstDecl) {
        const mapping = this.resolver.getSourceMapping(templateId);
        const errorMsg = `Cannot redeclare variable '${variable.name}' as it was previously declared elsewhere for the same template.`;
        // The allocation of the error here is pretty useless for variables declared in microsyntax,
        // since the sourceSpan refers to the entire microsyntax property, not a span for the specific
        // variable in question.
        //
        // TODO(alxhub): allocate to a tighter span once one is available.
        this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, {
            text: `The variable '${firstDecl.name}' was first declared here.`,
            span: firstDecl.sourceSpan,
        }));
    }
    requiresInlineTcb(templateId, node) {
        this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name, `This component requires inline template type-checking, which is not supported by the current environment.`));
    }
    requiresInlineTypeConstructors(templateId, node, directives) {
        let message;
        if (directives.length > 1) {
            message =
                `This component uses directives which require inline type constructors, which are not supported by the current environment.`;
        }
        else {
            message =
                `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;
        }
        this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map(dir => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));
    }
    suboptimalTypeInference(templateId, variables) {
        const mapping = this.resolver.getSourceMapping(templateId);
        // Select one of the template variables that's most suitable for reporting the diagnostic. Any
        // variable will do, but prefer one bound to the context's $implicit if present.
        let diagnosticVar = null;
        for (const variable of variables) {
            if (diagnosticVar === null || (variable.value === '' || variable.value === '$implicit')) {
                diagnosticVar = variable;
            }
        }
        if (diagnosticVar === null) {
            // There is no variable on which to report the diagnostic.
            return;
        }
        let varIdentification = `'${diagnosticVar.name}'`;
        if (variables.length === 2) {
            varIdentification += ` (and 1 other)`;
        }
        else if (variables.length > 2) {
            varIdentification += ` (and ${variables.length - 1} others)`;
        }
        const message = `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${varIdentification} will have type 'any' as a result.\n\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;
        this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, diagnosticVar.keySpan, ts.DiagnosticCategory.Suggestion, ngErrorCode(ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));
    }
}
function makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {
    return Object.assign(Object.assign({}, makeDiagnostic(code, node, messageText, relatedInformation)), { componentFile: node.getSourceFile(), templateId });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib29iLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL3NyYy9uZ3RzYy90eXBlY2hlY2svc3JjL29vYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFHSCxPQUFPLEtBQUssRUFBRSxNQUFNLFlBQVksQ0FBQztBQUVqQyxPQUFPLEVBQUMsU0FBUyxFQUFFLGNBQWMsRUFBRSxzQkFBc0IsRUFBRSxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUdqRyxPQUFPLEVBQUMsc0JBQXNCLEVBQXFCLE1BQU0sZ0JBQWdCLENBQUM7QUFnRTFFLE1BQU0sT0FBTywrQkFBK0I7SUFTMUMsWUFBb0IsUUFBZ0M7UUFBaEMsYUFBUSxHQUFSLFFBQVEsQ0FBd0I7UUFSNUMsaUJBQVksR0FBeUIsRUFBRSxDQUFDO1FBRWhEOzs7V0FHRztRQUNLLGtCQUFhLEdBQUcsSUFBSSxHQUFHLEVBQWUsQ0FBQztJQUVRLENBQUM7SUFFeEQsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzNCLENBQUM7SUFFRCxzQkFBc0IsQ0FBQyxVQUFzQixFQUFFLEdBQXFCO1FBQ2xFLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDM0QsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUUvQixNQUFNLFFBQVEsR0FBRyxxQ0FBcUMsS0FBSyxJQUFJLENBQUM7UUFDaEUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQ3pDLFVBQVUsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLFNBQVMsSUFBSSxHQUFHLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQ2pGLFdBQVcsQ0FBQyxT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QUN2RixhQUFhLEdBQUcsUUFBUSxDQUFDO2FBQzFCO1NBQ0Y7UUFDRCxJQUFJLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDMUIsMERBQTBEO1lBQzFELE9BQU87U0FDUjtRQUVELElBQUksaUJBQWlCLEdBQUcsSUFBSSxhQUFhLENBQUMsSUFBSSxHQUFHLENBQUM7UUFDbEQsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQixpQkFBaUIsSUFBSSxnQkFBZ0IsQ0FBQztTQUN2QzthQUFNLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDL0IsaUJBQWlCLElBQUksU0FBUyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsVUFBVSxDQUFDO1NBQzlEO1FBQ0QsTUFBTSxPQUFPLEdBQ1QsdUlBQ0ksaUJBQWlCLDRKQUE0SixDQUFDO1FBRXRMLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUN6QyxVQUFVLEVBQUUsT0FBTyxFQUFFLGFBQWEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsRUFDNUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxpQ0FBaUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDMUUsQ0FBQztDQUNGO0FBRUQsU0FBUyxvQkFBb0IsQ0FDekIsVUFBc0IsRUFBRSxJQUF1RSxFQUMvRixJQUFhLEVBQUUsV0FBNkMsRUFDNUQsa0JBQXNEO0lBQ3hELHVDQUNLLGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxrQkFBa0IsQ0FBQyxLQUM5RCxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUNuQyxVQUFVLElBQ1Y7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7QmluZGluZ1BpcGUsIFByb3BlcnR5V3JpdGUsIFRtcGxBc3RSZWZlcmVuY2UsIFRtcGxBc3RWYXJpYWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7RXJyb3JDb2RlLCBtYWtlRGlhZ25vc3RpYywgbWFrZVJlbGF0ZWRJbmZvcm1hdGlvbiwgbmdFcnJvckNvZGV9IGZyb20gJy4uLy4uL2RpYWdub3N0aWNzJztcbmltcG9ydCB7Q2xhc3NEZWNsYXJhdGlvbn0gZnJvbSAnLi4vLi4vcmVmbGVjdGlvbic7XG5pbXBvcnQge1RlbXBsYXRlSWR9IGZyb20gJy4uL2FwaSc7XG5pbXBvcnQge21ha2VUZW1wbGF0ZURpYWdub3N0aWMsIFRlbXBsYXRlRGlhZ25vc3RpY30gZnJvbSAnLi4vZGlhZ25vc3RpY3MnO1xuXG5pbXBvcnQge1RlbXBsYXRlU291cmNlUmVzb2x2ZXJ9IGZyb20gJy4vdGNiX3V0aWwnO1xuXG5cblxuLyoqXG4gKiBDb2xsZWN0cyBgdHMuRGlhZ25vc3RpY2BzIG9uIHByb2JsZW1zIHdoaWNoIG9jY3VyIGluIHRoZSB0ZW1wbGF0ZSB3aGljaCBhcmVuJ3QgZGlyZWN0bHkgc291cmNlZFxuICogZnJvbSBUeXBlIENoZWNrIEJsb2Nrcy5cbiAqXG4gKiBEdXJpbmcgdGhlIGNyZWF0aW9uIG9mIGEgVHlwZSBDaGVjayBCbG9jaywgdGhlIHRlbXBsYXRlIGlzIHRyYXZlcnNlZCBhbmQgdGhlXG4gKiBgT3V0T2ZCYW5kRGlhZ25vc3RpY1JlY29yZGVyYCBpcyBjYWxsZWQgdG8gcmVjb3JkIGNhc2VzIHdoZW4gYSBjb3JyZWN0IGludGVycHJldGF0aW9uIGZvciB0aGVcbiAqIHRlbXBsYXRlIGNhbm5vdCBiZSBmb3VuZC4gVGhlc2Ugb3BlcmF0aW9ucyBjcmVhdGUgYHRzLkRpYWdub3N0aWNgcyB3aGljaCBhcmUgc3RvcmVkIGJ5IHRoZVxuICogcmVjb3JkZXIgZm9yIGxhdGVyIGRpc3BsYXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3V0T2ZCYW5kRGlhZ25vc3RpY1JlY29yZGVyIHtcbiAgcmVhZG9ubHkgZGlhZ25vc3RpY3M6IFJlYWRvbmx5QXJyYXk8VGVtcGxhdGVEaWFnbm9zdGljPjtcblxuICAvKipcbiAgICogUmVwb3J0cyBhIGAjcmVmPVwidGFyZ2V0XCJgIGV4cHJlc3Npb24gaW4gdGhlIHRlbXBsYXRlIGZvciB3aGljaCBhIHRhcmdldCBkaXJlY3RpdmUgY291bGQgbm90IGJlXG4gICAqIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gdGVtcGxhdGVJZCB0aGUgdGVtcGxhdGUgdHlwZS1jaGVja2luZyBJRCBvZiB0aGUgdGVtcGxhdGUgd2hpY2ggY29udGFpbnMgdGhlIGJyb2tlblxuICAgKiByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSByZWYgdGhlIGBUbXBsQXN0UmVmZXJlbmNlYCB3aGljaCBjb3VsZCBub3QgYmUgbWF0Y2hlZCB0byBhIGRpcmVjdGl2ZS5cbiAgICovXG4gIG1pc3NpbmdSZWZlcmVuY2VUYXJnZXQodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgcmVmOiBUbXBsQXN0UmVmZXJlbmNlKTogdm9pZDtcblxuICAvKipcbiAgICogUmVwb3J0cyB1c2FnZSBvZiBhIGB8IHBpcGVgIGV4cHJlc3Npb24gaW4gdGhlIHRlbXBsYXRlIGZvciB3aGljaCB0aGUgbmFtZWQgcGlwZSBjb3VsZCBub3QgYmVcbiAgICogZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZUlkIHRoZSB0ZW1wbGF0ZSB0eXBlLWNoZWNraW5nIElEIG9mIHRoZSB0ZW1wbGF0ZSB3aGljaCBjb250YWlucyB0aGUgdW5rbm93blxuICAgKiBwaXBlLlxuICAgKiBAcGFyYW0gYXN0IHRoZSBgQmluZGluZ1BpcGVgIGludm9jYXRpb24gb2YgdGhlIHBpcGUgd2hpY2ggY291bGQgbm90IGJlIGZvdW5kLlxuICAgKi9cbiAgbWlzc2luZ1BpcGUodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgYXN0OiBCaW5kaW5nUGlwZSk6IHZvaWQ7XG5cbiAgaWxsZWdhbEFzc2lnbm1lbnRUb1RlbXBsYXRlVmFyKFxuICAgICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgYXNzaWdubWVudDogUHJvcGVydHlXcml0ZSwgdGFyZ2V0OiBUbXBsQXN0VmFyaWFibGUpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXBvcnRzIGEgZHVwbGljYXRlIGRlY2xhcmF0aW9uIG9mIGEgdGVtcGxhdGUgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZUlkIHRoZSB0ZW1wbGF0ZSB0eXBlLWNoZWNraW5nIElEIG9mIHRoZSB0ZW1wbGF0ZSB3aGljaCBjb250YWlucyB0aGUgZHVwbGljYXRlXG4gICAqIGRlY2xhcmF0aW9uLlxuICAgKiBAcGFyYW0gdmFyaWFibGUgdGhlIGBUbXBsQXN0VmFyaWFibGVgIHdoaWNoIGR1cGxpY2F0ZXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0gZmlyc3REZWNsIHRoZSBmaXJzdCB2YXJpYWJsZSBkZWNsYXJhdGlvbiB3aGljaCB1c2VzIHRoZSBzYW1lIG5hbWUgYXMgYHZhcmlhYmxlYC5cbiAgICovXG4gIGR1cGxpY2F0ZVRlbXBsYXRlVmFyKFxuICAgICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgdmFyaWFibGU6IFRtcGxBc3RWYXJpYWJsZSwgZmlyc3REZWNsOiBUbXBsQXN0VmFyaWFibGUpOiB2b2lkO1xuXG4gIHJlcXVpcmVzSW5saW5lVGNiKHRlbXBsYXRlSWQ6IFRlbXBsYXRlSWQsIG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkO1xuXG4gIHJlcXVpcmVzSW5saW5lVHlwZUNvbnN0cnVjdG9ycyhcbiAgICAgIHRlbXBsYXRlSWQ6IFRlbXBsYXRlSWQsIG5vZGU6IENsYXNzRGVjbGFyYXRpb24sIGRpcmVjdGl2ZXM6IENsYXNzRGVjbGFyYXRpb25bXSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlcG9ydCBhIHdhcm5pbmcgd2hlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgc3VwcG9ydCBjb250ZXh0IGd1YXJkcywgYnV0IHRoZSBjdXJyZW50XG4gICAqIHR5cGUtY2hlY2tpbmcgY29uZmlndXJhdGlvbiBwcm9oaWJpdHMgdGhlaXIgdXNhZ2UuXG4gICAqL1xuICBzdWJvcHRpbWFsVHlwZUluZmVyZW5jZSh0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCB2YXJpYWJsZXM6IFRtcGxBc3RWYXJpYWJsZVtdKTogdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIE91dE9mQmFuZERpYWdub3N0aWNSZWNvcmRlckltcGwgaW1wbGVtZW50cyBPdXRPZkJhbmREaWFnbm9zdGljUmVjb3JkZXIge1xuICBwcml2YXRlIF9kaWFnbm9zdGljczogVGVtcGxhdGVEaWFnbm9zdGljW10gPSBbXTtcblxuICAvKipcbiAgICogVHJhY2tzIHdoaWNoIGBCaW5kaW5nUGlwZWAgbm9kZXMgaGF2ZSBhbHJlYWR5IGJlZW4gcmVjb3JkZWQgYXMgaW52YWxpZCwgc28gb25seSBvbmUgZGlhZ25vc3RpY1xuICAgKiBpcyBldmVyIHByb2R1Y2VkIHBlciBub2RlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWNvcmRlZFBpcGVzID0gbmV3IFNldDxCaW5kaW5nUGlwZT4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlc29sdmVyOiBUZW1wbGF0ZVNvdXJjZVJlc29sdmVyKSB7fVxuXG4gIGdldCBkaWFnbm9zdGljcygpOiBSZWFkb25seUFycmF5PFRlbXBsYXRlRGlhZ25vc3RpYz4ge1xuICAgIHJldHVybiB0aGlzLl9kaWFnbm9zdGljcztcbiAgfVxuXG4gIG1pc3NpbmdSZWZlcmVuY2VUYXJnZXQodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgcmVmOiBUbXBsQXN0UmVmZXJlbmNlKTogdm9pZCB7XG4gICAgY29uc3QgbWFwcGluZyA9IHRoaXMucmVzb2x2ZXIuZ2V0U291cmNlTWFwcGluZyh0ZW1wbGF0ZUlkKTtcbiAgICBjb25zdCB2YWx1ZSA9IHJlZi52YWx1ZS50cmltKCk7XG5cbiAgICBjb25zdCBlcnJvck1zZyA9IGBObyBkaXJlY3RpdmUgZm91bmQgd2l0aCBleHBvcnRBcyAnJHt2YWx1ZX0nLmA7XG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlVGVtcGxhdGVEaWFnbm9zdGljKFxuICAgICAgICB0ZW1wbGF0ZUlkLCBtYXBwaW5nLCByZWYudmFsdWVTcGFuIHx8IHJlZi5zb3VyY2VTcGFuLCB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgICAgIG5nRXJyb3JDb2RlKEVycm9yQ29kZS5NSVNTSU5HX1JFRkVSRU5DRV9UQVJHRVQpLCBlcnJvck1zZykpO1xuICB9XG5cbiAgbWlzc2luZ1BpcGUodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgYXN0OiBCaW5kaW5nUGlwZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlY29yZGVkUGlwZXMuaGFzKGFzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5yZXNvbHZlci5nZXRTb3VyY2VNYXBwaW5nKHRlbXBsYXRlSWQpO1xuICAgIGNvbnN0IGVycm9yTXNnID0gYE5vIHBpcGUgZm91bmQgd2l0aCBuYW1lICcke2FzdC5uYW1lfScuYDtcblxuICAgIGNvbnN0IHNvdXJjZVNwYW4gPSB0aGlzLnJlc29sdmVyLnRvUGFyc2VTb3VyY2VTcGFuKHRlbXBsYXRlSWQsIGFzdC5uYW1lU3Bhbik7XG4gICAgaWYgKHNvdXJjZVNwYW4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQXNzZXJ0aW9uIGZhaWx1cmU6IG5vIFNvdXJjZUxvY2F0aW9uIGZvdW5kIGZvciB1c2FnZSBvZiBwaXBlICcke2FzdC5uYW1lfScuYCk7XG4gICAgfVxuICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2gobWFrZVRlbXBsYXRlRGlhZ25vc3RpYyhcbiAgICAgICAgdGVtcGxhdGVJZCwgbWFwcGluZywgc291cmNlU3BhbiwgdHMuRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yLFxuICAgICAgICBuZ0Vycm9yQ29kZShFcnJvckNvZGUuTUlTU0lOR19QSVBFKSwgZXJyb3JNc2cpKTtcbiAgICB0aGlzLnJlY29yZGVkUGlwZXMuYWRkKGFzdCk7XG4gIH1cblxuICBpbGxlZ2FsQXNzaWdubWVudFRvVGVtcGxhdGVWYXIoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCBhc3NpZ25tZW50OiBQcm9wZXJ0eVdyaXRlLCB0YXJnZXQ6IFRtcGxBc3RWYXJpYWJsZSk6IHZvaWQge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnJlc29sdmVyLmdldFNvdXJjZU1hcHBpbmcodGVtcGxhdGVJZCk7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBgQ2Fubm90IHVzZSB2YXJpYWJsZSAnJHtcbiAgICAgICAgYXNzaWdubWVudFxuICAgICAgICAgICAgLm5hbWV9JyBhcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUZW1wbGF0ZSB2YXJpYWJsZXMgYXJlIHJlYWQtb25seS5gO1xuXG4gICAgY29uc3Qgc291cmNlU3BhbiA9IHRoaXMucmVzb2x2ZXIudG9QYXJzZVNvdXJjZVNwYW4odGVtcGxhdGVJZCwgYXNzaWdubWVudC5zb3VyY2VTcGFuKTtcbiAgICBpZiAoc291cmNlU3BhbiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZmFpbHVyZTogbm8gU291cmNlTG9jYXRpb24gZm91bmQgZm9yIHByb3BlcnR5IGJpbmRpbmcuYCk7XG4gICAgfVxuICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2gobWFrZVRlbXBsYXRlRGlhZ25vc3RpYyhcbiAgICAgICAgdGVtcGxhdGVJZCwgbWFwcGluZywgc291cmNlU3BhbiwgdHMuRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yLFxuICAgICAgICBuZ0Vycm9yQ29kZShFcnJvckNvZGUuV1JJVEVfVE9fUkVBRF9PTkxZX1ZBUklBQkxFKSwgZXJyb3JNc2csIHtcbiAgICAgICAgICB0ZXh0OiBgVGhlIHZhcmlhYmxlICR7YXNzaWdubWVudC5uYW1lfSBpcyBkZWNsYXJlZCBoZXJlLmAsXG4gICAgICAgICAgc3BhbjogdGFyZ2V0LnZhbHVlU3BhbiB8fCB0YXJnZXQuc291cmNlU3BhbixcbiAgICAgICAgfSkpO1xuICB9XG5cbiAgZHVwbGljYXRlVGVtcGxhdGVWYXIoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCB2YXJpYWJsZTogVG1wbEFzdFZhcmlhYmxlLCBmaXJzdERlY2w6IFRtcGxBc3RWYXJpYWJsZSk6IHZvaWQge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnJlc29sdmVyLmdldFNvdXJjZU1hcHBpbmcodGVtcGxhdGVJZCk7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBgQ2Fubm90IHJlZGVjbGFyZSB2YXJpYWJsZSAnJHtcbiAgICAgICAgdmFyaWFibGUubmFtZX0nIGFzIGl0IHdhcyBwcmV2aW91c2x5IGRlY2xhcmVkIGVsc2V3aGVyZSBmb3IgdGhlIHNhbWUgdGVtcGxhdGUuYDtcblxuICAgIC8vIFRoZSBhbGxvY2F0aW9uIG9mIHRoZSBlcnJvciBoZXJlIGlzIHByZXR0eSB1c2VsZXNzIGZvciB2YXJpYWJsZXMgZGVjbGFyZWQgaW4gbWljcm9zeW50YXgsXG4gICAgLy8gc2luY2UgdGhlIHNvdXJjZVNwYW4gcmVmZXJzIHRvIHRoZSBlbnRpcmUgbWljcm9zeW50YXggcHJvcGVydHksIG5vdCBhIHNwYW4gZm9yIHRoZSBzcGVjaWZpY1xuICAgIC8vIHZhcmlhYmxlIGluIHF1ZXN0aW9uLlxuICAgIC8vXG4gICAgLy8gVE9ETyhhbHhodWIpOiBhbGxvY2F0ZSB0byBhIHRpZ2h0ZXIgc3BhbiBvbmNlIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlVGVtcGxhdGVEaWFnbm9zdGljKFxuICAgICAgICB0ZW1wbGF0ZUlkLCBtYXBwaW5nLCB2YXJpYWJsZS5zb3VyY2VTcGFuLCB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgICAgIG5nRXJyb3JDb2RlKEVycm9yQ29kZS5EVVBMSUNBVEVfVkFSSUFCTEVfREVDTEFSQVRJT04pLCBlcnJvck1zZywge1xuICAgICAgICAgIHRleHQ6IGBUaGUgdmFyaWFibGUgJyR7Zmlyc3REZWNsLm5hbWV9JyB3YXMgZmlyc3QgZGVjbGFyZWQgaGVyZS5gLFxuICAgICAgICAgIHNwYW46IGZpcnN0RGVjbC5zb3VyY2VTcGFuLFxuICAgICAgICB9KSk7XG4gIH1cblxuICByZXF1aXJlc0lubGluZVRjYih0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCBub2RlOiBDbGFzc0RlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlSW5saW5lRGlhZ25vc3RpYyhcbiAgICAgICAgdGVtcGxhdGVJZCwgRXJyb3JDb2RlLklOTElORV9UQ0JfUkVRVUlSRUQsIG5vZGUubmFtZSxcbiAgICAgICAgYFRoaXMgY29tcG9uZW50IHJlcXVpcmVzIGlubGluZSB0ZW1wbGF0ZSB0eXBlLWNoZWNraW5nLCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGVudmlyb25tZW50LmApKTtcbiAgfVxuXG4gIHJlcXVpcmVzSW5saW5lVHlwZUNvbnN0cnVjdG9ycyhcbiAgICAgIHRlbXBsYXRlSWQ6IFRlbXBsYXRlSWQsIG5vZGU6IENsYXNzRGVjbGFyYXRpb24sIGRpcmVjdGl2ZXM6IENsYXNzRGVjbGFyYXRpb25bXSk6IHZvaWQge1xuICAgIGxldCBtZXNzYWdlOiBzdHJpbmc7XG4gICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoID4gMSkge1xuICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgYFRoaXMgY29tcG9uZW50IHVzZXMgZGlyZWN0aXZlcyB3aGljaCByZXF1aXJlIGlubGluZSB0eXBlIGNvbnN0cnVjdG9ycywgd2hpY2ggYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuYDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgYFRoaXMgY29tcG9uZW50IHVzZXMgYSBkaXJlY3RpdmUgd2hpY2ggcmVxdWlyZXMgYW4gaW5saW5lIHR5cGUgY29uc3RydWN0b3IsIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuYDtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKG1ha2VJbmxpbmVEaWFnbm9zdGljKFxuICAgICAgICB0ZW1wbGF0ZUlkLCBFcnJvckNvZGUuSU5MSU5FX1RZUEVfQ1RPUl9SRVFVSVJFRCwgbm9kZS5uYW1lLCBtZXNzYWdlLFxuICAgICAgICBkaXJlY3RpdmVzLm1hcChcbiAgICAgICAgICAgIGRpciA9PiBtYWtlUmVsYXRlZEluZm9ybWF0aW9uKGRpci5uYW1lLCBgUmVxdWlyZXMgYW4gaW5saW5lIHR5cGUgY29uc3RydWN0b3IuYCkpKSk7XG4gIH1cblxuICBzdWJvcHRpbWFsVHlwZUluZmVyZW5jZSh0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCB2YXJpYWJsZXM6IFRtcGxBc3RWYXJpYWJsZVtdKTogdm9pZCB7XG4gICAgY29uc3QgbWFwcGluZyA9IHRoaXMucmVzb2x2ZXIuZ2V0U291cmNlTWFwcGluZyh0ZW1wbGF0ZUlkKTtcblxuICAgIC8vIFNlbGVjdCBvbmUgb2YgdGhlIHRlbXBsYXRlIHZhcmlhYmxlcyB0aGF0J3MgbW9zdCBzdWl0YWJsZSBmb3IgcmVwb3J0aW5nIHRoZSBkaWFnbm9zdGljLiBBbnlcbiAgICAvLyB2YXJpYWJsZSB3aWxsIGRvLCBidXQgcHJlZmVyIG9uZSBib3VuZCB0byB0aGUgY29udGV4dCdzICRpbXBsaWNpdCBpZiBwcmVzZW50LlxuICAgIGxldCBkaWFnbm9zdGljVmFyOiBUbXBsQXN0VmFyaWFibGV8bnVsbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgIGlmIChkaWFnbm9zdGljVmFyID09PSBudWxsIHx8ICh2YXJpYWJsZS52YWx1ZSA9PT0gJycgfHwgdmFyaWFibGUudmFsdWUgPT09ICckaW1wbGljaXQnKSkge1xuICAgICAgICBkaWFnbm9zdGljVmFyID0gdmFyaWFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaWFnbm9zdGljVmFyID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyB2YXJpYWJsZSBvbiB3aGljaCB0byByZXBvcnQgdGhlIGRpYWdub3N0aWMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHZhcklkZW50aWZpY2F0aW9uID0gYCcke2RpYWdub3N0aWNWYXIubmFtZX0nYDtcbiAgICBpZiAodmFyaWFibGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFySWRlbnRpZmljYXRpb24gKz0gYCAoYW5kIDEgb3RoZXIpYDtcbiAgICB9IGVsc2UgaWYgKHZhcmlhYmxlcy5sZW5ndGggPiAyKSB7XG4gICAgICB2YXJJZGVudGlmaWNhdGlvbiArPSBgIChhbmQgJHt2YXJpYWJsZXMubGVuZ3RoIC0gMX0gb3RoZXJzKWA7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICBgVGhpcyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBzdXBwb3J0cyBhZHZhbmNlZCB0eXBlIGluZmVyZW5jZSwgYnV0IHRoZSBjdXJyZW50IGNvbXBpbGVyIGNvbmZpZ3VyYXRpb24gcHJldmVudHMgaXRzIHVzYWdlLiBUaGUgdmFyaWFibGUgJHtcbiAgICAgICAgICAgIHZhcklkZW50aWZpY2F0aW9ufSB3aWxsIGhhdmUgdHlwZSAnYW55JyBhcyBhIHJlc3VsdC5cXG5cXG5Db25zaWRlciBlbmFibGluZyB0aGUgJ3N0cmljdFRlbXBsYXRlcycgb3B0aW9uIGluIHlvdXIgdHNjb25maWcuanNvbiBmb3IgYmV0dGVyIHR5cGUgaW5mZXJlbmNlIHdpdGhpbiB0aGlzIHRlbXBsYXRlLmA7XG5cbiAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKG1ha2VUZW1wbGF0ZURpYWdub3N0aWMoXG4gICAgICAgIHRlbXBsYXRlSWQsIG1hcHBpbmcsIGRpYWdub3N0aWNWYXIua2V5U3BhbiwgdHMuRGlhZ25vc3RpY0NhdGVnb3J5LlN1Z2dlc3Rpb24sXG4gICAgICAgIG5nRXJyb3JDb2RlKEVycm9yQ29kZS5TVUdHRVNUX1NVQk9QVElNQUxfVFlQRV9JTkZFUkVOQ0UpLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUlubGluZURpYWdub3N0aWMoXG4gICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgY29kZTogRXJyb3JDb2RlLklOTElORV9UQ0JfUkVRVUlSRUR8RXJyb3JDb2RlLklOTElORV9UWVBFX0NUT1JfUkVRVUlSRUQsXG4gICAgbm9kZTogdHMuTm9kZSwgbWVzc2FnZVRleHQ6IHN0cmluZ3x0cy5EaWFnbm9zdGljTWVzc2FnZUNoYWluLFxuICAgIHJlbGF0ZWRJbmZvcm1hdGlvbj86IHRzLkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb25bXSk6IFRlbXBsYXRlRGlhZ25vc3RpYyB7XG4gIHJldHVybiB7XG4gICAgLi4ubWFrZURpYWdub3N0aWMoY29kZSwgbm9kZSwgbWVzc2FnZVRleHQsIHJlbGF0ZWRJbmZvcm1hdGlvbiksXG4gICAgY29tcG9uZW50RmlsZTogbm9kZS5nZXRTb3VyY2VGaWxlKCksXG4gICAgdGVtcGxhdGVJZCxcbiAgfTtcbn1cbiJdfQ==