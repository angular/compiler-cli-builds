/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/src/ngtsc/typecheck/src/oob", ["require", "exports", "tslib", "@angular/compiler", "typescript", "@angular/compiler-cli/src/ngtsc/diagnostics", "@angular/compiler-cli/src/ngtsc/typecheck/diagnostics"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutOfBandDiagnosticRecorderImpl = void 0;
    var tslib_1 = require("tslib");
    var compiler_1 = require("@angular/compiler");
    var ts = require("typescript");
    var diagnostics_1 = require("@angular/compiler-cli/src/ngtsc/diagnostics");
    var diagnostics_2 = require("@angular/compiler-cli/src/ngtsc/typecheck/diagnostics");
    var OutOfBandDiagnosticRecorderImpl = /** @class */ (function () {
        function OutOfBandDiagnosticRecorderImpl(resolver) {
            this.resolver = resolver;
            this._diagnostics = [];
            /**
             * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic
             * is ever produced per node.
             */
            this.recordedPipes = new Set();
        }
        Object.defineProperty(OutOfBandDiagnosticRecorderImpl.prototype, "diagnostics", {
            get: function () {
                return this._diagnostics;
            },
            enumerable: false,
            configurable: true
        });
        OutOfBandDiagnosticRecorderImpl.prototype.missingReferenceTarget = function (templateId, ref) {
            var mapping = this.resolver.getSourceMapping(templateId);
            var value = ref.value.trim();
            var errorMsg = "No directive found with exportAs '" + value + "'.";
            this._diagnostics.push((0, diagnostics_2.makeTemplateDiagnostic)(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error, (0, diagnostics_1.ngErrorCode)(diagnostics_1.ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));
        };
        OutOfBandDiagnosticRecorderImpl.prototype.missingPipe = function (templateId, ast) {
            if (this.recordedPipes.has(ast)) {
                return;
            }
            var mapping = this.resolver.getSourceMapping(templateId);
            var errorMsg = "No pipe found with name '" + ast.name + "'.";
            var sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);
            if (sourceSpan === null) {
                throw new Error("Assertion failure: no SourceLocation found for usage of pipe '" + ast.name + "'.");
            }
            this._diagnostics.push((0, diagnostics_2.makeTemplateDiagnostic)(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, (0, diagnostics_1.ngErrorCode)(diagnostics_1.ErrorCode.MISSING_PIPE), errorMsg));
            this.recordedPipes.add(ast);
        };
        OutOfBandDiagnosticRecorderImpl.prototype.illegalAssignmentToTemplateVar = function (templateId, assignment, target) {
            var _a, _b;
            var mapping = this.resolver.getSourceMapping(templateId);
            var errorMsg = "Cannot use variable '" + assignment
                .name + "' as the left-hand side of an assignment expression. Template variables are read-only.";
            var sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);
            if (sourceSpan === null) {
                throw new Error("Assertion failure: no SourceLocation found for property binding.");
            }
            this._diagnostics.push((0, diagnostics_2.makeTemplateDiagnostic)(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, (0, diagnostics_1.ngErrorCode)(diagnostics_1.ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, [{
                    text: "The variable " + assignment.name + " is declared here.",
                    start: ((_a = target.valueSpan) === null || _a === void 0 ? void 0 : _a.start.offset) || target.sourceSpan.start.offset,
                    end: ((_b = target.valueSpan) === null || _b === void 0 ? void 0 : _b.end.offset) || target.sourceSpan.end.offset,
                    sourceFile: mapping.node.getSourceFile(),
                }]));
        };
        OutOfBandDiagnosticRecorderImpl.prototype.duplicateTemplateVar = function (templateId, variable, firstDecl) {
            var mapping = this.resolver.getSourceMapping(templateId);
            var errorMsg = "Cannot redeclare variable '" + variable.name + "' as it was previously declared elsewhere for the same template.";
            // The allocation of the error here is pretty useless for variables declared in microsyntax,
            // since the sourceSpan refers to the entire microsyntax property, not a span for the specific
            // variable in question.
            //
            // TODO(alxhub): allocate to a tighter span once one is available.
            this._diagnostics.push((0, diagnostics_2.makeTemplateDiagnostic)(templateId, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error, (0, diagnostics_1.ngErrorCode)(diagnostics_1.ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, [{
                    text: "The variable '" + firstDecl.name + "' was first declared here.",
                    start: firstDecl.sourceSpan.start.offset,
                    end: firstDecl.sourceSpan.end.offset,
                    sourceFile: mapping.node.getSourceFile(),
                }]));
        };
        OutOfBandDiagnosticRecorderImpl.prototype.requiresInlineTcb = function (templateId, node) {
            this._diagnostics.push(makeInlineDiagnostic(templateId, diagnostics_1.ErrorCode.INLINE_TCB_REQUIRED, node.name, "This component requires inline template type-checking, which is not supported by the current environment."));
        };
        OutOfBandDiagnosticRecorderImpl.prototype.requiresInlineTypeConstructors = function (templateId, node, directives) {
            var message;
            if (directives.length > 1) {
                message =
                    "This component uses directives which require inline type constructors, which are not supported by the current environment.";
            }
            else {
                message =
                    "This component uses a directive which requires an inline type constructor, which is not supported by the current environment.";
            }
            this._diagnostics.push(makeInlineDiagnostic(templateId, diagnostics_1.ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map(function (dir) { return (0, diagnostics_1.makeRelatedInformation)(dir.name, "Requires an inline type constructor."); })));
        };
        OutOfBandDiagnosticRecorderImpl.prototype.suboptimalTypeInference = function (templateId, variables) {
            var e_1, _a;
            var mapping = this.resolver.getSourceMapping(templateId);
            // Select one of the template variables that's most suitable for reporting the diagnostic. Any
            // variable will do, but prefer one bound to the context's $implicit if present.
            var diagnosticVar = null;
            try {
                for (var variables_1 = (0, tslib_1.__values)(variables), variables_1_1 = variables_1.next(); !variables_1_1.done; variables_1_1 = variables_1.next()) {
                    var variable = variables_1_1.value;
                    if (diagnosticVar === null || (variable.value === '' || variable.value === '$implicit')) {
                        diagnosticVar = variable;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (variables_1_1 && !variables_1_1.done && (_a = variables_1.return)) _a.call(variables_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (diagnosticVar === null) {
                // There is no variable on which to report the diagnostic.
                return;
            }
            var varIdentification = "'" + diagnosticVar.name + "'";
            if (variables.length === 2) {
                varIdentification += " (and 1 other)";
            }
            else if (variables.length > 2) {
                varIdentification += " (and " + (variables.length - 1) + " others)";
            }
            var message = "This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable " + varIdentification + " will have type 'any' as a result.\n\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.";
            this._diagnostics.push((0, diagnostics_2.makeTemplateDiagnostic)(templateId, mapping, diagnosticVar.keySpan, ts.DiagnosticCategory.Suggestion, (0, diagnostics_1.ngErrorCode)(diagnostics_1.ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));
        };
        OutOfBandDiagnosticRecorderImpl.prototype.splitTwoWayBinding = function (templateId, input, output, inputConsumer, outputConsumer) {
            var mapping = this.resolver.getSourceMapping(templateId);
            var errorMsg = "The property and event halves of the two-way binding '" + input.name + "' are not bound to the same target.\n            Find more at https://angular.io/guide/two-way-binding#how-two-way-binding-works";
            var relatedMessages = [];
            relatedMessages.push({
                text: "The property half of the binding is to the '" + inputConsumer.name.text + "' component.",
                start: inputConsumer.name.getStart(),
                end: inputConsumer.name.getEnd(),
                sourceFile: inputConsumer.name.getSourceFile(),
            });
            if (outputConsumer instanceof compiler_1.TmplAstElement) {
                var message = "The event half of the binding is to a native event called '" + input.name + "' on the <" + outputConsumer.name + "> DOM element.";
                if (!mapping.node.getSourceFile().isDeclarationFile) {
                    message += "\n \n Are you missing an output declaration called '" + output.name + "'?";
                }
                relatedMessages.push({
                    text: message,
                    start: outputConsumer.sourceSpan.start.offset + 1,
                    end: outputConsumer.sourceSpan.start.offset + outputConsumer.name.length + 1,
                    sourceFile: mapping.node.getSourceFile(),
                });
            }
            else {
                relatedMessages.push({
                    text: "The event half of the binding is to the '" + outputConsumer.name.text + "' component.",
                    start: outputConsumer.name.getStart(),
                    end: outputConsumer.name.getEnd(),
                    sourceFile: outputConsumer.name.getSourceFile(),
                });
            }
            this._diagnostics.push((0, diagnostics_2.makeTemplateDiagnostic)(templateId, mapping, input.keySpan, ts.DiagnosticCategory.Error, (0, diagnostics_1.ngErrorCode)(diagnostics_1.ErrorCode.SPLIT_TWO_WAY_BINDING), errorMsg, relatedMessages));
        };
        return OutOfBandDiagnosticRecorderImpl;
    }());
    exports.OutOfBandDiagnosticRecorderImpl = OutOfBandDiagnosticRecorderImpl;
    function makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, (0, diagnostics_1.makeDiagnostic)(code, node, messageText, relatedInformation)), { componentFile: node.getSourceFile(), templateId: templateId });
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib29iLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL3NyYy9uZ3RzYy90eXBlY2hlY2svc3JjL29vYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7O0lBRUgsOENBQW1JO0lBRW5JLCtCQUFpQztJQUVqQywyRUFBaUc7SUFHakcscUZBQXNEO0lBdUV0RDtRQVNFLHlDQUFvQixRQUFnQztZQUFoQyxhQUFRLEdBQVIsUUFBUSxDQUF3QjtZQVI1QyxpQkFBWSxHQUF5QixFQUFFLENBQUM7WUFFaEQ7OztlQUdHO1lBQ0ssa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO1FBRVEsQ0FBQztRQUV4RCxzQkFBSSx3REFBVztpQkFBZjtnQkFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDM0IsQ0FBQzs7O1dBQUE7UUFFRCxnRUFBc0IsR0FBdEIsVUFBdUIsVUFBc0IsRUFBRSxHQUFxQjtZQUNsRSxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzNELElBQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7WUFFL0IsSUFBTSxRQUFRLEdBQUcsdUNBQXFDLEtBQUssT0FBSSxDQUFDO1lBQ2hFLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUEsb0NBQXNCLEVBQ3pDLFVBQVUsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLFNBQVMsSUFBSSxHQUFHLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQ2pGLElBQUEseUJBQVcsRUFBQyx1QkFBUyxDQUFDLHdCQUF3QixDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNsRSxDQUFDO1FBRUQscURBQVcsR0FBWCxV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dCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtCaW5kaW5nUGlwZSwgUHJvcGVydHlXcml0ZSwgVG1wbEFzdEJvdW5kRXZlbnQsIFRtcGxBc3RFbGVtZW50LCBUbXBsQXN0UmVmZXJlbmNlLCBUbXBsQXN0VmFyaWFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcbmltcG9ydCB7Qm91bmRBdHRyaWJ1dGV9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9yZW5kZXIzL3IzX2FzdCc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtFcnJvckNvZGUsIG1ha2VEaWFnbm9zdGljLCBtYWtlUmVsYXRlZEluZm9ybWF0aW9uLCBuZ0Vycm9yQ29kZX0gZnJvbSAnLi4vLi4vZGlhZ25vc3RpY3MnO1xuaW1wb3J0IHtDbGFzc0RlY2xhcmF0aW9ufSBmcm9tICcuLi8uLi9yZWZsZWN0aW9uJztcbmltcG9ydCB7VGVtcGxhdGVEaWFnbm9zdGljLCBUZW1wbGF0ZUlkfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHttYWtlVGVtcGxhdGVEaWFnbm9zdGljfSBmcm9tICcuLi9kaWFnbm9zdGljcyc7XG5cbmltcG9ydCB7VGVtcGxhdGVTb3VyY2VSZXNvbHZlcn0gZnJvbSAnLi90Y2JfdXRpbCc7XG5cblxuXG4vKipcbiAqIENvbGxlY3RzIGB0cy5EaWFnbm9zdGljYHMgb24gcHJvYmxlbXMgd2hpY2ggb2NjdXIgaW4gdGhlIHRlbXBsYXRlIHdoaWNoIGFyZW4ndCBkaXJlY3RseSBzb3VyY2VkXG4gKiBmcm9tIFR5cGUgQ2hlY2sgQmxvY2tzLlxuICpcbiAqIER1cmluZyB0aGUgY3JlYXRpb24gb2YgYSBUeXBlIENoZWNrIEJsb2NrLCB0aGUgdGVtcGxhdGUgaXMgdHJhdmVyc2VkIGFuZCB0aGVcbiAqIGBPdXRPZkJhbmREaWFnbm9zdGljUmVjb3JkZXJgIGlzIGNhbGxlZCB0byByZWNvcmQgY2FzZXMgd2hlbiBhIGNvcnJlY3QgaW50ZXJwcmV0YXRpb24gZm9yIHRoZVxuICogdGVtcGxhdGUgY2Fubm90IGJlIGZvdW5kLiBUaGVzZSBvcGVyYXRpb25zIGNyZWF0ZSBgdHMuRGlhZ25vc3RpY2BzIHdoaWNoIGFyZSBzdG9yZWQgYnkgdGhlXG4gKiByZWNvcmRlciBmb3IgbGF0ZXIgZGlzcGxheS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPdXRPZkJhbmREaWFnbm9zdGljUmVjb3JkZXIge1xuICByZWFkb25seSBkaWFnbm9zdGljczogUmVhZG9ubHlBcnJheTxUZW1wbGF0ZURpYWdub3N0aWM+O1xuXG4gIC8qKlxuICAgKiBSZXBvcnRzIGEgYCNyZWY9XCJ0YXJnZXRcImAgZXhwcmVzc2lvbiBpbiB0aGUgdGVtcGxhdGUgZm9yIHdoaWNoIGEgdGFyZ2V0IGRpcmVjdGl2ZSBjb3VsZCBub3QgYmVcbiAgICogZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB0ZW1wbGF0ZUlkIHRoZSB0ZW1wbGF0ZSB0eXBlLWNoZWNraW5nIElEIG9mIHRoZSB0ZW1wbGF0ZSB3aGljaCBjb250YWlucyB0aGUgYnJva2VuXG4gICAqIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHJlZiB0aGUgYFRtcGxBc3RSZWZlcmVuY2VgIHdoaWNoIGNvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIGEgZGlyZWN0aXZlLlxuICAgKi9cbiAgbWlzc2luZ1JlZmVyZW5jZVRhcmdldCh0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCByZWY6IFRtcGxBc3RSZWZlcmVuY2UpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXBvcnRzIHVzYWdlIG9mIGEgYHwgcGlwZWAgZXhwcmVzc2lvbiBpbiB0aGUgdGVtcGxhdGUgZm9yIHdoaWNoIHRoZSBuYW1lZCBwaXBlIGNvdWxkIG5vdCBiZVxuICAgKiBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlSWQgdGhlIHRlbXBsYXRlIHR5cGUtY2hlY2tpbmcgSUQgb2YgdGhlIHRlbXBsYXRlIHdoaWNoIGNvbnRhaW5zIHRoZSB1bmtub3duXG4gICAqIHBpcGUuXG4gICAqIEBwYXJhbSBhc3QgdGhlIGBCaW5kaW5nUGlwZWAgaW52b2NhdGlvbiBvZiB0aGUgcGlwZSB3aGljaCBjb3VsZCBub3QgYmUgZm91bmQuXG4gICAqL1xuICBtaXNzaW5nUGlwZSh0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCBhc3Q6IEJpbmRpbmdQaXBlKTogdm9pZDtcblxuICBpbGxlZ2FsQXNzaWdubWVudFRvVGVtcGxhdGVWYXIoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCBhc3NpZ25tZW50OiBQcm9wZXJ0eVdyaXRlLCB0YXJnZXQ6IFRtcGxBc3RWYXJpYWJsZSk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlcG9ydHMgYSBkdXBsaWNhdGUgZGVjbGFyYXRpb24gb2YgYSB0ZW1wbGF0ZSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHRlbXBsYXRlSWQgdGhlIHRlbXBsYXRlIHR5cGUtY2hlY2tpbmcgSUQgb2YgdGhlIHRlbXBsYXRlIHdoaWNoIGNvbnRhaW5zIHRoZSBkdXBsaWNhdGVcbiAgICogZGVjbGFyYXRpb24uXG4gICAqIEBwYXJhbSB2YXJpYWJsZSB0aGUgYFRtcGxBc3RWYXJpYWJsZWAgd2hpY2ggZHVwbGljYXRlcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgdmFyaWFibGUuXG4gICAqIEBwYXJhbSBmaXJzdERlY2wgdGhlIGZpcnN0IHZhcmlhYmxlIGRlY2xhcmF0aW9uIHdoaWNoIHVzZXMgdGhlIHNhbWUgbmFtZSBhcyBgdmFyaWFibGVgLlxuICAgKi9cbiAgZHVwbGljYXRlVGVtcGxhdGVWYXIoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCB2YXJpYWJsZTogVG1wbEFzdFZhcmlhYmxlLCBmaXJzdERlY2w6IFRtcGxBc3RWYXJpYWJsZSk6IHZvaWQ7XG5cbiAgcmVxdWlyZXNJbmxpbmVUY2IodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgbm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQ7XG5cbiAgcmVxdWlyZXNJbmxpbmVUeXBlQ29uc3RydWN0b3JzKFxuICAgICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgbm9kZTogQ2xhc3NEZWNsYXJhdGlvbiwgZGlyZWN0aXZlczogQ2xhc3NEZWNsYXJhdGlvbltdKTogdm9pZDtcblxuICAvKipcbiAgICogUmVwb3J0IGEgd2FybmluZyB3aGVuIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBzdXBwb3J0IGNvbnRleHQgZ3VhcmRzLCBidXQgdGhlIGN1cnJlbnRcbiAgICogdHlwZS1jaGVja2luZyBjb25maWd1cmF0aW9uIHByb2hpYml0cyB0aGVpciB1c2FnZS5cbiAgICovXG4gIHN1Ym9wdGltYWxUeXBlSW5mZXJlbmNlKHRlbXBsYXRlSWQ6IFRlbXBsYXRlSWQsIHZhcmlhYmxlczogVG1wbEFzdFZhcmlhYmxlW10pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXBvcnRzIGEgc3BsaXQgdHdvIHdheSBiaW5kaW5nIGVycm9yIG1lc3NhZ2UuXG4gICAqL1xuICBzcGxpdFR3b1dheUJpbmRpbmcoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCBpbnB1dDogQm91bmRBdHRyaWJ1dGUsIG91dHB1dDogVG1wbEFzdEJvdW5kRXZlbnQsXG4gICAgICBpbnB1dENvbnN1bWVyOiBDbGFzc0RlY2xhcmF0aW9uLCBvdXRwdXRDb25zdW1lcjogQ2xhc3NEZWNsYXJhdGlvbnxUbXBsQXN0RWxlbWVudCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBPdXRPZkJhbmREaWFnbm9zdGljUmVjb3JkZXJJbXBsIGltcGxlbWVudHMgT3V0T2ZCYW5kRGlhZ25vc3RpY1JlY29yZGVyIHtcbiAgcHJpdmF0ZSBfZGlhZ25vc3RpY3M6IFRlbXBsYXRlRGlhZ25vc3RpY1tdID0gW107XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB3aGljaCBgQmluZGluZ1BpcGVgIG5vZGVzIGhhdmUgYWxyZWFkeSBiZWVuIHJlY29yZGVkIGFzIGludmFsaWQsIHNvIG9ubHkgb25lIGRpYWdub3N0aWNcbiAgICogaXMgZXZlciBwcm9kdWNlZCBwZXIgbm9kZS5cbiAgICovXG4gIHByaXZhdGUgcmVjb3JkZWRQaXBlcyA9IG5ldyBTZXQ8QmluZGluZ1BpcGU+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZXNvbHZlcjogVGVtcGxhdGVTb3VyY2VSZXNvbHZlcikge31cblxuICBnZXQgZGlhZ25vc3RpY3MoKTogUmVhZG9ubHlBcnJheTxUZW1wbGF0ZURpYWdub3N0aWM+IHtcbiAgICByZXR1cm4gdGhpcy5fZGlhZ25vc3RpY3M7XG4gIH1cblxuICBtaXNzaW5nUmVmZXJlbmNlVGFyZ2V0KHRlbXBsYXRlSWQ6IFRlbXBsYXRlSWQsIHJlZjogVG1wbEFzdFJlZmVyZW5jZSk6IHZvaWQge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnJlc29sdmVyLmdldFNvdXJjZU1hcHBpbmcodGVtcGxhdGVJZCk7XG4gICAgY29uc3QgdmFsdWUgPSByZWYudmFsdWUudHJpbSgpO1xuXG4gICAgY29uc3QgZXJyb3JNc2cgPSBgTm8gZGlyZWN0aXZlIGZvdW5kIHdpdGggZXhwb3J0QXMgJyR7dmFsdWV9Jy5gO1xuICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2gobWFrZVRlbXBsYXRlRGlhZ25vc3RpYyhcbiAgICAgICAgdGVtcGxhdGVJZCwgbWFwcGluZywgcmVmLnZhbHVlU3BhbiB8fCByZWYuc291cmNlU3BhbiwgdHMuRGlhZ25vc3RpY0NhdGVnb3J5LkVycm9yLFxuICAgICAgICBuZ0Vycm9yQ29kZShFcnJvckNvZGUuTUlTU0lOR19SRUZFUkVOQ0VfVEFSR0VUKSwgZXJyb3JNc2cpKTtcbiAgfVxuXG4gIG1pc3NpbmdQaXBlKHRlbXBsYXRlSWQ6IFRlbXBsYXRlSWQsIGFzdDogQmluZGluZ1BpcGUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yZWNvcmRlZFBpcGVzLmhhcyhhc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWFwcGluZyA9IHRoaXMucmVzb2x2ZXIuZ2V0U291cmNlTWFwcGluZyh0ZW1wbGF0ZUlkKTtcbiAgICBjb25zdCBlcnJvck1zZyA9IGBObyBwaXBlIGZvdW5kIHdpdGggbmFtZSAnJHthc3QubmFtZX0nLmA7XG5cbiAgICBjb25zdCBzb3VyY2VTcGFuID0gdGhpcy5yZXNvbHZlci50b1BhcnNlU291cmNlU3Bhbih0ZW1wbGF0ZUlkLCBhc3QubmFtZVNwYW4pO1xuICAgIGlmIChzb3VyY2VTcGFuID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEFzc2VydGlvbiBmYWlsdXJlOiBubyBTb3VyY2VMb2NhdGlvbiBmb3VuZCBmb3IgdXNhZ2Ugb2YgcGlwZSAnJHthc3QubmFtZX0nLmApO1xuICAgIH1cbiAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKG1ha2VUZW1wbGF0ZURpYWdub3N0aWMoXG4gICAgICAgIHRlbXBsYXRlSWQsIG1hcHBpbmcsIHNvdXJjZVNwYW4sIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvcixcbiAgICAgICAgbmdFcnJvckNvZGUoRXJyb3JDb2RlLk1JU1NJTkdfUElQRSksIGVycm9yTXNnKSk7XG4gICAgdGhpcy5yZWNvcmRlZFBpcGVzLmFkZChhc3QpO1xuICB9XG5cbiAgaWxsZWdhbEFzc2lnbm1lbnRUb1RlbXBsYXRlVmFyKFxuICAgICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgYXNzaWdubWVudDogUHJvcGVydHlXcml0ZSwgdGFyZ2V0OiBUbXBsQXN0VmFyaWFibGUpOiB2b2lkIHtcbiAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5yZXNvbHZlci5nZXRTb3VyY2VNYXBwaW5nKHRlbXBsYXRlSWQpO1xuICAgIGNvbnN0IGVycm9yTXNnID0gYENhbm5vdCB1c2UgdmFyaWFibGUgJyR7XG4gICAgICAgIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIC5uYW1lfScgYXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGVtcGxhdGUgdmFyaWFibGVzIGFyZSByZWFkLW9ubHkuYDtcblxuICAgIGNvbnN0IHNvdXJjZVNwYW4gPSB0aGlzLnJlc29sdmVyLnRvUGFyc2VTb3VyY2VTcGFuKHRlbXBsYXRlSWQsIGFzc2lnbm1lbnQuc291cmNlU3Bhbik7XG4gICAgaWYgKHNvdXJjZVNwYW4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGZhaWx1cmU6IG5vIFNvdXJjZUxvY2F0aW9uIGZvdW5kIGZvciBwcm9wZXJ0eSBiaW5kaW5nLmApO1xuICAgIH1cbiAgICB0aGlzLl9kaWFnbm9zdGljcy5wdXNoKG1ha2VUZW1wbGF0ZURpYWdub3N0aWMoXG4gICAgICAgIHRlbXBsYXRlSWQsIG1hcHBpbmcsIHNvdXJjZVNwYW4sIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvcixcbiAgICAgICAgbmdFcnJvckNvZGUoRXJyb3JDb2RlLldSSVRFX1RPX1JFQURfT05MWV9WQVJJQUJMRSksIGVycm9yTXNnLCBbe1xuICAgICAgICAgIHRleHQ6IGBUaGUgdmFyaWFibGUgJHthc3NpZ25tZW50Lm5hbWV9IGlzIGRlY2xhcmVkIGhlcmUuYCxcbiAgICAgICAgICBzdGFydDogdGFyZ2V0LnZhbHVlU3Bhbj8uc3RhcnQub2Zmc2V0IHx8IHRhcmdldC5zb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgICBlbmQ6IHRhcmdldC52YWx1ZVNwYW4/LmVuZC5vZmZzZXQgfHwgdGFyZ2V0LnNvdXJjZVNwYW4uZW5kLm9mZnNldCxcbiAgICAgICAgICBzb3VyY2VGaWxlOiBtYXBwaW5nLm5vZGUuZ2V0U291cmNlRmlsZSgpLFxuICAgICAgICB9XSkpO1xuICB9XG5cbiAgZHVwbGljYXRlVGVtcGxhdGVWYXIoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCB2YXJpYWJsZTogVG1wbEFzdFZhcmlhYmxlLCBmaXJzdERlY2w6IFRtcGxBc3RWYXJpYWJsZSk6IHZvaWQge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnJlc29sdmVyLmdldFNvdXJjZU1hcHBpbmcodGVtcGxhdGVJZCk7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBgQ2Fubm90IHJlZGVjbGFyZSB2YXJpYWJsZSAnJHtcbiAgICAgICAgdmFyaWFibGUubmFtZX0nIGFzIGl0IHdhcyBwcmV2aW91c2x5IGRlY2xhcmVkIGVsc2V3aGVyZSBmb3IgdGhlIHNhbWUgdGVtcGxhdGUuYDtcblxuICAgIC8vIFRoZSBhbGxvY2F0aW9uIG9mIHRoZSBlcnJvciBoZXJlIGlzIHByZXR0eSB1c2VsZXNzIGZvciB2YXJpYWJsZXMgZGVjbGFyZWQgaW4gbWljcm9zeW50YXgsXG4gICAgLy8gc2luY2UgdGhlIHNvdXJjZVNwYW4gcmVmZXJzIHRvIHRoZSBlbnRpcmUgbWljcm9zeW50YXggcHJvcGVydHksIG5vdCBhIHNwYW4gZm9yIHRoZSBzcGVjaWZpY1xuICAgIC8vIHZhcmlhYmxlIGluIHF1ZXN0aW9uLlxuICAgIC8vXG4gICAgLy8gVE9ETyhhbHhodWIpOiBhbGxvY2F0ZSB0byBhIHRpZ2h0ZXIgc3BhbiBvbmNlIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlVGVtcGxhdGVEaWFnbm9zdGljKFxuICAgICAgICB0ZW1wbGF0ZUlkLCBtYXBwaW5nLCB2YXJpYWJsZS5zb3VyY2VTcGFuLCB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgICAgIG5nRXJyb3JDb2RlKEVycm9yQ29kZS5EVVBMSUNBVEVfVkFSSUFCTEVfREVDTEFSQVRJT04pLCBlcnJvck1zZywgW3tcbiAgICAgICAgICB0ZXh0OiBgVGhlIHZhcmlhYmxlICcke2ZpcnN0RGVjbC5uYW1lfScgd2FzIGZpcnN0IGRlY2xhcmVkIGhlcmUuYCxcbiAgICAgICAgICBzdGFydDogZmlyc3REZWNsLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0LFxuICAgICAgICAgIGVuZDogZmlyc3REZWNsLnNvdXJjZVNwYW4uZW5kLm9mZnNldCxcbiAgICAgICAgICBzb3VyY2VGaWxlOiBtYXBwaW5nLm5vZGUuZ2V0U291cmNlRmlsZSgpLFxuICAgICAgICB9XSkpO1xuICB9XG5cbiAgcmVxdWlyZXNJbmxpbmVUY2IodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgbm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX2RpYWdub3N0aWNzLnB1c2gobWFrZUlubGluZURpYWdub3N0aWMoXG4gICAgICAgIHRlbXBsYXRlSWQsIEVycm9yQ29kZS5JTkxJTkVfVENCX1JFUVVJUkVELCBub2RlLm5hbWUsXG4gICAgICAgIGBUaGlzIGNvbXBvbmVudCByZXF1aXJlcyBpbmxpbmUgdGVtcGxhdGUgdHlwZS1jaGVja2luZywgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5gKSk7XG4gIH1cblxuICByZXF1aXJlc0lubGluZVR5cGVDb25zdHJ1Y3RvcnMoXG4gICAgICB0ZW1wbGF0ZUlkOiBUZW1wbGF0ZUlkLCBub2RlOiBDbGFzc0RlY2xhcmF0aW9uLCBkaXJlY3RpdmVzOiBDbGFzc0RlY2xhcmF0aW9uW10pOiB2b2lkIHtcbiAgICBsZXQgbWVzc2FnZTogc3RyaW5nO1xuICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgIGBUaGlzIGNvbXBvbmVudCB1c2VzIGRpcmVjdGl2ZXMgd2hpY2ggcmVxdWlyZSBpbmxpbmUgdHlwZSBjb25zdHJ1Y3RvcnMsIHdoaWNoIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGVudmlyb25tZW50LmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgIGBUaGlzIGNvbXBvbmVudCB1c2VzIGEgZGlyZWN0aXZlIHdoaWNoIHJlcXVpcmVzIGFuIGlubGluZSB0eXBlIGNvbnN0cnVjdG9yLCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGVudmlyb25tZW50LmA7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlSW5saW5lRGlhZ25vc3RpYyhcbiAgICAgICAgdGVtcGxhdGVJZCwgRXJyb3JDb2RlLklOTElORV9UWVBFX0NUT1JfUkVRVUlSRUQsIG5vZGUubmFtZSwgbWVzc2FnZSxcbiAgICAgICAgZGlyZWN0aXZlcy5tYXAoXG4gICAgICAgICAgICBkaXIgPT4gbWFrZVJlbGF0ZWRJbmZvcm1hdGlvbihkaXIubmFtZSwgYFJlcXVpcmVzIGFuIGlubGluZSB0eXBlIGNvbnN0cnVjdG9yLmApKSkpO1xuICB9XG5cbiAgc3Vib3B0aW1hbFR5cGVJbmZlcmVuY2UodGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgdmFyaWFibGVzOiBUbXBsQXN0VmFyaWFibGVbXSk6IHZvaWQge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnJlc29sdmVyLmdldFNvdXJjZU1hcHBpbmcodGVtcGxhdGVJZCk7XG5cbiAgICAvLyBTZWxlY3Qgb25lIG9mIHRoZSB0ZW1wbGF0ZSB2YXJpYWJsZXMgdGhhdCdzIG1vc3Qgc3VpdGFibGUgZm9yIHJlcG9ydGluZyB0aGUgZGlhZ25vc3RpYy4gQW55XG4gICAgLy8gdmFyaWFibGUgd2lsbCBkbywgYnV0IHByZWZlciBvbmUgYm91bmQgdG8gdGhlIGNvbnRleHQncyAkaW1wbGljaXQgaWYgcHJlc2VudC5cbiAgICBsZXQgZGlhZ25vc3RpY1ZhcjogVG1wbEFzdFZhcmlhYmxlfG51bGwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdmFyaWFibGVzKSB7XG4gICAgICBpZiAoZGlhZ25vc3RpY1ZhciA9PT0gbnVsbCB8fCAodmFyaWFibGUudmFsdWUgPT09ICcnIHx8IHZhcmlhYmxlLnZhbHVlID09PSAnJGltcGxpY2l0JykpIHtcbiAgICAgICAgZGlhZ25vc3RpY1ZhciA9IHZhcmlhYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlhZ25vc3RpY1ZhciA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gdmFyaWFibGUgb24gd2hpY2ggdG8gcmVwb3J0IHRoZSBkaWFnbm9zdGljLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB2YXJJZGVudGlmaWNhdGlvbiA9IGAnJHtkaWFnbm9zdGljVmFyLm5hbWV9J2A7XG4gICAgaWYgKHZhcmlhYmxlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhcklkZW50aWZpY2F0aW9uICs9IGAgKGFuZCAxIG90aGVyKWA7XG4gICAgfSBlbHNlIGlmICh2YXJpYWJsZXMubGVuZ3RoID4gMikge1xuICAgICAgdmFySWRlbnRpZmljYXRpb24gKz0gYCAoYW5kICR7dmFyaWFibGVzLmxlbmd0aCAtIDF9IG90aGVycylgO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgYFRoaXMgc3RydWN0dXJhbCBkaXJlY3RpdmUgc3VwcG9ydHMgYWR2YW5jZWQgdHlwZSBpbmZlcmVuY2UsIGJ1dCB0aGUgY3VycmVudCBjb21waWxlciBjb25maWd1cmF0aW9uIHByZXZlbnRzIGl0cyB1c2FnZS4gVGhlIHZhcmlhYmxlICR7XG4gICAgICAgICAgICB2YXJJZGVudGlmaWNhdGlvbn0gd2lsbCBoYXZlIHR5cGUgJ2FueScgYXMgYSByZXN1bHQuXFxuXFxuQ29uc2lkZXIgZW5hYmxpbmcgdGhlICdzdHJpY3RUZW1wbGF0ZXMnIG9wdGlvbiBpbiB5b3VyIHRzY29uZmlnLmpzb24gZm9yIGJldHRlciB0eXBlIGluZmVyZW5jZSB3aXRoaW4gdGhpcyB0ZW1wbGF0ZS5gO1xuXG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlVGVtcGxhdGVEaWFnbm9zdGljKFxuICAgICAgICB0ZW1wbGF0ZUlkLCBtYXBwaW5nLCBkaWFnbm9zdGljVmFyLmtleVNwYW4sIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5TdWdnZXN0aW9uLFxuICAgICAgICBuZ0Vycm9yQ29kZShFcnJvckNvZGUuU1VHR0VTVF9TVUJPUFRJTUFMX1RZUEVfSU5GRVJFTkNFKSwgbWVzc2FnZSkpO1xuICB9XG5cbiAgc3BsaXRUd29XYXlCaW5kaW5nKFxuICAgICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgaW5wdXQ6IEJvdW5kQXR0cmlidXRlLCBvdXRwdXQ6IFRtcGxBc3RCb3VuZEV2ZW50LFxuICAgICAgaW5wdXRDb25zdW1lcjogQ2xhc3NEZWNsYXJhdGlvbiwgb3V0cHV0Q29uc3VtZXI6IENsYXNzRGVjbGFyYXRpb258VG1wbEFzdEVsZW1lbnQpOiB2b2lkIHtcbiAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5yZXNvbHZlci5nZXRTb3VyY2VNYXBwaW5nKHRlbXBsYXRlSWQpO1xuICAgIGNvbnN0IGVycm9yTXNnID0gYFRoZSBwcm9wZXJ0eSBhbmQgZXZlbnQgaGFsdmVzIG9mIHRoZSB0d28td2F5IGJpbmRpbmcgJyR7XG4gICAgICAgIGlucHV0Lm5hbWV9JyBhcmUgbm90IGJvdW5kIHRvIHRoZSBzYW1lIHRhcmdldC5cbiAgICAgICAgICAgIEZpbmQgbW9yZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvdHdvLXdheS1iaW5kaW5nI2hvdy10d28td2F5LWJpbmRpbmctd29ya3NgO1xuXG4gICAgY29uc3QgcmVsYXRlZE1lc3NhZ2VzOiB7dGV4dDogc3RyaW5nOyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlO31bXSA9IFtdO1xuXG4gICAgcmVsYXRlZE1lc3NhZ2VzLnB1c2goe1xuICAgICAgdGV4dDogYFRoZSBwcm9wZXJ0eSBoYWxmIG9mIHRoZSBiaW5kaW5nIGlzIHRvIHRoZSAnJHtpbnB1dENvbnN1bWVyLm5hbWUudGV4dH0nIGNvbXBvbmVudC5gLFxuICAgICAgc3RhcnQ6IGlucHV0Q29uc3VtZXIubmFtZS5nZXRTdGFydCgpLFxuICAgICAgZW5kOiBpbnB1dENvbnN1bWVyLm5hbWUuZ2V0RW5kKCksXG4gICAgICBzb3VyY2VGaWxlOiBpbnB1dENvbnN1bWVyLm5hbWUuZ2V0U291cmNlRmlsZSgpLFxuICAgIH0pO1xuXG4gICAgaWYgKG91dHB1dENvbnN1bWVyIGluc3RhbmNlb2YgVG1wbEFzdEVsZW1lbnQpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gYFRoZSBldmVudCBoYWxmIG9mIHRoZSBiaW5kaW5nIGlzIHRvIGEgbmF0aXZlIGV2ZW50IGNhbGxlZCAnJHtcbiAgICAgICAgICBpbnB1dC5uYW1lfScgb24gdGhlIDwke291dHB1dENvbnN1bWVyLm5hbWV9PiBET00gZWxlbWVudC5gO1xuICAgICAgaWYgKCFtYXBwaW5nLm5vZGUuZ2V0U291cmNlRmlsZSgpLmlzRGVjbGFyYXRpb25GaWxlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcbiBcXG4gQXJlIHlvdSBtaXNzaW5nIGFuIG91dHB1dCBkZWNsYXJhdGlvbiBjYWxsZWQgJyR7b3V0cHV0Lm5hbWV9Jz9gO1xuICAgICAgfVxuICAgICAgcmVsYXRlZE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuICAgICAgICBzdGFydDogb3V0cHV0Q29uc3VtZXIuc291cmNlU3Bhbi5zdGFydC5vZmZzZXQgKyAxLFxuICAgICAgICBlbmQ6IG91dHB1dENvbnN1bWVyLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ICsgb3V0cHV0Q29uc3VtZXIubmFtZS5sZW5ndGggKyAxLFxuICAgICAgICBzb3VyY2VGaWxlOiBtYXBwaW5nLm5vZGUuZ2V0U291cmNlRmlsZSgpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbGF0ZWRNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgdGV4dDogYFRoZSBldmVudCBoYWxmIG9mIHRoZSBiaW5kaW5nIGlzIHRvIHRoZSAnJHtvdXRwdXRDb25zdW1lci5uYW1lLnRleHR9JyBjb21wb25lbnQuYCxcbiAgICAgICAgc3RhcnQ6IG91dHB1dENvbnN1bWVyLm5hbWUuZ2V0U3RhcnQoKSxcbiAgICAgICAgZW5kOiBvdXRwdXRDb25zdW1lci5uYW1lLmdldEVuZCgpLFxuICAgICAgICBzb3VyY2VGaWxlOiBvdXRwdXRDb25zdW1lci5uYW1lLmdldFNvdXJjZUZpbGUoKSxcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgdGhpcy5fZGlhZ25vc3RpY3MucHVzaChtYWtlVGVtcGxhdGVEaWFnbm9zdGljKFxuICAgICAgICB0ZW1wbGF0ZUlkLCBtYXBwaW5nLCBpbnB1dC5rZXlTcGFuLCB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuRXJyb3IsXG4gICAgICAgIG5nRXJyb3JDb2RlKEVycm9yQ29kZS5TUExJVF9UV09fV0FZX0JJTkRJTkcpLCBlcnJvck1zZywgcmVsYXRlZE1lc3NhZ2VzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUlubGluZURpYWdub3N0aWMoXG4gICAgdGVtcGxhdGVJZDogVGVtcGxhdGVJZCwgY29kZTogRXJyb3JDb2RlLklOTElORV9UQ0JfUkVRVUlSRUR8RXJyb3JDb2RlLklOTElORV9UWVBFX0NUT1JfUkVRVUlSRUQsXG4gICAgbm9kZTogdHMuTm9kZSwgbWVzc2FnZVRleHQ6IHN0cmluZ3x0cy5EaWFnbm9zdGljTWVzc2FnZUNoYWluLFxuICAgIHJlbGF0ZWRJbmZvcm1hdGlvbj86IHRzLkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb25bXSk6IFRlbXBsYXRlRGlhZ25vc3RpYyB7XG4gIHJldHVybiB7XG4gICAgLi4ubWFrZURpYWdub3N0aWMoY29kZSwgbm9kZSwgbWVzc2FnZVRleHQsIHJlbGF0ZWRJbmZvcm1hdGlvbiksXG4gICAgY29tcG9uZW50RmlsZTogbm9kZS5nZXRTb3VyY2VGaWxlKCksXG4gICAgdGVtcGxhdGVJZCxcbiAgfTtcbn1cbiJdfQ==