/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FunctionExpr, LiteralArrayExpr, LiteralExpr, literalMap, ReturnStatement, WrappedNodeExpr } from '@angular/compiler';
import * as ts from 'typescript';
import { valueReferenceToExpression, wrapFunctionExpressionsInParens } from './util';
/**
 * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata
 * present on the class or its member fields. An ngDevMode guard is used to allow the call to be
 * tree-shaken away, as the `setClassMetadata` invocation is only needed for testing purposes.
 *
 * If no such metadata is present, this function returns `null`. Otherwise, the call is returned
 * as a `Statement` for inclusion along with the class.
 */
export function extractClassMetadata(clazz, reflection, isCore, annotateForClosureCompiler) {
    if (!reflection.isClass(clazz)) {
        return null;
    }
    const id = reflection.getAdjacentNameOfClass(clazz);
    // Reflect over the class decorators. If none are present, or those that are aren't from
    // Angular, then return null. Otherwise, turn them into metadata.
    const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);
    if (classDecorators === null) {
        return null;
    }
    const ngClassDecorators = classDecorators.filter(dec => isAngularDecorator(dec, isCore))
        .map(decorator => decoratorToMetadata(decorator, annotateForClosureCompiler))
        // Since the `setClassMetadata` call is intended to be emitted after the class
        // declaration, we have to strip references to the existing identifiers or
        // TypeScript might generate invalid code when it emits to JS. In particular
        // this can break when emitting a class to ES5 which has a custom decorator
        // and is referenced inside of its own metadata (see #39509 for more information).
        .map(decorator => removeIdentifierReferences(decorator, id.text));
    if (ngClassDecorators.length === 0) {
        return null;
    }
    const metaDecorators = new WrappedNodeExpr(ts.createArrayLiteral(ngClassDecorators));
    // Convert the constructor parameters to metadata, passing null if none are present.
    let metaCtorParameters = null;
    const classCtorParameters = reflection.getConstructorParameters(clazz);
    if (classCtorParameters !== null) {
        const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, isCore));
        metaCtorParameters = new FunctionExpr([], [
            new ReturnStatement(new LiteralArrayExpr(ctorParameters)),
        ]);
    }
    // Do the same for property decorators.
    let metaPropDecorators = null;
    const classMembers = reflection.getMembersOfClass(clazz).filter(member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);
    const duplicateDecoratedMemberNames = classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);
    if (duplicateDecoratedMemberNames.length > 0) {
        // This should theoretically never happen, because the only way to have duplicate instance
        // member names is getter/setter pairs and decorators cannot appear in both a getter and the
        // corresponding setter.
        throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` +
            duplicateDecoratedMemberNames.join(', '));
    }
    const decoratedMembers = classMembers.map(member => { var _a; return classMemberToMetadata((_a = member.nameNode) !== null && _a !== void 0 ? _a : member.name, member.decorators, isCore); });
    if (decoratedMembers.length > 0) {
        metaPropDecorators = new WrappedNodeExpr(ts.createObjectLiteral(decoratedMembers));
    }
    return {
        type: new WrappedNodeExpr(id),
        decorators: metaDecorators,
        ctorParameters: metaCtorParameters,
        propDecorators: metaPropDecorators,
    };
}
/**
 * Convert a reflected constructor parameter to metadata.
 */
function ctorParameterToMetadata(param, isCore) {
    // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise
    // its type is undefined.
    const type = param.typeValueReference.kind !== 2 /* UNAVAILABLE */ ?
        valueReferenceToExpression(param.typeValueReference) :
        new LiteralExpr(undefined);
    const mapEntries = [
        { key: 'type', value: type, quoted: false },
    ];
    // If the parameter has decorators, include the ones from Angular.
    if (param.decorators !== null) {
        const ngDecorators = param.decorators.filter(dec => isAngularDecorator(dec, isCore))
            .map((decorator) => decoratorToMetadata(decorator));
        const value = new WrappedNodeExpr(ts.createArrayLiteral(ngDecorators));
        mapEntries.push({ key: 'decorators', value, quoted: false });
    }
    return literalMap(mapEntries);
}
/**
 * Convert a reflected class member to metadata.
 */
function classMemberToMetadata(name, decorators, isCore) {
    const ngDecorators = decorators.filter(dec => isAngularDecorator(dec, isCore))
        .map((decorator) => decoratorToMetadata(decorator));
    const decoratorMeta = ts.createArrayLiteral(ngDecorators);
    return ts.createPropertyAssignment(name, decoratorMeta);
}
/**
 * Convert a reflected decorator to metadata.
 */
function decoratorToMetadata(decorator, wrapFunctionsInParens) {
    if (decorator.identifier === null) {
        throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');
    }
    // Decorators have a type.
    const properties = [
        ts.createPropertyAssignment('type', ts.getMutableClone(decorator.identifier)),
    ];
    // Sometimes they have arguments.
    if (decorator.args !== null && decorator.args.length > 0) {
        const args = decorator.args.map(arg => {
            const expr = ts.getMutableClone(arg);
            return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(expr) : expr;
        });
        properties.push(ts.createPropertyAssignment('args', ts.createArrayLiteral(args)));
    }
    return ts.createObjectLiteral(properties, true);
}
/**
 * Whether a given decorator should be treated as an Angular decorator.
 *
 * Either it's used in @angular/core, or it's imported from there.
 */
function isAngularDecorator(decorator, isCore) {
    return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');
}
/**
 * Recursively recreates all of the `Identifier` descendant nodes with a particular name inside
 * of an AST node, thus removing any references to them. Useful if a particular node has to be t
 * aken from one place any emitted to another one exactly as it has been written.
 */
function removeIdentifierReferences(node, name) {
    const result = ts.transform(node, [context => root => ts.visitNode(root, function walk(current) {
            return ts.isIdentifier(current) && current.text === name ?
                ts.createIdentifier(current.text) :
                ts.visitEachChild(current, walk, context);
        })]);
    return result.transformed[0];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0YWRhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvc3JjL25ndHNjL2Fubm90YXRpb25zL3NyYy9tZXRhZGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQWEsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQW1CLGVBQWUsRUFBRSxlQUFlLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUN6SixPQUFPLEtBQUssRUFBRSxNQUFNLFlBQVksQ0FBQztBQUlqQyxPQUFPLEVBQUMsMEJBQTBCLEVBQUUsK0JBQStCLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFbkY7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FDaEMsS0FBc0IsRUFBRSxVQUEwQixFQUFFLE1BQWUsRUFDbkUsMEJBQW9DO0lBQ3RDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzlCLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFcEQsd0ZBQXdGO0lBQ3hGLGlFQUFpRTtJQUNqRSxNQUFNLGVBQWUsR0FBRyxVQUFVLENBQUMsMEJBQTBCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckUsSUFBSSxlQUFlLEtBQUssSUFBSSxFQUFFO1FBQzVCLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxNQUFNLGlCQUFpQixHQUNuQixlQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pELEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSwwQkFBMEIs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QUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxrQkFBa0IsQ0FBQyxTQUFvQixFQUFFLE1BQWU7SUFDL0QsT0FBTyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxLQUFLLElBQUksSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxlQUFlLENBQUMsQ0FBQztBQUM1RixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsMEJBQTBCLENBQW9CLElBQU8sRUFBRSxJQUFZO0lBQzFFLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQ3ZCLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLElBQUksQ0FBQyxPQUFnQjtZQUN6RSxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDdEQsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxFQUFFLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDaEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRVQsT0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQy9CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtFeHByZXNzaW9uLCBGdW5jdGlvbkV4cHIsIExpdGVyYWxBcnJheUV4cHIsIExpdGVyYWxFeHByLCBsaXRlcmFsTWFwLCBSM0NsYXNzTWV0YWRhdGEsIFJldHVyblN0YXRlbWVudCwgV3JhcHBlZE5vZGVFeHByfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtDdG9yUGFyYW1ldGVyLCBEZWNsYXJhdGlvbk5vZGUsIERlY29yYXRvciwgUmVmbGVjdGlvbkhvc3QsIFR5cGVWYWx1ZVJlZmVyZW5jZUtpbmR9IGZyb20gJy4uLy4uL3JlZmxlY3Rpb24nO1xuXG5pbXBvcnQge3ZhbHVlUmVmZXJlbmNlVG9FeHByZXNzaW9uLCB3cmFwRnVuY3Rpb25FeHByZXNzaW9uc0luUGFyZW5zfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEdpdmVuIGEgY2xhc3MgZGVjbGFyYXRpb24sIGdlbmVyYXRlIGEgY2FsbCB0byBgc2V0Q2xhc3NNZXRhZGF0YWAgd2l0aCB0aGUgQW5ndWxhciBtZXRhZGF0YVxuICogcHJlc2VudCBvbiB0aGUgY2xhc3Mgb3IgaXRzIG1lbWJlciBmaWVsZHMuIEFuIG5nRGV2TW9kZSBndWFyZCBpcyB1c2VkIHRvIGFsbG93IHRoZSBjYWxsIHRvIGJlXG4gKiB0cmVlLXNoYWtlbiBhd2F5LCBhcyB0aGUgYHNldENsYXNzTWV0YWRhdGFgIGludm9jYXRpb24gaXMgb25seSBuZWVkZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogSWYgbm8gc3VjaCBtZXRhZGF0YSBpcyBwcmVzZW50LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYG51bGxgLiBPdGhlcndpc2UsIHRoZSBjYWxsIGlzIHJldHVybmVkXG4gKiBhcyBhIGBTdGF0ZW1lbnRgIGZvciBpbmNsdXNpb24gYWxvbmcgd2l0aCB0aGUgY2xhc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Q2xhc3NNZXRhZGF0YShcbiAgICBjbGF6ejogRGVjbGFyYXRpb25Ob2RlLCByZWZsZWN0aW9uOiBSZWZsZWN0aW9uSG9zdCwgaXNDb3JlOiBib29sZWFuLFxuICAgIGFubm90YXRlRm9yQ2xvc3VyZUNvbXBpbGVyPzogYm9vbGVhbik6IFIzQ2xhc3NNZXRhZGF0YXxudWxsIHtcbiAgaWYgKCFyZWZsZWN0aW9uLmlzQ2xhc3MoY2xhenopKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaWQgPSByZWZsZWN0aW9uLmdldEFkamFjZW50TmFtZU9mQ2xhc3MoY2xhenopO1xuXG4gIC8vIFJlZmxlY3Qgb3ZlciB0aGUgY2xhc3MgZGVjb3JhdG9ycy4gSWYgbm9uZSBhcmUgcHJlc2VudCwgb3IgdGhvc2UgdGhhdCBhcmUgYXJlbid0IGZyb21cbiAgLy8gQW5ndWxhciwgdGhlbiByZXR1cm4gbnVsbC4gT3RoZXJ3aXNlLCB0dXJuIHRoZW0gaW50byBtZXRhZGF0YS5cbiAgY29uc3QgY2xhc3NEZWNvcmF0b3JzID0gcmVmbGVjdGlvbi5nZXREZWNvcmF0b3JzT2ZEZWNsYXJhdGlvbihjbGF6eik7XG4gIGlmIChjbGFzc0RlY29yYXRvcnMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBuZ0NsYXNzRGVjb3JhdG9ycyA9XG4gICAgICBjbGFzc0RlY29yYXRvcnMuZmlsdGVyKGRlYyA9PiBpc0FuZ3VsYXJEZWNvcmF0b3IoZGVjLCBpc0NvcmUpKVxuICAgICAgICAgIC5tYXAoZGVjb3JhdG9yID0+IGRlY29yYXRvclRvTWV0YWRhdGEoZGVjb3JhdG9yLCBhbm5vdGF0ZUZvckNsb3N1cmVDb21waWxlcikpXG4gICAgICAgICAgLy8gU2luY2UgdGhlIGBzZXRDbGFzc01ldGFkYXRhYCBjYWxsIGlzIGludGVuZGVkIHRvIGJlIGVtaXR0ZWQgYWZ0ZXIgdGhlIGNsYXNzXG4gICAgICAgICAgLy8gZGVjbGFyYXRpb24sIHdlIGhhdmUgdG8gc3RyaXAgcmVmZXJlbmNlcyB0byB0aGUgZXhpc3RpbmcgaWRlbnRpZmllcnMgb3JcbiAgICAgICAgICAvLyBUeXBlU2NyaXB0IG1pZ2h0IGdlbmVyYXRlIGludmFsaWQgY29kZSB3aGVuIGl0IGVtaXRzIHRvIEpTLiBJbiBwYXJ0aWN1bGFyXG4gICAgICAgICAgLy8gdGhpcyBjYW4gYnJlYWsgd2hlbiBlbWl0dGluZyBhIGNsYXNzIHRvIEVTNSB3aGljaCBoYXMgYSBjdXN0b20gZGVjb3JhdG9yXG4gICAgICAgICAgLy8gYW5kIGlzIHJlZmVyZW5jZWQgaW5zaWRlIG9mIGl0cyBvd24gbWV0YWRhdGEgKHNlZSAjMzk1MDkgZm9yIG1vcmUgaW5mb3JtYXRpb24pLlxuICAgICAgICAgIC5tYXAoZGVjb3JhdG9yID0+IHJlbW92ZUlkZW50aWZpZXJSZWZlcmVuY2VzKGRlY29yYXRvciwgaWQudGV4dCkpO1xuICBpZiAobmdDbGFzc0RlY29yYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWV0YURlY29yYXRvcnMgPSBuZXcgV3JhcHBlZE5vZGVFeHByKHRzLmNyZWF0ZUFycmF5TGl0ZXJhbChuZ0NsYXNzRGVjb3JhdG9ycykpO1xuXG4gIC8vIENvbnZlcnQgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgdG8gbWV0YWRhdGEsIHBhc3NpbmcgbnVsbCBpZiBub25lIGFyZSBwcmVzZW50LlxuICBsZXQgbWV0YUN0b3JQYXJhbWV0ZXJzOiBFeHByZXNzaW9ufG51bGwgPSBudWxsO1xuICBjb25zdCBjbGFzc0N0b3JQYXJhbWV0ZXJzID0gcmVmbGVjdGlvbi5nZXRDb25zdHJ1Y3RvclBhcmFtZXRlcnMoY2xhenopO1xuICBpZiAoY2xhc3NDdG9yUGFyYW1ldGVycyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGN0b3JQYXJhbWV0ZXJzID0gY2xhc3NDdG9yUGFyYW1ldGVycy5tYXAocGFyYW0gPT4gY3RvclBhcmFtZXRlclRvTWV0YWRhdGEocGFyYW0sIGlzQ29yZSkpO1xuICAgIG1ldGFDdG9yUGFyYW1ldGVycyA9IG5ldyBGdW5jdGlvbkV4cHIoW10sIFtcbiAgICAgIG5ldyBSZXR1cm5TdGF0ZW1lbnQobmV3IExpdGVyYWxBcnJheUV4cHIoY3RvclBhcmFtZXRlcnMpKSxcbiAgICBdKTtcbiAgfVxuXG4gIC8vIERvIHRoZSBzYW1lIGZvciBwcm9wZXJ0eSBkZWNvcmF0b3JzLlxuICBsZXQgbWV0YVByb3BEZWNvcmF0b3JzOiBFeHByZXNzaW9ufG51bGwgPSBudWxsO1xuICBjb25zdCBjbGFzc01lbWJlcnMgPSByZWZsZWN0aW9uLmdldE1lbWJlcnNPZkNsYXNzKGNsYXp6KS5maWx0ZXIoXG4gICAgICBtZW1iZXIgPT4gIW1lbWJlci5pc1N0YXRpYyAmJiBtZW1iZXIuZGVjb3JhdG9ycyAhPT0gbnVsbCAmJiBtZW1iZXIuZGVjb3JhdG9ycy5sZW5ndGggPiAwKTtcbiAgY29uc3QgZHVwbGljYXRlRGVjb3JhdGVkTWVtYmVyTmFtZXMgPVxuICAgICAgY2xhc3NNZW1iZXJzLm1hcChtZW1iZXIgPT4gbWVtYmVyLm5hbWUpLmZpbHRlcigobmFtZSwgaSwgYXJyKSA9PiBhcnIuaW5kZXhPZihuYW1lKSA8IGkpO1xuICBpZiAoZHVwbGljYXRlRGVjb3JhdGVkTWVtYmVyTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRoZW9yZXRpY2FsbHkgbmV2ZXIgaGFwcGVuLCBiZWNhdXNlIHRoZSBvbmx5IHdheSB0byBoYXZlIGR1cGxpY2F0ZSBpbnN0YW5jZVxuICAgIC8vIG1lbWJlciBuYW1lcyBpcyBnZXR0ZXIvc2V0dGVyIHBhaXJzIGFuZCBkZWNvcmF0b3JzIGNhbm5vdCBhcHBlYXIgaW4gYm90aCBhIGdldHRlciBhbmQgdGhlXG4gICAgLy8gY29ycmVzcG9uZGluZyBzZXR0ZXIuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRHVwbGljYXRlIGRlY29yYXRlZCBwcm9wZXJ0aWVzIGZvdW5kIG9uIGNsYXNzICcke2NsYXp6Lm5hbWUudGV4dH0nOiBgICtcbiAgICAgICAgZHVwbGljYXRlRGVjb3JhdGVkTWVtYmVyTmFtZXMuam9pbignLCAnKSk7XG4gIH1cbiAgY29uc3QgZGVjb3JhdGVkTWVtYmVycyA9IGNsYXNzTWVtYmVycy5tYXAoXG4gICAgICBtZW1iZXIgPT4gY2xhc3NNZW1iZXJUb01ldGFkYXRhKG1lbWJlci5uYW1lTm9kZSA/PyBtZW1iZXIubmFtZSwgbWVtYmVyLmRlY29yYXRvcnMhLCBpc0NvcmUpKTtcbiAgaWYgKGRlY29yYXRlZE1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgIG1ldGFQcm9wRGVjb3JhdG9ycyA9IG5ldyBXcmFwcGVkTm9kZUV4cHIodHMuY3JlYXRlT2JqZWN0TGl0ZXJhbChkZWNvcmF0ZWRNZW1iZXJzKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoaWQpLFxuICAgIGRlY29yYXRvcnM6IG1ldGFEZWNvcmF0b3JzLFxuICAgIGN0b3JQYXJhbWV0ZXJzOiBtZXRhQ3RvclBhcmFtZXRlcnMsXG4gICAgcHJvcERlY29yYXRvcnM6IG1ldGFQcm9wRGVjb3JhdG9ycyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcmVmbGVjdGVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciB0byBtZXRhZGF0YS5cbiAqL1xuZnVuY3Rpb24gY3RvclBhcmFtZXRlclRvTWV0YWRhdGEocGFyYW06IEN0b3JQYXJhbWV0ZXIsIGlzQ29yZTogYm9vbGVhbik6IEV4cHJlc3Npb24ge1xuICAvLyBQYXJhbWV0ZXJzIHNvbWV0aW1lcyBoYXZlIGEgdHlwZSB0aGF0IGNhbiBiZSByZWZlcmVuY2VkLiBJZiBzbywgdGhlbiB1c2UgaXQsIG90aGVyd2lzZVxuICAvLyBpdHMgdHlwZSBpcyB1bmRlZmluZWQuXG4gIGNvbnN0IHR5cGUgPSBwYXJhbS50eXBlVmFsdWVSZWZlcmVuY2Uua2luZCAhPT0gVHlwZVZhbHVlUmVmZXJlbmNlS2luZC5VTkFWQUlMQUJMRSA/XG4gICAgICB2YWx1ZVJlZmVyZW5jZVRvRXhwcmVzc2lvbihwYXJhbS50eXBlVmFsdWVSZWZlcmVuY2UpIDpcbiAgICAgIG5ldyBMaXRlcmFsRXhwcih1bmRlZmluZWQpO1xuXG4gIGNvbnN0IG1hcEVudHJpZXM6IHtrZXk6IHN0cmluZywgdmFsdWU6IEV4cHJlc3Npb24sIHF1b3RlZDogZmFsc2V9W10gPSBbXG4gICAge2tleTogJ3R5cGUnLCB2YWx1ZTogdHlwZSwgcXVvdGVkOiBmYWxzZX0sXG4gIF07XG5cbiAgLy8gSWYgdGhlIHBhcmFtZXRlciBoYXMgZGVjb3JhdG9ycywgaW5jbHVkZSB0aGUgb25lcyBmcm9tIEFuZ3VsYXIuXG4gIGlmIChwYXJhbS5kZWNvcmF0b3JzICE9PSBudWxsKSB7XG4gICAgY29uc3QgbmdEZWNvcmF0b3JzID0gcGFyYW0uZGVjb3JhdG9ycy5maWx0ZXIoZGVjID0+IGlzQW5ndWxhckRlY29yYXRvcihkZWMsIGlzQ29yZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGRlY29yYXRvcjogRGVjb3JhdG9yKSA9PiBkZWNvcmF0b3JUb01ldGFkYXRhKGRlY29yYXRvcikpO1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFdyYXBwZWROb2RlRXhwcih0cy5jcmVhdGVBcnJheUxpdGVyYWwobmdEZWNvcmF0b3JzKSk7XG4gICAgbWFwRW50cmllcy5wdXNoKHtrZXk6ICdkZWNvcmF0b3JzJywgdmFsdWUsIHF1b3RlZDogZmFsc2V9KTtcbiAgfVxuICByZXR1cm4gbGl0ZXJhbE1hcChtYXBFbnRyaWVzKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcmVmbGVjdGVkIGNsYXNzIG1lbWJlciB0byBtZXRhZGF0YS5cbiAqL1xuZnVuY3Rpb24gY2xhc3NNZW1iZXJUb01ldGFkYXRhKFxuICAgIG5hbWU6IHRzLlByb3BlcnR5TmFtZXxzdHJpbmcsIGRlY29yYXRvcnM6IERlY29yYXRvcltdLCBpc0NvcmU6IGJvb2xlYW4pOiB0cy5Qcm9wZXJ0eUFzc2lnbm1lbnQge1xuICBjb25zdCBuZ0RlY29yYXRvcnMgPSBkZWNvcmF0b3JzLmZpbHRlcihkZWMgPT4gaXNBbmd1bGFyRGVjb3JhdG9yKGRlYywgaXNDb3JlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGRlY29yYXRvcjogRGVjb3JhdG9yKSA9PiBkZWNvcmF0b3JUb01ldGFkYXRhKGRlY29yYXRvcikpO1xuICBjb25zdCBkZWNvcmF0b3JNZXRhID0gdHMuY3JlYXRlQXJyYXlMaXRlcmFsKG5nRGVjb3JhdG9ycyk7XG4gIHJldHVybiB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQobmFtZSwgZGVjb3JhdG9yTWV0YSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHJlZmxlY3RlZCBkZWNvcmF0b3IgdG8gbWV0YWRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlY29yYXRvclRvTWV0YWRhdGEoXG4gICAgZGVjb3JhdG9yOiBEZWNvcmF0b3IsIHdyYXBGdW5jdGlvbnNJblBhcmVucz86IGJvb2xlYW4pOiB0cy5PYmplY3RMaXRlcmFsRXhwcmVzc2lvbiB7XG4gIGlmIChkZWNvcmF0b3IuaWRlbnRpZmllciA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBzdGF0ZTogc3ludGhlc2l6ZWQgZGVjb3JhdG9yIGNhbm5vdCBiZSBlbWl0dGVkIGluIGNsYXNzIG1ldGFkYXRhLicpO1xuICB9XG4gIC8vIERlY29yYXRvcnMgaGF2ZSBhIHR5cGUuXG4gIGNvbnN0IHByb3BlcnRpZXM6IHRzLk9iamVjdExpdGVyYWxFbGVtZW50TGlrZVtdID0gW1xuICAgIHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudCgndHlwZScsIHRzLmdldE11dGFibGVDbG9uZShkZWNvcmF0b3IuaWRlbnRpZmllcikpLFxuICBdO1xuICAvLyBTb21ldGltZXMgdGhleSBoYXZlIGFyZ3VtZW50cy5cbiAgaWYgKGRlY29yYXRvci5hcmdzICE9PSBudWxsICYmIGRlY29yYXRvci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBhcmdzID0gZGVjb3JhdG9yLmFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICBjb25zdCBleHByID0gdHMuZ2V0TXV0YWJsZUNsb25lKGFyZyk7XG4gICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uc0luUGFyZW5zID8gd3JhcEZ1bmN0aW9uRXhwcmVzc2lvbnNJblBhcmVucyhleHByKSA6IGV4cHI7XG4gICAgfSk7XG4gICAgcHJvcGVydGllcy5wdXNoKHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudCgnYXJncycsIHRzLmNyZWF0ZUFycmF5TGl0ZXJhbChhcmdzKSkpO1xuICB9XG4gIHJldHVybiB0cy5jcmVhdGVPYmplY3RMaXRlcmFsKHByb3BlcnRpZXMsIHRydWUpO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgYSBnaXZlbiBkZWNvcmF0b3Igc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYW4gQW5ndWxhciBkZWNvcmF0b3IuXG4gKlxuICogRWl0aGVyIGl0J3MgdXNlZCBpbiBAYW5ndWxhci9jb3JlLCBvciBpdCdzIGltcG9ydGVkIGZyb20gdGhlcmUuXG4gKi9cbmZ1bmN0aW9uIGlzQW5ndWxhckRlY29yYXRvcihkZWNvcmF0b3I6IERlY29yYXRvciwgaXNDb3JlOiBib29sZWFuKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc0NvcmUgfHwgKGRlY29yYXRvci5pbXBvcnQgIT09IG51bGwgJiYgZGVjb3JhdG9yLmltcG9ydC5mcm9tID09PSAnQGFuZ3VsYXIvY29yZScpO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlY3JlYXRlcyBhbGwgb2YgdGhlIGBJZGVudGlmaWVyYCBkZXNjZW5kYW50IG5vZGVzIHdpdGggYSBwYXJ0aWN1bGFyIG5hbWUgaW5zaWRlXG4gKiBvZiBhbiBBU1Qgbm9kZSwgdGh1cyByZW1vdmluZyBhbnkgcmVmZXJlbmNlcyB0byB0aGVtLiBVc2VmdWwgaWYgYSBwYXJ0aWN1bGFyIG5vZGUgaGFzIHRvIGJlIHRcbiAqIGFrZW4gZnJvbSBvbmUgcGxhY2UgYW55IGVtaXR0ZWQgdG8gYW5vdGhlciBvbmUgZXhhY3RseSBhcyBpdCBoYXMgYmVlbiB3cml0dGVuLlxuICovXG5mdW5jdGlvbiByZW1vdmVJZGVudGlmaWVyUmVmZXJlbmNlczxUIGV4dGVuZHMgdHMuTm9kZT4obm9kZTogVCwgbmFtZTogc3RyaW5nKTogVCB7XG4gIGNvbnN0IHJlc3VsdCA9IHRzLnRyYW5zZm9ybShcbiAgICAgIG5vZGUsIFtjb250ZXh0ID0+IHJvb3QgPT4gdHMudmlzaXROb2RlKHJvb3QsIGZ1bmN0aW9uIHdhbGsoY3VycmVudDogdHMuTm9kZSk6IHRzLk5vZGUge1xuICAgICAgICByZXR1cm4gdHMuaXNJZGVudGlmaWVyKGN1cnJlbnQpICYmIGN1cnJlbnQudGV4dCA9PT0gbmFtZSA/XG4gICAgICAgICAgICB0cy5jcmVhdGVJZGVudGlmaWVyKGN1cnJlbnQudGV4dCkgOlxuICAgICAgICAgICAgdHMudmlzaXRFYWNoQ2hpbGQoY3VycmVudCwgd2FsaywgY29udGV4dCk7XG4gICAgICB9KV0pO1xuXG4gIHJldHVybiByZXN1bHQudHJhbnNmb3JtZWRbMF07XG59XG4iXX0=