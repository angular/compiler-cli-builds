/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
/**
 * Adds extra imports in the import manage for this source file, after the existing imports
 * and before the module body.
 * Can optionally add extra statements (e.g. new constants) before the body as well.
 */
export function addImports(importManager, sf, extraStatements = []) {
    // Generate the import statements to prepend.
    const addedImports = importManager.getAllImports(sf.fileName).map(i => {
        const qualifier = ts.createIdentifier(i.qualifier.text);
        const importClause = ts.createImportClause(
        /* name */ undefined, 
        /* namedBindings */ ts.createNamespaceImport(qualifier));
        const decl = ts.createImportDeclaration(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* importClause */ importClause, 
        /* moduleSpecifier */ ts.createLiteral(i.specifier));
        // Set the qualifier's original TS node to the `ts.ImportDeclaration`. This allows downstream
        // transforms such as tsickle to properly process references to this import.
        //
        // This operation is load-bearing in g3 as some imported modules contain special metadata
        // generated by clutz, which tsickle uses to transform imports and references to those imports.
        //
        // TODO(alxhub): add a test for this when tsickle is updated externally to depend on this
        // behavior.
        ts.setOriginalNode(i.qualifier, decl);
        return decl;
    });
    // Filter out the existing imports and the source file body. All new statements
    // will be inserted between them.
    const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));
    const body = sf.statements.filter(stmt => !isImportStatement(stmt));
    // Prepend imports if needed.
    if (addedImports.length > 0) {
        // If we prepend imports, we also prepend NotEmittedStatement to use it as an anchor
        // for @fileoverview Closure annotation. If there is no @fileoverview annotations, this
        // statement would be a noop.
        const fileoverviewAnchorStmt = ts.createNotEmittedStatement(sf);
        return ts.updateSourceFileNode(sf, ts.createNodeArray([
            fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body
        ]));
    }
    return sf;
}
function isImportStatement(stmt) {
    return ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) ||
        ts.isNamespaceImport(stmt);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb21waWxlci1jbGkvc3JjL25ndHNjL3RyYW5zZm9ybS9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBQ0gsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFJakM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQ3RCLGFBQTRCLEVBQUUsRUFBaUIsRUFDL0Msa0JBQWtDLEVBQUU7SUFDdEMsNkNBQTZDO0lBQzdDLE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNwRSxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4RCxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUMsa0JBQWtCO1FBQ3RDLFVBQVUsQ0FBQyxTQUFTO1FBQ3BCLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQzdELE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQyx1QkFBdUI7UUFDbkMsZ0JBQWdCLENBQUMsU0FBUztRQUMxQixlQUFlLENBQUMsU0FBUztRQUN6QixrQkFBa0IsQ0FBQyxZQUFZO1FBQy9CLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFFekQsNkZBQTZGO1FBQzdGLDRFQUE0RTtRQUM1RSxFQUFFO1FBQ0YseUZBQXlGO1FBQ3pGLCtGQUErRjtRQUMvRixFQUFFO1FBQ0YseUZBQXlGO1FBQ3pGLFlBQVk7UUFDWixFQUFFLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFdEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDLENBQUMsQ0FBQztJQUVILCtFQUErRTtJQUMvRSxpQ0FBaUM7SUFDakMsTUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlFLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLDZCQUE2QjtJQUM3QixJQUFJLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQzNCLG9GQUFvRjtRQUNwRix1RkFBdUY7UUFDdkYsNkJBQTZCO1FBQzdCLE1BQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDLHlCQUF5QixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2hFLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDO1lBQ3BELHNCQUFzQixFQUFFLEdBQUcsZUFBZSxFQUFFLEdBQUcsWUFBWSxFQUFFLEdBQUcsZUFBZSxFQUFFLEdBQUcsSUFBSTtTQUN6RixDQUFDLENBQUMsQ0FBQztLQUNMO0lBRUQsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxJQUFrQjtJQUMzQyxPQUFPLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDO1FBQ3JFLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNqQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtJbXBvcnRNYW5hZ2VyfSBmcm9tICcuLi8uLi90cmFuc2xhdG9yJztcblxuLyoqXG4gKiBBZGRzIGV4dHJhIGltcG9ydHMgaW4gdGhlIGltcG9ydCBtYW5hZ2UgZm9yIHRoaXMgc291cmNlIGZpbGUsIGFmdGVyIHRoZSBleGlzdGluZyBpbXBvcnRzXG4gKiBhbmQgYmVmb3JlIHRoZSBtb2R1bGUgYm9keS5cbiAqIENhbiBvcHRpb25hbGx5IGFkZCBleHRyYSBzdGF0ZW1lbnRzIChlLmcuIG5ldyBjb25zdGFudHMpIGJlZm9yZSB0aGUgYm9keSBhcyB3ZWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkSW1wb3J0cyhcbiAgICBpbXBvcnRNYW5hZ2VyOiBJbXBvcnRNYW5hZ2VyLCBzZjogdHMuU291cmNlRmlsZSxcbiAgICBleHRyYVN0YXRlbWVudHM6IHRzLlN0YXRlbWVudFtdID0gW10pOiB0cy5Tb3VyY2VGaWxlIHtcbiAgLy8gR2VuZXJhdGUgdGhlIGltcG9ydCBzdGF0ZW1lbnRzIHRvIHByZXBlbmQuXG4gIGNvbnN0IGFkZGVkSW1wb3J0cyA9IGltcG9ydE1hbmFnZXIuZ2V0QWxsSW1wb3J0cyhzZi5maWxlTmFtZSkubWFwKGkgPT4ge1xuICAgIGNvbnN0IHF1YWxpZmllciA9IHRzLmNyZWF0ZUlkZW50aWZpZXIoaS5xdWFsaWZpZXIudGV4dCk7XG4gICAgY29uc3QgaW1wb3J0Q2xhdXNlID0gdHMuY3JlYXRlSW1wb3J0Q2xhdXNlKFxuICAgICAgICAvKiBuYW1lICovIHVuZGVmaW5lZCxcbiAgICAgICAgLyogbmFtZWRCaW5kaW5ncyAqLyB0cy5jcmVhdGVOYW1lc3BhY2VJbXBvcnQocXVhbGlmaWVyKSk7XG4gICAgY29uc3QgZGVjbCA9IHRzLmNyZWF0ZUltcG9ydERlY2xhcmF0aW9uKFxuICAgICAgICAvKiBkZWNvcmF0b3JzICovIHVuZGVmaW5lZCxcbiAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgLyogaW1wb3J0Q2xhdXNlICovIGltcG9ydENsYXVzZSxcbiAgICAgICAgLyogbW9kdWxlU3BlY2lmaWVyICovIHRzLmNyZWF0ZUxpdGVyYWwoaS5zcGVjaWZpZXIpKTtcblxuICAgIC8vIFNldCB0aGUgcXVhbGlmaWVyJ3Mgb3JpZ2luYWwgVFMgbm9kZSB0byB0aGUgYHRzLkltcG9ydERlY2xhcmF0aW9uYC4gVGhpcyBhbGxvd3MgZG93bnN0cmVhbVxuICAgIC8vIHRyYW5zZm9ybXMgc3VjaCBhcyB0c2lja2xlIHRvIHByb3Blcmx5IHByb2Nlc3MgcmVmZXJlbmNlcyB0byB0aGlzIGltcG9ydC5cbiAgICAvL1xuICAgIC8vIFRoaXMgb3BlcmF0aW9uIGlzIGxvYWQtYmVhcmluZyBpbiBnMyBhcyBzb21lIGltcG9ydGVkIG1vZHVsZXMgY29udGFpbiBzcGVjaWFsIG1ldGFkYXRhXG4gICAgLy8gZ2VuZXJhdGVkIGJ5IGNsdXR6LCB3aGljaCB0c2lja2xlIHVzZXMgdG8gdHJhbnNmb3JtIGltcG9ydHMgYW5kIHJlZmVyZW5jZXMgdG8gdGhvc2UgaW1wb3J0cy5cbiAgICAvL1xuICAgIC8vIFRPRE8oYWx4aHViKTogYWRkIGEgdGVzdCBmb3IgdGhpcyB3aGVuIHRzaWNrbGUgaXMgdXBkYXRlZCBleHRlcm5hbGx5IHRvIGRlcGVuZCBvbiB0aGlzXG4gICAgLy8gYmVoYXZpb3IuXG4gICAgdHMuc2V0T3JpZ2luYWxOb2RlKGkucXVhbGlmaWVyLCBkZWNsKTtcblxuICAgIHJldHVybiBkZWNsO1xuICB9KTtcblxuICAvLyBGaWx0ZXIgb3V0IHRoZSBleGlzdGluZyBpbXBvcnRzIGFuZCB0aGUgc291cmNlIGZpbGUgYm9keS4gQWxsIG5ldyBzdGF0ZW1lbnRzXG4gIC8vIHdpbGwgYmUgaW5zZXJ0ZWQgYmV0d2VlbiB0aGVtLlxuICBjb25zdCBleGlzdGluZ0ltcG9ydHMgPSBzZi5zdGF0ZW1lbnRzLmZpbHRlcihzdG10ID0+IGlzSW1wb3J0U3RhdGVtZW50KHN0bXQpKTtcbiAgY29uc3QgYm9keSA9IHNmLnN0YXRlbWVudHMuZmlsdGVyKHN0bXQgPT4gIWlzSW1wb3J0U3RhdGVtZW50KHN0bXQpKTtcbiAgLy8gUHJlcGVuZCBpbXBvcnRzIGlmIG5lZWRlZC5cbiAgaWYgKGFkZGVkSW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgd2UgcHJlcGVuZCBpbXBvcnRzLCB3ZSBhbHNvIHByZXBlbmQgTm90RW1pdHRlZFN0YXRlbWVudCB0byB1c2UgaXQgYXMgYW4gYW5jaG9yXG4gICAgLy8gZm9yIEBmaWxlb3ZlcnZpZXcgQ2xvc3VyZSBhbm5vdGF0aW9uLiBJZiB0aGVyZSBpcyBubyBAZmlsZW92ZXJ2aWV3IGFubm90YXRpb25zLCB0aGlzXG4gICAgLy8gc3RhdGVtZW50IHdvdWxkIGJlIGEgbm9vcC5cbiAgICBjb25zdCBmaWxlb3ZlcnZpZXdBbmNob3JTdG10ID0gdHMuY3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudChzZik7XG4gICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNmLCB0cy5jcmVhdGVOb2RlQXJyYXkoW1xuICAgICAgZmlsZW92ZXJ2aWV3QW5jaG9yU3RtdCwgLi4uZXhpc3RpbmdJbXBvcnRzLCAuLi5hZGRlZEltcG9ydHMsIC4uLmV4dHJhU3RhdGVtZW50cywgLi4uYm9keVxuICAgIF0pKTtcbiAgfVxuXG4gIHJldHVybiBzZjtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnRTdGF0ZW1lbnQoc3RtdDogdHMuU3RhdGVtZW50KTogYm9vbGVhbiB7XG4gIHJldHVybiB0cy5pc0ltcG9ydERlY2xhcmF0aW9uKHN0bXQpIHx8IHRzLmlzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24oc3RtdCkgfHxcbiAgICAgIHRzLmlzTmFtZXNwYWNlSW1wb3J0KHN0bXQpO1xufVxuIl19