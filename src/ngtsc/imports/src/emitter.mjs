/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ExternalExpr, ExternalReference, WrappedNodeExpr } from '@angular/compiler';
import * as ts from 'typescript';
import { absoluteFromSourceFile, dirname, LogicalProjectPath, relative, toRelativeImport } from '../../file_system';
import { stripExtension } from '../../file_system/src/util';
import { getSourceFile, isDeclaration, isNamedDeclaration, isTypeDeclaration, nodeNameForError } from '../../util/src/typescript';
import { findExportedNameOfNode } from './find_export';
/**
 * Flags which alter the imports generated by the `ReferenceEmitter`.
 */
export var ImportFlags;
(function (ImportFlags) {
    ImportFlags[ImportFlags["None"] = 0] = "None";
    /**
     * Force the generation of a new import when generating a reference, even if an identifier already
     * exists in the target file which could be used instead.
     *
     * This is sometimes required if there's a risk TypeScript might remove imports during emit.
     */
    ImportFlags[ImportFlags["ForceNewImport"] = 1] = "ForceNewImport";
    /**
     * Don't make use of any aliasing information when emitting a reference.
     *
     * This is sometimes required if emitting into a context where generated references will be fed
     * into TypeScript and type-checked (such as in template type-checking).
     */
    ImportFlags[ImportFlags["NoAliasing"] = 2] = "NoAliasing";
    /**
     * Indicates that an import to a type-only declaration is allowed.
     *
     * For references that occur in type-positions, the referred declaration may be a type-only
     * declaration that is not retained during emit. Including this flag allows to emit references to
     * type-only declarations as used in e.g. template type-checking.
     */
    ImportFlags[ImportFlags["AllowTypeImports"] = 4] = "AllowTypeImports";
})(ImportFlags || (ImportFlags = {}));
/**
 * Generates `Expression`s which refer to `Reference`s in a given context.
 *
 * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
 * `Expression` which refers to a `Reference` in the context of a particular file.
 */
export class ReferenceEmitter {
    constructor(strategies) {
        this.strategies = strategies;
    }
    emit(ref, context, importFlags = ImportFlags.None) {
        for (const strategy of this.strategies) {
            const emitted = strategy.emit(ref, context, importFlags);
            if (emitted !== null) {
                return emitted;
            }
        }
        throw new Error(`Unable to write a reference to ${nodeNameForError(ref.node)} in ${ref.node.getSourceFile().fileName} from ${context.fileName}`);
    }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
 * such identifiers are available.
 */
export class LocalIdentifierStrategy {
    emit(ref, context, importFlags) {
        const refSf = getSourceFile(ref.node);
        // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
        // local identifier at all, *except* in the source file where the node is actually declared.
        if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {
            return null;
        }
        // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,
        // etc) and it is in the current file then just use it directly.
        // This is important because the reference could be a property access (e.g. `exports.foo`). In
        // such a case, the reference's `identities` property would be `[foo]`, which would result in an
        // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.
        if (!isDeclaration(ref.node) && refSf === context) {
            return {
                expression: new WrappedNodeExpr(ref.node),
                importedFile: null,
            };
        }
        // A Reference can have multiple identities in different files, so it may already have an
        // Identifier in the requested context file.
        const identifier = ref.getIdentityIn(context);
        if (identifier !== null) {
            return {
                expression: new WrappedNodeExpr(identifier),
                importedFile: null,
            };
        }
        else {
            return null;
        }
    }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
 * an absolute import.
 *
 * Part of this strategy involves looking at the target entry point and identifying the exported
 * name of the targeted declaration, as it might be different from the declared name (e.g. a
 * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
 * which maps back to the original directive, an error is thrown.
 */
export class AbsoluteModuleStrategy {
    constructor(program, checker, moduleResolver, reflectionHost) {
        this.program = program;
        this.checker = checker;
        this.moduleResolver = moduleResolver;
        this.reflectionHost = reflectionHost;
        /**
         * A cache of the exports of specific modules, because resolving a module to its exports is a
         * costly operation.
         */
        this.moduleExportsCache = new Map();
    }
    emit(ref, context, importFlags) {
        if (ref.bestGuessOwningModule === null) {
            // There is no module name available for this Reference, meaning it was arrived at via a
            // relative path.
            return null;
        }
        else if (!isDeclaration(ref.node)) {
            // It's not possible to import something which isn't a declaration.
            throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${ts.SyntaxKind[ref.node.kind]}.`);
        }
        else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {
            throw new Error(`Importing a type-only declaration of type ${ts.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);
        }
        // Try to find the exported name of the declaration, if one is available.
        const { specifier, resolutionContext } = ref.bestGuessOwningModule;
        const exports = this.getExportsOfModule(specifier, resolutionContext);
        if (exports === null || !exports.exportMap.has(ref.node)) {
            // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be
            // triggered.
            throw new Error(`Symbol ${ref.debugName} declared in ${getSourceFile(ref.node).fileName} is not exported from ${specifier} (import into ${context.fileName})`);
        }
        const symbolName = exports.exportMap.get(ref.node);
        return {
            expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),
            importedFile: exports.module,
        };
    }
    getExportsOfModule(moduleName, fromFile) {
        if (!this.moduleExportsCache.has(moduleName)) {
            this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
        }
        return this.moduleExportsCache.get(moduleName);
    }
    enumerateExportsOfModule(specifier, fromFile) {
        // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
        const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
        if (entryPointFile === null) {
            return null;
        }
        const exports = this.reflectionHost.getExportsOfModule(entryPointFile);
        if (exports === null) {
            return null;
        }
        const exportMap = new Map();
        for (const [name, declaration] of exports) {
            if (exportMap.has(declaration.node)) {
                // An export for this declaration has already been registered. We prefer an export that
                // has the same name as the declared name, i.e. is not an aliased export. This is relevant
                // for partial compilations where emitted references should import symbols using a stable
                // name. This is particularly relevant for declarations inside VE-generated libraries, as
                // such libraries contain private, unstable reexports of symbols.
                const existingExport = exportMap.get(declaration.node);
                if (isNamedDeclaration(declaration.node) && declaration.node.name.text === existingExport) {
                    continue;
                }
            }
            exportMap.set(declaration.node, name);
        }
        return { module: entryPointFile, exportMap };
    }
}
/**
 * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
 * both in the logical project "space" of paths.
 *
 * This is trickier than it sounds, as the two files may be in different root directories in the
 * project. Simply calculating a file system relative path between the two is not sufficient.
 * Instead, `LogicalProjectPath`s are used.
 */
export class LogicalProjectStrategy {
    constructor(reflector, logicalFs) {
        this.reflector = reflector;
        this.logicalFs = logicalFs;
    }
    emit(ref, context) {
        const destSf = getSourceFile(ref.node);
        // Compute the relative path from the importing file to the file being imported. This is done
        // as a logical path computation, because the two files might be in different rootDirs.
        const destPath = this.logicalFs.logicalPathOfSf(destSf);
        if (destPath === null) {
            // The imported file is not within the logical project filesystem.
            return null;
        }
        const originPath = this.logicalFs.logicalPathOfSf(context);
        if (originPath === null) {
            throw new Error(`Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);
        }
        // There's no way to emit a relative reference from a file to itself.
        if (destPath === originPath) {
            return null;
        }
        const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
        if (name === null) {
            // The target declaration isn't exported from the file it's declared in. This is an issue!
            return null;
        }
        // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
        // path is now straightforward.
        const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);
        return {
            expression: new ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
/**
 * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
 *
 * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
 * necessitates the stronger logic of `LogicalProjectStrategy`.
 */
export class RelativePathStrategy {
    constructor(reflector) {
        this.reflector = reflector;
    }
    emit(ref, context) {
        const destSf = getSourceFile(ref.node);
        const relativePath = relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));
        const moduleName = toRelativeImport(stripExtension(relativePath));
        const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
        return { expression: new ExternalExpr({ moduleName, name }), importedFile: destSf };
    }
}
/**
 * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
 * references.
 */
export class UnifiedModulesStrategy {
    constructor(reflector, unifiedModulesHost) {
        this.reflector = reflector;
        this.unifiedModulesHost = unifiedModulesHost;
    }
    emit(ref, context) {
        const destSf = getSourceFile(ref.node);
        const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
        if (name === null) {
            return null;
        }
        const moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);
        return {
            expression: new ExternalExpr({ moduleName, name }),
            importedFile: destSf,
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1pdHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvaW1wb3J0cy9zcmMvZW1pdHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFDSCxPQUFPLEVBQWEsWUFBWSxFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQy9GLE9BQU8sS0FBSyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBR2pDLE9BQU8sRUFBQyxzQkFBc0IsRUFBRSxPQUFPLEVBQXFCLGtCQUFrQixFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ3JJLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUUxRCxPQUFPLEVBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRWhJLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUtyRDs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFdBMkJYO0FBM0JELFdBQVksV0FBVztJQUNyQiw2Q0FBVyxDQUFBO0lBRVg7Ozs7O09BS0c7SUFDSCxpRUFBcUIsQ0FBQTtJQUVyQjs7Ozs7T0FLRztJQUNILHlEQUFpQixDQUFBO0lBRWpCOzs7Ozs7T0FNRztJQUNILHFFQUF1QixDQUFBO0FBQ3pCLENBQUMsRUEzQlcsV0FBVyxLQUFYLFdBQVcsUUEyQnRCO0FBMEREOzs7OztHQUtHO0FBQ0gsTUFBTSxPQUFPLGdCQUFnQjtJQUMzQixZQUFvQixVQUFtQztRQUFuQyxlQUFVLEdBQVYsVUFBVSxDQUF5QjtJQUFHLENBQUM7SUFFM0QsSUFBSSxDQUFDLEdBQWMsRUFBRSxPQUFzQixFQUFFLGNBQTJCLFdBQVcsQ0FBQyxJQUFJO1FBRXRGLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUN0QyxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDekQsSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFO2dCQUNwQixPQUFPLE9BQU8sQ0FBQzthQUNoQjtTQUNGO1FBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUN4RSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFFBQVEsU0FBUyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNwRSxDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sdUJBQXVCO0lBQ2xDLElBQUksQ0FBQyxHQUFjLEVBQUUsT0FBc0IsRUFBRSxXQUF3QjtRQUNuRSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRDLDZGQUE2RjtRQUM3Riw0RkFBNEY7UUFDNUYsSUFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDLGNBQWMsSUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFO1lBQ2pFLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCwrRkFBK0Y7UUFDL0YsZ0VBQWdFO1FBQ2hFLDhGQUE4RjtRQUM5RixnR0FBZ0c7UUFDaEcsbUZBQW1GO1FBQ25GLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssS0FBSyxPQUFPLEVBQUU7WUFDakQsT0FBTztnQkFDTCxVQUFVLEVBQUUsSUFBSSxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztnQkFDekMsWUFBWSxFQUFFLElBQUk7YUFDbkIsQ0FBQztTQUNIO1FBRUQseUZBQXlGO1FBQ3pGLDRDQUE0QztRQUM1QyxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLElBQUksVUFBVSxLQUFLLElBQUksRUFBRTtZQUN2QixPQUFPO2dCQUNMLFVBQVUsRUFBRSxJQUFJLGVBQWUsQ0FBQyxVQUFVLENBQUM7Z0JBQzNDLFlBQVksRUFBRSxJQUFJO2FBQ25CLENBQUM7U0FDSDthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtJQUNILENBQUM7Q0FDRjtBQWlCRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sT0FBTyxzQkFBc0I7SUFPakMsWUFDYyxPQUFtQixFQUFZLE9BQXVCLEVBQ3RELGNBQThCLEVBQVUsY0FBOEI7UUFEdEUsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFZLFlBQU8sR0FBUCxPQUFPLENBQWdCO1FBQ3RELG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUFVLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQVJwRjs7O1dBR0c7UUFDSyx1QkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBOEIsQ0FBQztJQUlvQixDQUFDO0lBRXhGLElBQUksQ0FBQyxHQUFjLEVBQUUsT0FBc0IsRUFBRSxXQUF3QjtRQUNuRSxJQUFJLEdBQUcsQ0FBQyxxQkFBcUIsS0FBSyxJQUFJLEVBQUU7WUFDdEMsd0ZBQXdGO1lBQ3hGLGlCQUFpQjtZQUNqQixPQUFPLElBQUksQ0FBQztTQUNiO2FBQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDbkMsbUVBQW1FO1lBQ25FLE1BQU0sSUFBSSxLQUFLLENBQUMseUVBQ1osRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN0QzthQUFNLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM1RixNQUFNLElBQUksS0FBSyxDQUFDLDZDQUNaLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsc0NBQXNDLENBQUMsQ0FBQztTQUN6RTtRQUVELHlFQUF5RTtRQUN6RSxNQUFNLEVBQUMsU0FBUyxFQUFFLGlCQUFpQixFQUFDLEdBQUcsR0FBRyxDQUFDLHFCQUFxQixDQUFDO1FBQ2pFLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUN0RSxJQUFJLE9BQU8sS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDeEQsOEZBQThGO1lBQzlGLGFBQWE7WUFDYixNQUFNLElBQUksS0FBSyxDQUFDLFVBQVUsR0FBRyxDQUFDLFNBQVMsZ0JBQ25DLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSx5QkFBeUIsU0FBUyxpQkFDbEUsT0FBTyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7U0FDMUI7UUFDRCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFFLENBQUM7UUFFcEQsT0FBTztZQUNMLFVBQVUsRUFBRSxJQUFJLFlBQVksQ0FBQyxJQUFJLGlCQUFpQixDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUMxRSxZQUFZLEVBQUUsT0FBTyxDQUFDLE1BQU07U0FDN0IsQ0FBQztJQUNKLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxVQUFrQixFQUFFLFFBQWdCO1FBQzdELElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzVDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUM5RjtRQUNELE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUUsQ0FBQztJQUNsRCxDQUFDO0lBRVMsd0JBQXdCLENBQUMsU0FBaUIsRUFBRSxRQUFnQjtRQUNwRSx3RkFBd0Y7UUFDeEYsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQzlFLElBQUksY0FBYyxLQUFLLElBQUksRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN2RSxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxFQUEyQixDQUFDO1FBQ3JELEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsSUFBSSxPQUFPLEVBQUU7WUFDekMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDbkMsdUZBQXVGO2dCQUN2RiwwRkFBMEY7Z0JBQzFGLHlGQUF5RjtnQkFDekYseUZBQXlGO2dCQUN6RixpRUFBaUU7Z0JBQ2pFLE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBRSxDQUFDO2dCQUN4RCxJQUFJLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxFQUFFO29CQUN6RixTQUFTO2lCQUNWO2FBQ0Y7WUFDRCxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdkM7UUFDRCxPQUFPLEVBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUMsQ0FBQztJQUM3QyxDQUFDO0NBQ0Y7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxPQUFPLHNCQUFzQjtJQUNqQyxZQUFvQixTQUF5QixFQUFVLFNBQTRCO1FBQS9ELGNBQVMsR0FBVCxTQUFTLENBQWdCO1FBQVUsY0FBUyxHQUFULFNBQVMsQ0FBbUI7SUFBRyxDQUFDO0lBRXZGLElBQUksQ0FBQyxHQUFjLEVBQUUsT0FBc0I7UUFDekMsTUFBTSxNQUFNLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV2Qyw2RkFBNkY7UUFDN0YsdUZBQXVGO1FBQ3ZGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hELElBQUksUUFBUSxLQUFLLElBQUksRUFBRTtZQUNyQixrRUFBa0U7WUFDbEUsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNELElBQUksVUFBVSxLQUFLLElBQUksRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUNYLHdDQUF3QyxPQUFPLENBQUMsUUFBUSxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQy9GO1FBRUQscUVBQXFFO1FBQ3JFLElBQUksUUFBUSxLQUFLLFVBQVUsRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxJQUFJLEdBQUcsc0JBQXNCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RFLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtZQUNqQiwwRkFBMEY7WUFDMUYsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELCtGQUErRjtRQUMvRiwrQkFBK0I7UUFDL0IsTUFBTSxVQUFVLEdBQUcsa0JBQWtCLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ2hGLE9BQU87WUFDTCxVQUFVLEVBQUUsSUFBSSxZQUFZLENBQUMsRUFBQyxVQUFVLEVBQUUsSUFBSSxFQUFDLENBQUM7WUFDaEQsWUFBWSxFQUFFLE1BQU07U0FDckIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxPQUFPLG9CQUFvQjtJQUMvQixZQUFvQixTQUF5QjtRQUF6QixjQUFTLEdBQVQsU0FBUyxDQUFnQjtJQUFHLENBQUM7SUFFakQsSUFBSSxDQUFDLEdBQWMsRUFBRSxPQUFzQjtRQUN6QyxNQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLE1BQU0sWUFBWSxHQUNkLFFBQVEsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3ZGLE1BQU0sVUFBVSxHQUFHLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBRWxFLE1BQU0sSUFBSSxHQUFHLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0RSxPQUFPLEVBQUMsVUFBVSxFQUFFLElBQUksWUFBWSxDQUFDLEVBQUMsVUFBVSxFQUFFLElBQUksRUFBQyxDQUFDLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBQyxDQUFDO0lBQ2xGLENBQUM7Q0FDRjtBQUVEOzs7R0FHRztBQUNILE1BQU0sT0FBTyxzQkFBc0I7SUFDakMsWUFBb0IsU0FBeUIsRUFBVSxrQkFBc0M7UUFBekUsY0FBUyxHQUFULFNBQVMsQ0FBZ0I7UUFBVSx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO0lBQUcsQ0FBQztJQUVqRyxJQUFJLENBQUMsR0FBYyxFQUFFLE9BQXNCO1FBQ3pDLE1BQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkMsTUFBTSxJQUFJLEdBQUcsc0JBQXNCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RFLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtZQUNqQixPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxVQUFVLEdBQ1osSUFBSSxDQUFDLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXBGLE9BQU87WUFDTCxVQUFVLEVBQUUsSUFBSSxZQUFZLENBQUMsRUFBQyxVQUFVLEVBQUUsSUFBSSxFQUFDLENBQUM7WUFDaEQsWUFBWSxFQUFFLE1BQU07U0FDckIsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHtFeHByZXNzaW9uLCBFeHRlcm5hbEV4cHIsIEV4dGVybmFsUmVmZXJlbmNlLCBXcmFwcGVkTm9kZUV4cHJ9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge1VuaWZpZWRNb2R1bGVzSG9zdH0gZnJvbSAnLi4vLi4vY29yZS9hcGknO1xuaW1wb3J0IHthYnNvbHV0ZUZyb21Tb3VyY2VGaWxlLCBkaXJuYW1lLCBMb2dpY2FsRmlsZVN5c3RlbSwgTG9naWNhbFByb2plY3RQYXRoLCByZWxhdGl2ZSwgdG9SZWxhdGl2ZUltcG9ydH0gZnJvbSAnLi4vLi4vZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtzdHJpcEV4dGVuc2lvbn0gZnJvbSAnLi4vLi4vZmlsZV9zeXN0ZW0vc3JjL3V0aWwnO1xuaW1wb3J0IHtEZWNsYXJhdGlvbk5vZGUsIFJlZmxlY3Rpb25Ib3N0fSBmcm9tICcuLi8uLi9yZWZsZWN0aW9uJztcbmltcG9ydCB7Z2V0U291cmNlRmlsZSwgaXNEZWNsYXJhdGlvbiwgaXNOYW1lZERlY2xhcmF0aW9uLCBpc1R5cGVEZWNsYXJhdGlvbiwgbm9kZU5hbWVGb3JFcnJvcn0gZnJvbSAnLi4vLi4vdXRpbC9zcmMvdHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7ZmluZEV4cG9ydGVkTmFtZU9mTm9kZX0gZnJvbSAnLi9maW5kX2V4cG9ydCc7XG5pbXBvcnQge1JlZmVyZW5jZX0gZnJvbSAnLi9yZWZlcmVuY2VzJztcbmltcG9ydCB7TW9kdWxlUmVzb2x2ZXJ9IGZyb20gJy4vcmVzb2x2ZXInO1xuXG5cbi8qKlxuICogRmxhZ3Mgd2hpY2ggYWx0ZXIgdGhlIGltcG9ydHMgZ2VuZXJhdGVkIGJ5IHRoZSBgUmVmZXJlbmNlRW1pdHRlcmAuXG4gKi9cbmV4cG9ydCBlbnVtIEltcG9ydEZsYWdzIHtcbiAgTm9uZSA9IDB4MDAsXG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBnZW5lcmF0aW9uIG9mIGEgbmV3IGltcG9ydCB3aGVuIGdlbmVyYXRpbmcgYSByZWZlcmVuY2UsIGV2ZW4gaWYgYW4gaWRlbnRpZmllciBhbHJlYWR5XG4gICAqIGV4aXN0cyBpbiB0aGUgdGFyZ2V0IGZpbGUgd2hpY2ggY291bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGlzIGlzIHNvbWV0aW1lcyByZXF1aXJlZCBpZiB0aGVyZSdzIGEgcmlzayBUeXBlU2NyaXB0IG1pZ2h0IHJlbW92ZSBpbXBvcnRzIGR1cmluZyBlbWl0LlxuICAgKi9cbiAgRm9yY2VOZXdJbXBvcnQgPSAweDAxLFxuXG4gIC8qKlxuICAgKiBEb24ndCBtYWtlIHVzZSBvZiBhbnkgYWxpYXNpbmcgaW5mb3JtYXRpb24gd2hlbiBlbWl0dGluZyBhIHJlZmVyZW5jZS5cbiAgICpcbiAgICogVGhpcyBpcyBzb21ldGltZXMgcmVxdWlyZWQgaWYgZW1pdHRpbmcgaW50byBhIGNvbnRleHQgd2hlcmUgZ2VuZXJhdGVkIHJlZmVyZW5jZXMgd2lsbCBiZSBmZWRcbiAgICogaW50byBUeXBlU2NyaXB0IGFuZCB0eXBlLWNoZWNrZWQgKHN1Y2ggYXMgaW4gdGVtcGxhdGUgdHlwZS1jaGVja2luZykuXG4gICAqL1xuICBOb0FsaWFzaW5nID0gMHgwMixcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgYW4gaW1wb3J0IHRvIGEgdHlwZS1vbmx5IGRlY2xhcmF0aW9uIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEZvciByZWZlcmVuY2VzIHRoYXQgb2NjdXIgaW4gdHlwZS1wb3NpdGlvbnMsIHRoZSByZWZlcnJlZCBkZWNsYXJhdGlvbiBtYXkgYmUgYSB0eXBlLW9ubHlcbiAgICogZGVjbGFyYXRpb24gdGhhdCBpcyBub3QgcmV0YWluZWQgZHVyaW5nIGVtaXQuIEluY2x1ZGluZyB0aGlzIGZsYWcgYWxsb3dzIHRvIGVtaXQgcmVmZXJlbmNlcyB0b1xuICAgKiB0eXBlLW9ubHkgZGVjbGFyYXRpb25zIGFzIHVzZWQgaW4gZS5nLiB0ZW1wbGF0ZSB0eXBlLWNoZWNraW5nLlxuICAgKi9cbiAgQWxsb3dUeXBlSW1wb3J0cyA9IDB4MDQsXG59XG5cbi8qKlxuICogQW4gZW1pdHRlciBzdHJhdGVneSBoYXMgdGhlIGFiaWxpdHkgdG8gaW5kaWNhdGUgd2hpY2ggYHRzLlNvdXJjZUZpbGVgIGlzIGJlaW5nIGltcG9ydGVkIGJ5IHRoZVxuICogZXhwcmVzc2lvbiB0aGF0IGl0IGhhcyBnZW5lcmF0ZWQuIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZnVsIGZvciBjb25zdW1lcnMgb2YgdGhlIGVtaXR0ZWRcbiAqIHJlZmVyZW5jZSB0aGF0IHdvdWxkIG90aGVyd2lzZSBoYXZlIHRvIHBlcmZvcm0gYSByZWxhdGl2ZWx5IGV4cGVuc2l2ZSBtb2R1bGUgcmVzb2x1dGlvbiBzdGVwLFxuICogZS5nLiBmb3IgY3ljbGljIGltcG9ydCBhbmFseXNpcy4gSW4gY2FzZXMgdGhlIGVtaXR0ZXIgaXMgdW5hYmxlIHRvIGRlZmluaXRpdmVseSBkZXRlcm1pbmUgdGhlXG4gKiBpbXBvcnRlZCBzb3VyY2UgZmlsZSBvciBhIGNvbXB1dGF0aW9uIHdvdWxkIGJlIHJlcXVpcmVkIHRvIGFjdHVhbGx5IGRldGVybWluZSB0aGUgaW1wb3J0ZWRcbiAqIHNvdXJjZSBmaWxlLCB0aGVuIGAndW5rbm93bidgIHNob3VsZCBiZSByZXR1cm5lZC4gSWYgdGhlIGdlbmVyYXRlZCBleHByZXNzaW9uIGRvZXMgbm90IHJlcHJlc2VudFxuICogYW4gaW1wb3J0IHRoZW4gYG51bGxgIHNob3VsZCBiZSB1c2VkLlxuICovXG5leHBvcnQgdHlwZSBJbXBvcnRlZEZpbGUgPSB0cy5Tb3VyY2VGaWxlfCd1bmtub3duJ3xudWxsO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGVtaXR0ZWQgZXhwcmVzc2lvbiBvZiBhIGBSZWZlcmVuY2VgIHRoYXQgaXMgdmFsaWQgaW4gdGhlIHNvdXJjZSBmaWxlIGl0IHdhc1xuICogZW1pdHRlZCBmcm9tLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVtaXR0ZWRSZWZlcmVuY2Uge1xuICAvKipcbiAgICogVGhlIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gYFJlZmVyZW5jZWAuXG4gICAqL1xuICBleHByZXNzaW9uOiBFeHByZXNzaW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgYHRzLlNvdXJjZUZpbGVgIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYGV4cHJlc3Npb25gLiBUaGlzIGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgc291cmNlIGZpbGVcbiAgICogb2YgdGhlIGBSZWZlcmVuY2VgJ3MgZGVjbGFyYXRpb24gbm9kZSwgYXMgdGhlIHJlZmVyZW5jZSBtYXkgaGF2ZSBiZWVuIHJld3JpdHRlbiB0aHJvdWdoIGFuXG4gICAqIGFsaWFzIGV4cG9ydC4gSXQgY291bGQgYWxzbyBiZSBgbnVsbGAgaWYgYGV4cHJlc3Npb25gIGlzIGEgbG9jYWwgaWRlbnRpZmllciwgb3IgYCd1bmtub3duJ2AgaWZcbiAgICogdGhlIGV4YWN0IHNvdXJjZSBmaWxlIHRoYXQgaXMgYmVpbmcgaW1wb3J0ZWQgaXMgbm90IGtub3duIHRvIHRoZSBlbWl0dGVyLlxuICAgKi9cbiAgaW1wb3J0ZWRGaWxlOiBJbXBvcnRlZEZpbGU7XG59XG5cbi8qKlxuICogQSBwYXJ0aWN1bGFyIHN0cmF0ZWd5IGZvciBnZW5lcmF0aW5nIGFuIGV4cHJlc3Npb24gd2hpY2ggcmVmZXJzIHRvIGEgYFJlZmVyZW5jZWAuXG4gKlxuICogVGhlcmUgYXJlIG1hbnkgcG90ZW50aWFsIHdheXMgYSBnaXZlbiBgUmVmZXJlbmNlYCBjb3VsZCBiZSByZWZlcnJlZCB0byBpbiB0aGUgY29udGV4dCBvZiBhIGdpdmVuXG4gKiBmaWxlLiBBIGxvY2FsIGRlY2xhcmF0aW9uIGNvdWxkIGJlIGF2YWlsYWJsZSwgdGhlIGBSZWZlcmVuY2VgIGNvdWxkIGJlIGltcG9ydGFibGUgdmlhIGEgcmVsYXRpdmVcbiAqIGltcG9ydCB3aXRoaW4gdGhlIHByb2plY3QsIG9yIGFuIGFic29sdXRlIGltcG9ydCBpbnRvIGBub2RlX21vZHVsZXNgIG1pZ2h0IGJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBEaWZmZXJlbnQgYFJlZmVyZW5jZUVtaXRTdHJhdGVneWAgaW1wbGVtZW50YXRpb25zIGltcGxlbWVudCBzcGVjaWZpYyBsb2dpYyBmb3IgZ2VuZXJhdGluZyBzdWNoXG4gKiByZWZlcmVuY2VzLiBBIHNpbmdsZSBzdHJhdGVneSAoc3VjaCBhcyB1c2luZyBhIGxvY2FsIGRlY2xhcmF0aW9uKSBtYXkgbm90IGFsd2F5cyBiZSBhYmxlIHRvXG4gKiBnZW5lcmF0ZSBhbiBleHByZXNzaW9uIGZvciBldmVyeSBgUmVmZXJlbmNlYCAoZm9yIGV4YW1wbGUsIGlmIG5vIGxvY2FsIGlkZW50aWZpZXIgaXMgYXZhaWxhYmxlKSxcbiAqIGFuZCBtYXkgcmV0dXJuIGBudWxsYCBpbiBzdWNoIGEgY2FzZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWZlcmVuY2VFbWl0U3RyYXRlZ3kge1xuICAvKipcbiAgICogRW1pdCBhbiBgRXhwcmVzc2lvbmAgd2hpY2ggcmVmZXJzIHRvIHRoZSBnaXZlbiBgUmVmZXJlbmNlYCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXJcbiAgICogc291cmNlIGZpbGUsIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gcmVmIHRoZSBgUmVmZXJlbmNlYCBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgYW4gZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gY29udGV4dCB0aGUgc291cmNlIGZpbGUgaW4gd2hpY2ggdGhlIGBFeHByZXNzaW9uYCBtdXN0IGJlIHZhbGlkXG4gICAqIEBwYXJhbSBpbXBvcnRGbGFncyBhIGZsYWcgd2hpY2ggY29udHJvbHMgd2hldGhlciBpbXBvcnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQgb3Igbm90XG4gICAqIEByZXR1cm5zIGFuIGBFbWl0dGVkUmVmZXJlbmNlYCB3aGljaCByZWZlcnMgdG8gdGhlIGBSZWZlcmVuY2VgLCBvciBgbnVsbGAgaWYgbm9uZSBjYW4gYmVcbiAgICogICBnZW5lcmF0ZWRcbiAgICovXG4gIGVtaXQocmVmOiBSZWZlcmVuY2UsIGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUsIGltcG9ydEZsYWdzOiBJbXBvcnRGbGFncyk6IEVtaXR0ZWRSZWZlcmVuY2V8bnVsbDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYEV4cHJlc3Npb25gcyB3aGljaCByZWZlciB0byBgUmVmZXJlbmNlYHMgaW4gYSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEEgYFJlZmVyZW5jZUVtaXR0ZXJgIHVzZXMgb25lIG9yIG1vcmUgYFJlZmVyZW5jZUVtaXRTdHJhdGVneWAgaW1wbGVtZW50YXRpb25zIHRvIHByb2R1Y2UgYW5cbiAqIGBFeHByZXNzaW9uYCB3aGljaCByZWZlcnMgdG8gYSBgUmVmZXJlbmNlYCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcnRpY3VsYXIgZmlsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmVyZW5jZUVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0cmF0ZWdpZXM6IFJlZmVyZW5jZUVtaXRTdHJhdGVneVtdKSB7fVxuXG4gIGVtaXQocmVmOiBSZWZlcmVuY2UsIGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUsIGltcG9ydEZsYWdzOiBJbXBvcnRGbGFncyA9IEltcG9ydEZsYWdzLk5vbmUpOlxuICAgICAgRW1pdHRlZFJlZmVyZW5jZSB7XG4gICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiB0aGlzLnN0cmF0ZWdpZXMpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWQgPSBzdHJhdGVneS5lbWl0KHJlZiwgY29udGV4dCwgaW1wb3J0RmxhZ3MpO1xuICAgICAgaWYgKGVtaXR0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHdyaXRlIGEgcmVmZXJlbmNlIHRvICR7bm9kZU5hbWVGb3JFcnJvcihyZWYubm9kZSl9IGluICR7XG4gICAgICAgIHJlZi5ub2RlLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZX0gZnJvbSAke2NvbnRleHQuZmlsZU5hbWV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGBSZWZlcmVuY2VFbWl0U3RyYXRlZ3lgIHdoaWNoIHdpbGwgcmVmZXIgdG8gZGVjbGFyYXRpb25zIGJ5IGFueSBsb2NhbCBgdHMuSWRlbnRpZmllcmBzLCBpZlxuICogc3VjaCBpZGVudGlmaWVycyBhcmUgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgY2xhc3MgTG9jYWxJZGVudGlmaWVyU3RyYXRlZ3kgaW1wbGVtZW50cyBSZWZlcmVuY2VFbWl0U3RyYXRlZ3kge1xuICBlbWl0KHJlZjogUmVmZXJlbmNlLCBjb250ZXh0OiB0cy5Tb3VyY2VGaWxlLCBpbXBvcnRGbGFnczogSW1wb3J0RmxhZ3MpOiBFbWl0dGVkUmVmZXJlbmNlfG51bGwge1xuICAgIGNvbnN0IHJlZlNmID0gZ2V0U291cmNlRmlsZShyZWYubm9kZSk7XG5cbiAgICAvLyBJZiB0aGUgZW1pdHRlciBoYXMgc3BlY2lmaWVkIEZvcmNlTmV3SW1wb3J0LCB0aGVuIExvY2FsSWRlbnRpZmllclN0cmF0ZWd5IHNob3VsZCBub3QgdXNlIGFcbiAgICAvLyBsb2NhbCBpZGVudGlmaWVyIGF0IGFsbCwgKmV4Y2VwdCogaW4gdGhlIHNvdXJjZSBmaWxlIHdoZXJlIHRoZSBub2RlIGlzIGFjdHVhbGx5IGRlY2xhcmVkLlxuICAgIGlmIChpbXBvcnRGbGFncyAmIEltcG9ydEZsYWdzLkZvcmNlTmV3SW1wb3J0ICYmIHJlZlNmICE9PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZiByZWZlcmVuY2VkIG5vZGUgaXMgbm90IGFuIGFjdHVhbCBUUyBkZWNsYXJhdGlvbiAoZS5nLiBgY2xhc3MgRm9vYCBvciBgZnVuY3Rpb24gZm9vKCkge31gLFxuICAgIC8vIGV0YykgYW5kIGl0IGlzIGluIHRoZSBjdXJyZW50IGZpbGUgdGhlbiBqdXN0IHVzZSBpdCBkaXJlY3RseS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSByZWZlcmVuY2UgY291bGQgYmUgYSBwcm9wZXJ0eSBhY2Nlc3MgKGUuZy4gYGV4cG9ydHMuZm9vYCkuIEluXG4gICAgLy8gc3VjaCBhIGNhc2UsIHRoZSByZWZlcmVuY2UncyBgaWRlbnRpdGllc2AgcHJvcGVydHkgd291bGQgYmUgYFtmb29dYCwgd2hpY2ggd291bGQgcmVzdWx0IGluIGFuXG4gICAgLy8gaW52YWxpZCBlbWlzc2lvbiBvZiBhIGZyZWUtc3RhbmRpbmcgYGZvb2AgaWRlbnRpZmllciwgcmF0aGVyIHRoYW4gYGV4cG9ydHMuZm9vYC5cbiAgICBpZiAoIWlzRGVjbGFyYXRpb24ocmVmLm5vZGUpICYmIHJlZlNmID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHByZXNzaW9uOiBuZXcgV3JhcHBlZE5vZGVFeHByKHJlZi5ub2RlKSxcbiAgICAgICAgaW1wb3J0ZWRGaWxlOiBudWxsLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBIFJlZmVyZW5jZSBjYW4gaGF2ZSBtdWx0aXBsZSBpZGVudGl0aWVzIGluIGRpZmZlcmVudCBmaWxlcywgc28gaXQgbWF5IGFscmVhZHkgaGF2ZSBhblxuICAgIC8vIElkZW50aWZpZXIgaW4gdGhlIHJlcXVlc3RlZCBjb250ZXh0IGZpbGUuXG4gICAgY29uc3QgaWRlbnRpZmllciA9IHJlZi5nZXRJZGVudGl0eUluKGNvbnRleHQpO1xuICAgIGlmIChpZGVudGlmaWVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHByZXNzaW9uOiBuZXcgV3JhcHBlZE5vZGVFeHByKGlkZW50aWZpZXIpLFxuICAgICAgICBpbXBvcnRlZEZpbGU6IG51bGwsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBleHBvcnRlZCBkZWNsYXJhdGlvbnMgZnJvbSBhIG1vZHVsZSBzb3VyY2UgZmlsZS5cbiAqL1xuaW50ZXJmYWNlIE1vZHVsZUV4cG9ydHMge1xuICAvKipcbiAgICogVGhlIHNvdXJjZSBmaWxlIG9mIHRoZSBtb2R1bGUuXG4gICAqL1xuICBtb2R1bGU6IHRzLlNvdXJjZUZpbGU7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXAgb2YgZGVjbGFyYXRpb25zIHRvIHRoZWlyIGV4cG9ydGVkIG5hbWUuXG4gICAqL1xuICBleHBvcnRNYXA6IE1hcDxEZWNsYXJhdGlvbk5vZGUsIHN0cmluZz47XG59XG5cbi8qKlxuICogQSBgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5YCB3aGljaCB3aWxsIHJlZmVyIHRvIGRlY2xhcmF0aW9ucyB0aGF0IGNvbWUgZnJvbSBgbm9kZV9tb2R1bGVzYCB1c2luZ1xuICogYW4gYWJzb2x1dGUgaW1wb3J0LlxuICpcbiAqIFBhcnQgb2YgdGhpcyBzdHJhdGVneSBpbnZvbHZlcyBsb29raW5nIGF0IHRoZSB0YXJnZXQgZW50cnkgcG9pbnQgYW5kIGlkZW50aWZ5aW5nIHRoZSBleHBvcnRlZFxuICogbmFtZSBvZiB0aGUgdGFyZ2V0ZWQgZGVjbGFyYXRpb24sIGFzIGl0IG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoZSBkZWNsYXJlZCBuYW1lIChlLmcuIGFcbiAqIGRpcmVjdGl2ZSBtaWdodCBiZSBkZWNsYXJlZCBhcyBGb29EaXJJbXBsLCBidXQgZXhwb3J0ZWQgYXMgRm9vRGlyKS4gSWYgbm8gZXhwb3J0IGNhbiBiZSBmb3VuZFxuICogd2hpY2ggbWFwcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBkaXJlY3RpdmUsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIEFic29sdXRlTW9kdWxlU3RyYXRlZ3kgaW1wbGVtZW50cyBSZWZlcmVuY2VFbWl0U3RyYXRlZ3kge1xuICAvKipcbiAgICogQSBjYWNoZSBvZiB0aGUgZXhwb3J0cyBvZiBzcGVjaWZpYyBtb2R1bGVzLCBiZWNhdXNlIHJlc29sdmluZyBhIG1vZHVsZSB0byBpdHMgZXhwb3J0cyBpcyBhXG4gICAqIGNvc3RseSBvcGVyYXRpb24uXG4gICAqL1xuICBwcml2YXRlIG1vZHVsZUV4cG9ydHNDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBNb2R1bGVFeHBvcnRzfG51bGw+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcm90ZWN0ZWQgcHJvZ3JhbTogdHMuUHJvZ3JhbSwgcHJvdGVjdGVkIGNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgICAgcHJvdGVjdGVkIG1vZHVsZVJlc29sdmVyOiBNb2R1bGVSZXNvbHZlciwgcHJpdmF0ZSByZWZsZWN0aW9uSG9zdDogUmVmbGVjdGlvbkhvc3QpIHt9XG5cbiAgZW1pdChyZWY6IFJlZmVyZW5jZSwgY29udGV4dDogdHMuU291cmNlRmlsZSwgaW1wb3J0RmxhZ3M6IEltcG9ydEZsYWdzKTogRW1pdHRlZFJlZmVyZW5jZXxudWxsIHtcbiAgICBpZiAocmVmLmJlc3RHdWVzc093bmluZ01vZHVsZSA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gbW9kdWxlIG5hbWUgYXZhaWxhYmxlIGZvciB0aGlzIFJlZmVyZW5jZSwgbWVhbmluZyBpdCB3YXMgYXJyaXZlZCBhdCB2aWEgYVxuICAgICAgLy8gcmVsYXRpdmUgcGF0aC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoIWlzRGVjbGFyYXRpb24ocmVmLm5vZGUpKSB7XG4gICAgICAvLyBJdCdzIG5vdCBwb3NzaWJsZSB0byBpbXBvcnQgc29tZXRoaW5nIHdoaWNoIGlzbid0IGEgZGVjbGFyYXRpb24uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERlYnVnIGFzc2VydDogdW5hYmxlIHRvIGltcG9ydCBhIFJlZmVyZW5jZSB0byBub24tZGVjbGFyYXRpb24gb2YgdHlwZSAke1xuICAgICAgICAgIHRzLlN5bnRheEtpbmRbcmVmLm5vZGUua2luZF19LmApO1xuICAgIH0gZWxzZSBpZiAoKGltcG9ydEZsYWdzICYgSW1wb3J0RmxhZ3MuQWxsb3dUeXBlSW1wb3J0cykgPT09IDAgJiYgaXNUeXBlRGVjbGFyYXRpb24ocmVmLm5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9ydGluZyBhIHR5cGUtb25seSBkZWNsYXJhdGlvbiBvZiB0eXBlICR7XG4gICAgICAgICAgdHMuU3ludGF4S2luZFtyZWYubm9kZS5raW5kXX0gaW4gYSB2YWx1ZSBwb3NpdGlvbiBpcyBub3QgYWxsb3dlZC5gKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgZXhwb3J0ZWQgbmFtZSBvZiB0aGUgZGVjbGFyYXRpb24sIGlmIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgY29uc3Qge3NwZWNpZmllciwgcmVzb2x1dGlvbkNvbnRleHR9ID0gcmVmLmJlc3RHdWVzc093bmluZ01vZHVsZTtcbiAgICBjb25zdCBleHBvcnRzID0gdGhpcy5nZXRFeHBvcnRzT2ZNb2R1bGUoc3BlY2lmaWVyLCByZXNvbHV0aW9uQ29udGV4dCk7XG4gICAgaWYgKGV4cG9ydHMgPT09IG51bGwgfHwgIWV4cG9ydHMuZXhwb3J0TWFwLmhhcyhyZWYubm9kZSkpIHtcbiAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGVycm9yIGEgdHMuRGlhZ25vc3RpYyBwb2ludGluZyBhdCB3aGF0ZXZlciBjYXVzZWQgdGhpcyBpbXBvcnQgdG8gYmVcbiAgICAgIC8vIHRyaWdnZXJlZC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3ltYm9sICR7cmVmLmRlYnVnTmFtZX0gZGVjbGFyZWQgaW4gJHtcbiAgICAgICAgICBnZXRTb3VyY2VGaWxlKHJlZi5ub2RlKS5maWxlTmFtZX0gaXMgbm90IGV4cG9ydGVkIGZyb20gJHtzcGVjaWZpZXJ9IChpbXBvcnQgaW50byAke1xuICAgICAgICAgIGNvbnRleHQuZmlsZU5hbWV9KWApO1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xOYW1lID0gZXhwb3J0cy5leHBvcnRNYXAuZ2V0KHJlZi5ub2RlKSE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcmVzc2lvbjogbmV3IEV4dGVybmFsRXhwcihuZXcgRXh0ZXJuYWxSZWZlcmVuY2Uoc3BlY2lmaWVyLCBzeW1ib2xOYW1lKSksXG4gICAgICBpbXBvcnRlZEZpbGU6IGV4cG9ydHMubW9kdWxlLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVOYW1lOiBzdHJpbmcsIGZyb21GaWxlOiBzdHJpbmcpOiBNb2R1bGVFeHBvcnRzfG51bGwge1xuICAgIGlmICghdGhpcy5tb2R1bGVFeHBvcnRzQ2FjaGUuaGFzKG1vZHVsZU5hbWUpKSB7XG4gICAgICB0aGlzLm1vZHVsZUV4cG9ydHNDYWNoZS5zZXQobW9kdWxlTmFtZSwgdGhpcy5lbnVtZXJhdGVFeHBvcnRzT2ZNb2R1bGUobW9kdWxlTmFtZSwgZnJvbUZpbGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlRXhwb3J0c0NhY2hlLmdldChtb2R1bGVOYW1lKSE7XG4gIH1cblxuICBwcm90ZWN0ZWQgZW51bWVyYXRlRXhwb3J0c09mTW9kdWxlKHNwZWNpZmllcjogc3RyaW5nLCBmcm9tRmlsZTogc3RyaW5nKTogTW9kdWxlRXhwb3J0c3xudWxsIHtcbiAgICAvLyBGaXJzdCwgcmVzb2x2ZSB0aGUgbW9kdWxlIHNwZWNpZmllciB0byBpdHMgZW50cnkgcG9pbnQsIGFuZCBnZXQgdGhlIHRzLlN5bWJvbCBmb3IgaXQuXG4gICAgY29uc3QgZW50cnlQb2ludEZpbGUgPSB0aGlzLm1vZHVsZVJlc29sdmVyLnJlc29sdmVNb2R1bGUoc3BlY2lmaWVyLCBmcm9tRmlsZSk7XG4gICAgaWYgKGVudHJ5UG9pbnRGaWxlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBleHBvcnRzID0gdGhpcy5yZWZsZWN0aW9uSG9zdC5nZXRFeHBvcnRzT2ZNb2R1bGUoZW50cnlQb2ludEZpbGUpO1xuICAgIGlmIChleHBvcnRzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXhwb3J0TWFwID0gbmV3IE1hcDxEZWNsYXJhdGlvbk5vZGUsIHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBkZWNsYXJhdGlvbl0gb2YgZXhwb3J0cykge1xuICAgICAgaWYgKGV4cG9ydE1hcC5oYXMoZGVjbGFyYXRpb24ubm9kZSkpIHtcbiAgICAgICAgLy8gQW4gZXhwb3J0IGZvciB0aGlzIGRlY2xhcmF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC4gV2UgcHJlZmVyIGFuIGV4cG9ydCB0aGF0XG4gICAgICAgIC8vIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBkZWNsYXJlZCBuYW1lLCBpLmUuIGlzIG5vdCBhbiBhbGlhc2VkIGV4cG9ydC4gVGhpcyBpcyByZWxldmFudFxuICAgICAgICAvLyBmb3IgcGFydGlhbCBjb21waWxhdGlvbnMgd2hlcmUgZW1pdHRlZCByZWZlcmVuY2VzIHNob3VsZCBpbXBvcnQgc3ltYm9scyB1c2luZyBhIHN0YWJsZVxuICAgICAgICAvLyBuYW1lLiBUaGlzIGlzIHBhcnRpY3VsYXJseSByZWxldmFudCBmb3IgZGVjbGFyYXRpb25zIGluc2lkZSBWRS1nZW5lcmF0ZWQgbGlicmFyaWVzLCBhc1xuICAgICAgICAvLyBzdWNoIGxpYnJhcmllcyBjb250YWluIHByaXZhdGUsIHVuc3RhYmxlIHJlZXhwb3J0cyBvZiBzeW1ib2xzLlxuICAgICAgICBjb25zdCBleGlzdGluZ0V4cG9ydCA9IGV4cG9ydE1hcC5nZXQoZGVjbGFyYXRpb24ubm9kZSkhO1xuICAgICAgICBpZiAoaXNOYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLm5vZGUpICYmIGRlY2xhcmF0aW9uLm5vZGUubmFtZS50ZXh0ID09PSBleGlzdGluZ0V4cG9ydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleHBvcnRNYXAuc2V0KGRlY2xhcmF0aW9uLm5vZGUsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge21vZHVsZTogZW50cnlQb2ludEZpbGUsIGV4cG9ydE1hcH07XG4gIH1cbn1cblxuLyoqXG4gKiBBIGBSZWZlcmVuY2VFbWl0U3RyYXRlZ3lgIHdoaWNoIHdpbGwgcmVmZXIgdG8gZGVjbGFyYXRpb25zIHZpYSByZWxhdGl2ZSBwYXRocywgcHJvdmlkZWQgdGhleSdyZVxuICogYm90aCBpbiB0aGUgbG9naWNhbCBwcm9qZWN0IFwic3BhY2VcIiBvZiBwYXRocy5cbiAqXG4gKiBUaGlzIGlzIHRyaWNraWVyIHRoYW4gaXQgc291bmRzLCBhcyB0aGUgdHdvIGZpbGVzIG1heSBiZSBpbiBkaWZmZXJlbnQgcm9vdCBkaXJlY3RvcmllcyBpbiB0aGVcbiAqIHByb2plY3QuIFNpbXBseSBjYWxjdWxhdGluZyBhIGZpbGUgc3lzdGVtIHJlbGF0aXZlIHBhdGggYmV0d2VlbiB0aGUgdHdvIGlzIG5vdCBzdWZmaWNpZW50LlxuICogSW5zdGVhZCwgYExvZ2ljYWxQcm9qZWN0UGF0aGBzIGFyZSB1c2VkLlxuICovXG5leHBvcnQgY2xhc3MgTG9naWNhbFByb2plY3RTdHJhdGVneSBpbXBsZW1lbnRzIFJlZmVyZW5jZUVtaXRTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVmbGVjdG9yOiBSZWZsZWN0aW9uSG9zdCwgcHJpdmF0ZSBsb2dpY2FsRnM6IExvZ2ljYWxGaWxlU3lzdGVtKSB7fVxuXG4gIGVtaXQocmVmOiBSZWZlcmVuY2UsIGNvbnRleHQ6IHRzLlNvdXJjZUZpbGUpOiBFbWl0dGVkUmVmZXJlbmNlfG51bGwge1xuICAgIGNvbnN0IGRlc3RTZiA9IGdldFNvdXJjZUZpbGUocmVmLm5vZGUpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBpbXBvcnRpbmcgZmlsZSB0byB0aGUgZmlsZSBiZWluZyBpbXBvcnRlZC4gVGhpcyBpcyBkb25lXG4gICAgLy8gYXMgYSBsb2dpY2FsIHBhdGggY29tcHV0YXRpb24sIGJlY2F1c2UgdGhlIHR3byBmaWxlcyBtaWdodCBiZSBpbiBkaWZmZXJlbnQgcm9vdERpcnMuXG4gICAgY29uc3QgZGVzdFBhdGggPSB0aGlzLmxvZ2ljYWxGcy5sb2dpY2FsUGF0aE9mU2YoZGVzdFNmKTtcbiAgICBpZiAoZGVzdFBhdGggPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBpbXBvcnRlZCBmaWxlIGlzIG5vdCB3aXRoaW4gdGhlIGxvZ2ljYWwgcHJvamVjdCBmaWxlc3lzdGVtLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luUGF0aCA9IHRoaXMubG9naWNhbEZzLmxvZ2ljYWxQYXRoT2ZTZihjb250ZXh0KTtcbiAgICBpZiAob3JpZ2luUGF0aCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBEZWJ1ZyBhc3NlcnQ6IGF0dGVtcHQgdG8gaW1wb3J0IGZyb20gJHtjb250ZXh0LmZpbGVOYW1lfSBidXQgaXQncyBvdXRzaWRlIHRoZSBwcm9ncmFtP2ApO1xuICAgIH1cblxuICAgIC8vIFRoZXJlJ3Mgbm8gd2F5IHRvIGVtaXQgYSByZWxhdGl2ZSByZWZlcmVuY2UgZnJvbSBhIGZpbGUgdG8gaXRzZWxmLlxuICAgIGlmIChkZXN0UGF0aCA9PT0gb3JpZ2luUGF0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGZpbmRFeHBvcnRlZE5hbWVPZk5vZGUocmVmLm5vZGUsIGRlc3RTZiwgdGhpcy5yZWZsZWN0b3IpO1xuICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAvLyBUaGUgdGFyZ2V0IGRlY2xhcmF0aW9uIGlzbid0IGV4cG9ydGVkIGZyb20gdGhlIGZpbGUgaXQncyBkZWNsYXJlZCBpbi4gVGhpcyBpcyBhbiBpc3N1ZSFcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFdpdGggYm90aCBmaWxlcyBleHByZXNzZWQgYXMgTG9naWNhbFByb2plY3RQYXRocywgZ2V0dGluZyB0aGUgbW9kdWxlIHNwZWNpZmllciBhcyBhIHJlbGF0aXZlXG4gICAgLy8gcGF0aCBpcyBub3cgc3RyYWlnaHRmb3J3YXJkLlxuICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBMb2dpY2FsUHJvamVjdFBhdGgucmVsYXRpdmVQYXRoQmV0d2VlbihvcmlnaW5QYXRoLCBkZXN0UGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cHJlc3Npb246IG5ldyBFeHRlcm5hbEV4cHIoe21vZHVsZU5hbWUsIG5hbWV9KSxcbiAgICAgIGltcG9ydGVkRmlsZTogZGVzdFNmLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBBIGBSZWZlcmVuY2VFbWl0U3RyYXRlZ3lgIHdoaWNoIGNvbnN0cnVjdHMgcmVsYXRpdmVzIHBhdGhzIGJldHdlZW4gYHRzLlNvdXJjZUZpbGVgcy5cbiAqXG4gKiBUaGlzIHN0cmF0ZWd5IGNhbiBiZSB1c2VkIGlmIHRoZXJlIGlzIG5vIGByb290RGlyYC9gcm9vdERpcnNgIHN0cnVjdHVyZSBmb3IgdGhlIHByb2plY3Qgd2hpY2hcbiAqIG5lY2Vzc2l0YXRlcyB0aGUgc3Ryb25nZXIgbG9naWMgb2YgYExvZ2ljYWxQcm9qZWN0U3RyYXRlZ3lgLlxuICovXG5leHBvcnQgY2xhc3MgUmVsYXRpdmVQYXRoU3RyYXRlZ3kgaW1wbGVtZW50cyBSZWZlcmVuY2VFbWl0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZmxlY3RvcjogUmVmbGVjdGlvbkhvc3QpIHt9XG5cbiAgZW1pdChyZWY6IFJlZmVyZW5jZSwgY29udGV4dDogdHMuU291cmNlRmlsZSk6IEVtaXR0ZWRSZWZlcmVuY2V8bnVsbCB7XG4gICAgY29uc3QgZGVzdFNmID0gZ2V0U291cmNlRmlsZShyZWYubm9kZSk7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID1cbiAgICAgICAgcmVsYXRpdmUoZGlybmFtZShhYnNvbHV0ZUZyb21Tb3VyY2VGaWxlKGNvbnRleHQpKSwgYWJzb2x1dGVGcm9tU291cmNlRmlsZShkZXN0U2YpKTtcbiAgICBjb25zdCBtb2R1bGVOYW1lID0gdG9SZWxhdGl2ZUltcG9ydChzdHJpcEV4dGVuc2lvbihyZWxhdGl2ZVBhdGgpKTtcblxuICAgIGNvbnN0IG5hbWUgPSBmaW5kRXhwb3J0ZWROYW1lT2ZOb2RlKHJlZi5ub2RlLCBkZXN0U2YsIHRoaXMucmVmbGVjdG9yKTtcbiAgICByZXR1cm4ge2V4cHJlc3Npb246IG5ldyBFeHRlcm5hbEV4cHIoe21vZHVsZU5hbWUsIG5hbWV9KSwgaW1wb3J0ZWRGaWxlOiBkZXN0U2Z9O1xuICB9XG59XG5cbi8qKlxuICogQSBgUmVmZXJlbmNlRW1pdFN0cmF0ZWd5YCB3aGljaCB1c2VzIGEgYFVuaWZpZWRNb2R1bGVzSG9zdGAgdG8gZ2VuZXJhdGUgYWJzb2x1dGUgaW1wb3J0XG4gKiByZWZlcmVuY2VzLlxuICovXG5leHBvcnQgY2xhc3MgVW5pZmllZE1vZHVsZXNTdHJhdGVneSBpbXBsZW1lbnRzIFJlZmVyZW5jZUVtaXRTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVmbGVjdG9yOiBSZWZsZWN0aW9uSG9zdCwgcHJpdmF0ZSB1bmlmaWVkTW9kdWxlc0hvc3Q6IFVuaWZpZWRNb2R1bGVzSG9zdCkge31cblxuICBlbWl0KHJlZjogUmVmZXJlbmNlLCBjb250ZXh0OiB0cy5Tb3VyY2VGaWxlKTogRW1pdHRlZFJlZmVyZW5jZXxudWxsIHtcbiAgICBjb25zdCBkZXN0U2YgPSBnZXRTb3VyY2VGaWxlKHJlZi5ub2RlKTtcbiAgICBjb25zdCBuYW1lID0gZmluZEV4cG9ydGVkTmFtZU9mTm9kZShyZWYubm9kZSwgZGVzdFNmLCB0aGlzLnJlZmxlY3Rvcik7XG4gICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZHVsZU5hbWUgPVxuICAgICAgICB0aGlzLnVuaWZpZWRNb2R1bGVzSG9zdC5maWxlTmFtZVRvTW9kdWxlTmFtZShkZXN0U2YuZmlsZU5hbWUsIGNvbnRleHQuZmlsZU5hbWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cHJlc3Npb246IG5ldyBFeHRlcm5hbEV4cHIoe21vZHVsZU5hbWUsIG5hbWV9KSxcbiAgICAgIGltcG9ydGVkRmlsZTogZGVzdFNmLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==