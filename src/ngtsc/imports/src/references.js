/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/src/ngtsc/imports/src/references", ["require", "exports", "tslib", "@angular/compiler", "path", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    /// <reference types="node" />
    var compiler_1 = require("@angular/compiler");
    var path = require("path");
    var ts = require("typescript");
    var TS_DTS_JS_EXTENSION = /(?:\.d)?\.ts$|\.js$/;
    var ImportMode;
    (function (ImportMode) {
        ImportMode[ImportMode["UseExistingImport"] = 0] = "UseExistingImport";
        ImportMode[ImportMode["ForceNewImport"] = 1] = "ForceNewImport";
    })(ImportMode = exports.ImportMode || (exports.ImportMode = {}));
    /**
     * A reference to a `ts.Node`.
     *
     * For example, if an expression evaluates to a function or class definition, it will be returned
     * as a `Reference` (assuming references are allowed in evaluation).
     */
    var Reference = /** @class */ (function () {
        function Reference(node) {
            this.node = node;
        }
        return Reference;
    }());
    exports.Reference = Reference;
    /**
     * A reference to a node only, without any ability to get an `Expression` representing that node.
     *
     * This is used for returning references to things like method declarations, which are not directly
     * referenceable.
     */
    var NodeReference = /** @class */ (function (_super) {
        tslib_1.__extends(NodeReference, _super);
        function NodeReference(node, moduleName) {
            var _this = _super.call(this, node) || this;
            _this.moduleName = moduleName;
            return _this;
        }
        NodeReference.prototype.toExpression = function (context) { return null; };
        NodeReference.prototype.addIdentifier = function (identifier) { };
        return NodeReference;
    }(Reference));
    exports.NodeReference = NodeReference;
    /**
     * A reference to a node which has a `ts.Identifier` and can be resolved to an `Expression`.
     *
     * Imports generated by `ResolvedReference`s are always relative.
     */
    var ResolvedReference = /** @class */ (function (_super) {
        tslib_1.__extends(ResolvedReference, _super);
        function ResolvedReference(node, primaryIdentifier) {
            var _this = _super.call(this, node) || this;
            _this.primaryIdentifier = primaryIdentifier;
            _this.identifiers = [];
            _this.expressable = true;
            return _this;
        }
        ResolvedReference.prototype.toExpression = function (context, importMode) {
            if (importMode === void 0) { importMode = ImportMode.UseExistingImport; }
            var localIdentifier = pickIdentifier(context, this.primaryIdentifier, this.identifiers, importMode);
            if (localIdentifier !== null) {
                return new compiler_1.WrappedNodeExpr(localIdentifier);
            }
            else {
                // Relative import from context -> this.node.getSourceFile().
                // TODO(alxhub): investigate the impact of multiple source roots here.
                // TODO(alxhub): investigate the need to map such paths via the Host for proper g3 support.
                var relative = path.posix.relative(path.dirname(context.fileName), this.node.getSourceFile().fileName)
                    .replace(TS_DTS_JS_EXTENSION, '');
                // path.relative() does not include the leading './'.
                if (!relative.startsWith('.')) {
                    relative = "./" + relative;
                }
                // path.relative() returns the empty string (converted to './' above) if the two paths are the
                // same.
                if (relative === './') {
                    // Same file after all.
                    return new compiler_1.WrappedNodeExpr(this.primaryIdentifier);
                }
                else {
                    return new compiler_1.ExternalExpr(new compiler_1.ExternalReference(relative, this.primaryIdentifier.text));
                }
            }
        };
        ResolvedReference.prototype.addIdentifier = function (identifier) { this.identifiers.push(identifier); };
        return ResolvedReference;
    }(Reference));
    exports.ResolvedReference = ResolvedReference;
    /**
     * A reference to a node which has a `ts.Identifer` and an expected absolute module name.
     *
     * An `AbsoluteReference` can be resolved to an `Expression`, and if that expression is an import
     * the module specifier will be an absolute module name, not a relative path.
     */
    var AbsoluteReference = /** @class */ (function (_super) {
        tslib_1.__extends(AbsoluteReference, _super);
        function AbsoluteReference(node, primaryIdentifier, moduleName, symbolName) {
            var _this = _super.call(this, node) || this;
            _this.primaryIdentifier = primaryIdentifier;
            _this.moduleName = moduleName;
            _this.symbolName = symbolName;
            _this.identifiers = [];
            _this.expressable = true;
            return _this;
        }
        AbsoluteReference.prototype.toExpression = function (context, importMode) {
            if (importMode === void 0) { importMode = ImportMode.UseExistingImport; }
            var localIdentifier = pickIdentifier(context, this.primaryIdentifier, this.identifiers, importMode);
            if (localIdentifier !== null) {
                return new compiler_1.WrappedNodeExpr(localIdentifier);
            }
            else {
                return new compiler_1.ExternalExpr(new compiler_1.ExternalReference(this.moduleName, this.symbolName));
            }
        };
        AbsoluteReference.prototype.addIdentifier = function (identifier) { this.identifiers.push(identifier); };
        return AbsoluteReference;
    }(Reference));
    exports.AbsoluteReference = AbsoluteReference;
    function pickIdentifier(context, primary, secondaries, mode) {
        context = ts.getOriginalNode(context);
        if (ts.getOriginalNode(primary).getSourceFile() === context) {
            return primary;
        }
        else if (mode === ImportMode.UseExistingImport) {
            return secondaries.find(function (id) { return ts.getOriginalNode(id).getSourceFile() === context; }) || null;
        }
        else {
            return null;
        }
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVmZXJlbmNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvaW1wb3J0cy9zcmMvcmVmZXJlbmNlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7SUFFSCw4QkFBOEI7SUFFOUIsOENBQStGO0lBQy9GLDJCQUE2QjtJQUM3QiwrQkFBaUM7SUFHakMsSUFBTSxtQkFBbUIsR0FBRyxxQkFBcUIsQ0FBQztJQUVsRCxJQUFZLFVBR1g7SUFIRCxXQUFZLFVBQVU7UUFDcEIscUVBQWlCLENBQUE7UUFDakIsK0RBQWMsQ0FBQTtJQUNoQixDQUFDLEVBSFcsVUFBVSxHQUFWLGtCQUFVLEtBQVYsa0JBQVUsUUFHckI7SUFFRDs7Ozs7T0FLRztJQUNIO1FBQ0UsbUJBQXFCLElBQU87WUFBUCxTQUFJLEdBQUosSUFBSSxDQUFHO1FBQUcsQ0FBQztRQWlCbEMsZ0JBQUM7SUFBRCxDQUFDLEFBbEJELElBa0JDO0lBbEJxQiw4QkFBUztJQW9CL0I7Ozs7O09BS0c7SUFDSDtRQUFnRSx5Q0FBWTtRQUMxRSx1QkFBWSxJQUFPLEVBQVcsVUFBdUI7WUFBckQsWUFBeUQsa0JBQU0sSUFBSSxDQUFDLFNBQUc7WUFBekMsZ0JBQVUsR0FBVixVQUFVLENBQWE7O1FBQWlCLENBQUM7UUFFdkUsb0NBQVksR0FBWixVQUFhLE9BQXNCLElBQVUsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRTNELHFDQUFhLEdBQWIsVUFBYyxVQUF5QixJQUFTLENBQUM7UUFDbkQsb0JBQUM7SUFBRCxDQUFDLEFBTkQsQ0FBZ0UsU0FBUyxHQU14RTtJQU5ZLHNDQUFhO0lBUTFCOzs7O09BSUc7SUFDSDtRQUFvRSw2Q0FBWTtRQUc5RSwyQkFBWSxJQUFPLEVBQVksaUJBQWdDO1lBQS9ELFlBQW1FLGtCQUFNLElBQUksQ0FBQyxTQUFHO1lB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VSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZGLHdCQUFDO0lBQUQsQ0FBQyxBQXRCRCxDQUEwRCxTQUFTLEdBc0JsRTtJQXRCWSw4Q0FBaUI7SUF3QjlCLFNBQVMsY0FBYyxDQUNuQixPQUFzQixFQUFFLE9BQXNCLEVBQUUsV0FBNEIsRUFDNUUsSUFBZ0I7UUFDbEIsT0FBTyxHQUFHLEVBQUUsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFrQixDQUFDO1FBRXZELElBQUksRUFBRSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxhQUFhLEVBQUUsS0FBSyxPQUFPLEVBQUU7WUFDM0QsT0FBTyxPQUFPLENBQUM7U0FDaEI7YUFBTSxJQUFJLElBQUksS0FBSyxVQUFVLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsT0FBTyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQUEsRUFBRSxJQUFJLE9BQUEsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLEVBQUUsS0FBSyxPQUFPLEVBQWxELENBQWtELENBQUMsSUFBSSxJQUFJLENBQUM7U0FDM0Y7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDO1NBQ2I7SUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm5vZGVcIiAvPlxuXG5pbXBvcnQge0V4cHJlc3Npb24sIEV4dGVybmFsRXhwciwgRXh0ZXJuYWxSZWZlcmVuY2UsIFdyYXBwZWROb2RlRXhwcn0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5cbmNvbnN0IFRTX0RUU19KU19FWFRFTlNJT04gPSAvKD86XFwuZCk/XFwudHMkfFxcLmpzJC87XG5cbmV4cG9ydCBlbnVtIEltcG9ydE1vZGUge1xuICBVc2VFeGlzdGluZ0ltcG9ydCxcbiAgRm9yY2VOZXdJbXBvcnQsXG59XG5cbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYSBgdHMuTm9kZWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGFuIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgZnVuY3Rpb24gb3IgY2xhc3MgZGVmaW5pdGlvbiwgaXQgd2lsbCBiZSByZXR1cm5lZFxuICogYXMgYSBgUmVmZXJlbmNlYCAoYXNzdW1pbmcgcmVmZXJlbmNlcyBhcmUgYWxsb3dlZCBpbiBldmFsdWF0aW9uKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlZmVyZW5jZTxUIGV4dGVuZHMgdHMuTm9kZSA9IHRzLk5vZGU+IHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbm9kZTogVCkge31cblxuICAvKipcbiAgICogV2hldGhlciBhbiBgRXhwcmVzc2lvbmAgY2FuIGJlIGdlbmVyYXRlZCB3aGljaCByZWZlcmVuY2VzIHRoZSBub2RlLlxuICAgKi9cbiAgLy8gVE9ETyhpc3N1ZS8yNDU3MSk6IHJlbW92ZSAnIScuXG4gIHJlYWRvbmx5IGV4cHJlc3NhYmxlICE6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGBFeHByZXNzaW9uYCByZXByZXNlbnRpbmcgdGhpcyB0eXBlLCBpbiB0aGUgY29udGV4dCBvZiB0aGUgZ2l2ZW4gU291cmNlRmlsZS5cbiAgICpcbiAgICogVGhpcyBjb3VsZCBiZSBhIGxvY2FsIHZhcmlhYmxlIHJlZmVyZW5jZSwgaWYgdGhlIHN5bWJvbCBpcyBpbXBvcnRlZCwgb3IgaXQgY291bGQgYmUgYSBuZXdcbiAgICogaW1wb3J0IGlmIG5lZWRlZC5cbiAgICovXG4gIGFic3RyYWN0IHRvRXhwcmVzc2lvbihjb250ZXh0OiB0cy5Tb3VyY2VGaWxlLCBpbXBvcnRNb2RlPzogSW1wb3J0TW9kZSk6IEV4cHJlc3Npb258bnVsbDtcblxuICBhYnN0cmFjdCBhZGRJZGVudGlmaWVyKGlkZW50aWZpZXI6IHRzLklkZW50aWZpZXIpOiB2b2lkO1xufVxuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgbm9kZSBvbmx5LCB3aXRob3V0IGFueSBhYmlsaXR5IHRvIGdldCBhbiBgRXhwcmVzc2lvbmAgcmVwcmVzZW50aW5nIHRoYXQgbm9kZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHJldHVybmluZyByZWZlcmVuY2VzIHRvIHRoaW5ncyBsaWtlIG1ldGhvZCBkZWNsYXJhdGlvbnMsIHdoaWNoIGFyZSBub3QgZGlyZWN0bHlcbiAqIHJlZmVyZW5jZWFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlUmVmZXJlbmNlPFQgZXh0ZW5kcyB0cy5Ob2RlID0gdHMuTm9kZT4gZXh0ZW5kcyBSZWZlcmVuY2U8VD4ge1xuICBjb25zdHJ1Y3Rvcihub2RlOiBULCByZWFkb25seSBtb2R1bGVOYW1lOiBzdHJpbmd8bnVsbCkgeyBzdXBlcihub2RlKTsgfVxuXG4gIHRvRXhwcmVzc2lvbihjb250ZXh0OiB0cy5Tb3VyY2VGaWxlKTogbnVsbCB7IHJldHVybiBudWxsOyB9XG5cbiAgYWRkSWRlbnRpZmllcihpZGVudGlmaWVyOiB0cy5JZGVudGlmaWVyKTogdm9pZCB7fVxufVxuXG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGEgbm9kZSB3aGljaCBoYXMgYSBgdHMuSWRlbnRpZmllcmAgYW5kIGNhbiBiZSByZXNvbHZlZCB0byBhbiBgRXhwcmVzc2lvbmAuXG4gKlxuICogSW1wb3J0cyBnZW5lcmF0ZWQgYnkgYFJlc29sdmVkUmVmZXJlbmNlYHMgYXJlIGFsd2F5cyByZWxhdGl2ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc29sdmVkUmVmZXJlbmNlPFQgZXh0ZW5kcyB0cy5Ob2RlID0gdHMuTm9kZT4gZXh0ZW5kcyBSZWZlcmVuY2U8VD4ge1xuICBwcm90ZWN0ZWQgaWRlbnRpZmllcnM6IHRzLklkZW50aWZpZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKG5vZGU6IFQsIHByb3RlY3RlZCBwcmltYXJ5SWRlbnRpZmllcjogdHMuSWRlbnRpZmllcikgeyBzdXBlcihub2RlKTsgfVxuXG4gIHJlYWRvbmx5IGV4cHJlc3NhYmxlID0gdHJ1ZTtcblxuICB0b0V4cHJlc3Npb24oY29udGV4dDogdHMuU291cmNlRmlsZSwgaW1wb3J0TW9kZTogSW1wb3J0TW9kZSA9IEltcG9ydE1vZGUuVXNlRXhpc3RpbmdJbXBvcnQpOlxuICAgICAgRXhwcmVzc2lvbiB7XG4gICAgY29uc3QgbG9jYWxJZGVudGlmaWVyID1cbiAgICAgICAgcGlja0lkZW50aWZpZXIoY29udGV4dCwgdGhpcy5wcmltYXJ5SWRlbnRpZmllciwgdGhpcy5pZGVudGlmaWVycywgaW1wb3J0TW9kZSk7XG4gICAgaWYgKGxvY2FsSWRlbnRpZmllciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIobG9jYWxJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVsYXRpdmUgaW1wb3J0IGZyb20gY29udGV4dCAtPiB0aGlzLm5vZGUuZ2V0U291cmNlRmlsZSgpLlxuICAgICAgLy8gVE9ETyhhbHhodWIpOiBpbnZlc3RpZ2F0ZSB0aGUgaW1wYWN0IG9mIG11bHRpcGxlIHNvdXJjZSByb290cyBoZXJlLlxuICAgICAgLy8gVE9ETyhhbHhodWIpOiBpbnZlc3RpZ2F0ZSB0aGUgbmVlZCB0byBtYXAgc3VjaCBwYXRocyB2aWEgdGhlIEhvc3QgZm9yIHByb3BlciBnMyBzdXBwb3J0LlxuICAgICAgbGV0IHJlbGF0aXZlID1cbiAgICAgICAgICBwYXRoLnBvc2l4LnJlbGF0aXZlKHBhdGguZGlybmFtZShjb250ZXh0LmZpbGVOYW1lKSwgdGhpcy5ub2RlLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZSlcbiAgICAgICAgICAgICAgLnJlcGxhY2UoVFNfRFRTX0pTX0VYVEVOU0lPTiwgJycpO1xuXG4gICAgICAvLyBwYXRoLnJlbGF0aXZlKCkgZG9lcyBub3QgaW5jbHVkZSB0aGUgbGVhZGluZyAnLi8nLlxuICAgICAgaWYgKCFyZWxhdGl2ZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmVsYXRpdmUgPSBgLi8ke3JlbGF0aXZlfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhdGgucmVsYXRpdmUoKSByZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcgKGNvbnZlcnRlZCB0byAnLi8nIGFib3ZlKSBpZiB0aGUgdHdvIHBhdGhzIGFyZSB0aGVcbiAgICAgIC8vIHNhbWUuXG4gICAgICBpZiAocmVsYXRpdmUgPT09ICcuLycpIHtcbiAgICAgICAgLy8gU2FtZSBmaWxlIGFmdGVyIGFsbC5cbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIodGhpcy5wcmltYXJ5SWRlbnRpZmllcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVybmFsRXhwcihuZXcgRXh0ZXJuYWxSZWZlcmVuY2UocmVsYXRpdmUsIHRoaXMucHJpbWFyeUlkZW50aWZpZXIudGV4dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZElkZW50aWZpZXIoaWRlbnRpZmllcjogdHMuSWRlbnRpZmllcik6IHZvaWQgeyB0aGlzLmlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7IH1cbn1cblxuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhIG5vZGUgd2hpY2ggaGFzIGEgYHRzLklkZW50aWZlcmAgYW5kIGFuIGV4cGVjdGVkIGFic29sdXRlIG1vZHVsZSBuYW1lLlxuICpcbiAqIEFuIGBBYnNvbHV0ZVJlZmVyZW5jZWAgY2FuIGJlIHJlc29sdmVkIHRvIGFuIGBFeHByZXNzaW9uYCwgYW5kIGlmIHRoYXQgZXhwcmVzc2lvbiBpcyBhbiBpbXBvcnRcbiAqIHRoZSBtb2R1bGUgc3BlY2lmaWVyIHdpbGwgYmUgYW4gYWJzb2x1dGUgbW9kdWxlIG5hbWUsIG5vdCBhIHJlbGF0aXZlIHBhdGguXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnNvbHV0ZVJlZmVyZW5jZTxUIGV4dGVuZHMgdHMuTm9kZT4gZXh0ZW5kcyBSZWZlcmVuY2U8VD4ge1xuICBwcml2YXRlIGlkZW50aWZpZXJzOiB0cy5JZGVudGlmaWVyW10gPSBbXTtcbiAgY29uc3RydWN0b3IoXG4gICAgICBub2RlOiBULCBwcml2YXRlIHByaW1hcnlJZGVudGlmaWVyOiB0cy5JZGVudGlmaWVyLCByZWFkb25seSBtb2R1bGVOYW1lOiBzdHJpbmcsXG4gICAgICByZWFkb25seSBzeW1ib2xOYW1lOiBzdHJpbmcpIHtcbiAgICBzdXBlcihub2RlKTtcbiAgfVxuXG4gIHJlYWRvbmx5IGV4cHJlc3NhYmxlID0gdHJ1ZTtcblxuICB0b0V4cHJlc3Npb24oY29udGV4dDogdHMuU291cmNlRmlsZSwgaW1wb3J0TW9kZTogSW1wb3J0TW9kZSA9IEltcG9ydE1vZGUuVXNlRXhpc3RpbmdJbXBvcnQpOlxuICAgICAgRXhwcmVzc2lvbiB7XG4gICAgY29uc3QgbG9jYWxJZGVudGlmaWVyID1cbiAgICAgICAgcGlja0lkZW50aWZpZXIoY29udGV4dCwgdGhpcy5wcmltYXJ5SWRlbnRpZmllciwgdGhpcy5pZGVudGlmaWVycywgaW1wb3J0TW9kZSk7XG4gICAgaWYgKGxvY2FsSWRlbnRpZmllciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkTm9kZUV4cHIobG9jYWxJZGVudGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIobmV3IEV4dGVybmFsUmVmZXJlbmNlKHRoaXMubW9kdWxlTmFtZSwgdGhpcy5zeW1ib2xOYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgYWRkSWRlbnRpZmllcihpZGVudGlmaWVyOiB0cy5JZGVudGlmaWVyKTogdm9pZCB7IHRoaXMuaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTsgfVxufVxuXG5mdW5jdGlvbiBwaWNrSWRlbnRpZmllcihcbiAgICBjb250ZXh0OiB0cy5Tb3VyY2VGaWxlLCBwcmltYXJ5OiB0cy5JZGVudGlmaWVyLCBzZWNvbmRhcmllczogdHMuSWRlbnRpZmllcltdLFxuICAgIG1vZGU6IEltcG9ydE1vZGUpOiB0cy5JZGVudGlmaWVyfG51bGwge1xuICBjb250ZXh0ID0gdHMuZ2V0T3JpZ2luYWxOb2RlKGNvbnRleHQpIGFzIHRzLlNvdXJjZUZpbGU7XG5cbiAgaWYgKHRzLmdldE9yaWdpbmFsTm9kZShwcmltYXJ5KS5nZXRTb3VyY2VGaWxlKCkgPT09IGNvbnRleHQpIHtcbiAgICByZXR1cm4gcHJpbWFyeTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBJbXBvcnRNb2RlLlVzZUV4aXN0aW5nSW1wb3J0KSB7XG4gICAgcmV0dXJuIHNlY29uZGFyaWVzLmZpbmQoaWQgPT4gdHMuZ2V0T3JpZ2luYWxOb2RlKGlkKS5nZXRTb3VyY2VGaWxlKCkgPT09IGNvbnRleHQpIHx8IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0iXX0=