import { InvalidFileSystem } from './invalid_file_system';
import { normalizeSeparators } from './util';
let fs = new InvalidFileSystem();
export function getFileSystem() {
    return fs;
}
export function setFileSystem(fileSystem) {
    fs = fileSystem;
}
/**
 * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.
 */
export function absoluteFrom(path) {
    if (!fs.isRooted(path)) {
        throw new Error(`Internal Error: absoluteFrom(${path}): path is not absolute`);
    }
    return fs.resolve(path);
}
const ABSOLUTE_PATH = Symbol('AbsolutePath');
/**
 * Extract an `AbsoluteFsPath` from a `ts.SourceFile`-like object.
 */
export function absoluteFromSourceFile(sf) {
    const sfWithPatch = sf;
    if (sfWithPatch[ABSOLUTE_PATH] === undefined) {
        sfWithPatch[ABSOLUTE_PATH] = fs.resolve(sfWithPatch.fileName);
    }
    // Non-null assertion needed since TS doesn't narrow the type of fields that use a symbol as a key
    // apparently.
    return sfWithPatch[ABSOLUTE_PATH];
}
/**
 * Convert the path `path` to a `PathSegment`, throwing an error if it's not a relative path.
 */
export function relativeFrom(path) {
    const normalized = normalizeSeparators(path);
    if (fs.isRooted(normalized)) {
        throw new Error(`Internal Error: relativeFrom(${path}): path is not relative`);
    }
    return normalized;
}
/**
 * Static access to `dirname`.
 */
export function dirname(file) {
    return fs.dirname(file);
}
/**
 * Static access to `join`.
 */
export function join(basePath, ...paths) {
    return fs.join(basePath, ...paths);
}
/**
 * Static access to `resolve`s.
 */
export function resolve(basePath, ...paths) {
    return fs.resolve(basePath, ...paths);
}
/** Returns true when the path provided is the root path. */
export function isRoot(path) {
    return fs.isRoot(path);
}
/**
 * Static access to `isRooted`.
 */
export function isRooted(path) {
    return fs.isRooted(path);
}
/**
 * Static access to `relative`.
 */
export function relative(from, to) {
    return fs.relative(from, to);
}
/**
 * Static access to `basename`.
 */
export function basename(filePath, extension) {
    return fs.basename(filePath, extension);
}
/**
 * Returns true if the given path is locally relative.
 *
 * This is used to work out if the given path is relative (i.e. not absolute) but also is not
 * escaping the current directory.
 */
export function isLocalRelativePath(relativePath) {
    return !isRooted(relativePath) && !relativePath.startsWith('..');
}
/**
 * Converts a path to a form suitable for use as a relative module import specifier.
 *
 * In other words it adds the `./` to the path if it is locally relative.
 */
export function toRelativeImport(relativePath) {
    return isLocalRelativePath(relativePath) ? `./${relativePath}` : relativePath;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvZmlsZV9zeXN0ZW0vc3JjL2hlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBU0EsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFeEQsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sUUFBUSxDQUFDO0FBRTNDLElBQUksRUFBRSxHQUFlLElBQUksaUJBQWlCLEVBQUUsQ0FBQztBQUM3QyxNQUFNLFVBQVUsYUFBYTtJQUMzQixPQUFPLEVBQUUsQ0FBQztBQUNaLENBQUM7QUFDRCxNQUFNLFVBQVUsYUFBYSxDQUFDLFVBQXNCO0lBQ2xELEVBQUUsR0FBRyxVQUFVLENBQUM7QUFDbEIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxJQUFZO0lBQ3ZDLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLElBQUkseUJBQXlCLENBQUMsQ0FBQztLQUNoRjtJQUNELE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMxQixDQUFDO0FBRUQsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBRTdDOztHQUVHO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUFDLEVBQXNCO0lBQzNELE1BQU0sV0FBVyxHQUFHLEVBQTBELENBQUM7SUFFL0UsSUFBSSxXQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssU0FBUyxFQUFFO1FBQzVDLFdBQVcsQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUMvRDtJQUVELGtHQUFrRztJQUNsRyxjQUFjO0lBQ2QsT0FBTyxXQUFXLENBQUMsYUFBYSxDQUFFLENBQUM7QUFDckMsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxJQUFZO0lBQ3ZDLE1BQU0sVUFBVSxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdDLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLGdDQUFnQyxJQUFJLHlCQUF5QixDQUFDLENBQUM7S0FDaEY7SUFDRCxPQUFPLFVBQXlCLENBQUM7QUFDbkMsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FBdUIsSUFBTztJQUNuRCxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLElBQUksQ0FBdUIsUUFBVyxFQUFFLEdBQUcsS0FBZTtJQUN4RSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDckMsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FBQyxRQUFnQixFQUFFLEdBQUcsS0FBZTtJQUMxRCxPQUFPLEVBQUUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUVELDREQUE0RDtBQUM1RCxNQUFNLFVBQVUsTUFBTSxDQUFDLElBQW9CO0lBQ3pDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsUUFBUSxDQUFDLElBQVk7SUFDbkMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQXVCLElBQU8sRUFBRSxFQUFLO0lBQzNELE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDL0IsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBQyxRQUFvQixFQUFFLFNBQWtCO0lBQy9ELE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFnQixDQUFDO0FBQ3pELENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxZQUFvQjtJQUN0RCxPQUFPLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuRSxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxZQUF3QztJQUV2RSxPQUFPLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFlBQVksRUFBaUIsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQy9GLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0ludmFsaWRGaWxlU3lzdGVtfSBmcm9tICcuL2ludmFsaWRfZmlsZV9zeXN0ZW0nO1xuaW1wb3J0IHtBYnNvbHV0ZUZzUGF0aCwgRmlsZVN5c3RlbSwgUGF0aFNlZ21lbnQsIFBhdGhTdHJpbmd9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtub3JtYWxpemVTZXBhcmF0b3JzfSBmcm9tICcuL3V0aWwnO1xuXG5sZXQgZnM6IEZpbGVTeXN0ZW0gPSBuZXcgSW52YWxpZEZpbGVTeXN0ZW0oKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlU3lzdGVtKCk6IEZpbGVTeXN0ZW0ge1xuICByZXR1cm4gZnM7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0RmlsZVN5c3RlbShmaWxlU3lzdGVtOiBGaWxlU3lzdGVtKSB7XG4gIGZzID0gZmlsZVN5c3RlbTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXRoIGBwYXRoYCB0byBhbiBgQWJzb2x1dGVGc1BhdGhgLCB0aHJvd2luZyBhbiBlcnJvciBpZiBpdCdzIG5vdCBhbiBhYnNvbHV0ZSBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzb2x1dGVGcm9tKHBhdGg6IHN0cmluZyk6IEFic29sdXRlRnNQYXRoIHtcbiAgaWYgKCFmcy5pc1Jvb3RlZChwYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgRXJyb3I6IGFic29sdXRlRnJvbSgke3BhdGh9KTogcGF0aCBpcyBub3QgYWJzb2x1dGVgKTtcbiAgfVxuICByZXR1cm4gZnMucmVzb2x2ZShwYXRoKTtcbn1cblxuY29uc3QgQUJTT0xVVEVfUEFUSCA9IFN5bWJvbCgnQWJzb2x1dGVQYXRoJyk7XG5cbi8qKlxuICogRXh0cmFjdCBhbiBgQWJzb2x1dGVGc1BhdGhgIGZyb20gYSBgdHMuU291cmNlRmlsZWAtbGlrZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnNvbHV0ZUZyb21Tb3VyY2VGaWxlKHNmOiB7ZmlsZU5hbWU6IHN0cmluZ30pOiBBYnNvbHV0ZUZzUGF0aCB7XG4gIGNvbnN0IHNmV2l0aFBhdGNoID0gc2YgYXMge2ZpbGVOYW1lOiBzdHJpbmcsIFtBQlNPTFVURV9QQVRIXT86IEFic29sdXRlRnNQYXRofTtcblxuICBpZiAoc2ZXaXRoUGF0Y2hbQUJTT0xVVEVfUEFUSF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHNmV2l0aFBhdGNoW0FCU09MVVRFX1BBVEhdID0gZnMucmVzb2x2ZShzZldpdGhQYXRjaC5maWxlTmFtZSk7XG4gIH1cblxuICAvLyBOb24tbnVsbCBhc3NlcnRpb24gbmVlZGVkIHNpbmNlIFRTIGRvZXNuJ3QgbmFycm93IHRoZSB0eXBlIG9mIGZpZWxkcyB0aGF0IHVzZSBhIHN5bWJvbCBhcyBhIGtleVxuICAvLyBhcHBhcmVudGx5LlxuICByZXR1cm4gc2ZXaXRoUGF0Y2hbQUJTT0xVVEVfUEFUSF0hO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhdGggYHBhdGhgIHRvIGEgYFBhdGhTZWdtZW50YCwgdGhyb3dpbmcgYW4gZXJyb3IgaWYgaXQncyBub3QgYSByZWxhdGl2ZSBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVsYXRpdmVGcm9tKHBhdGg6IHN0cmluZyk6IFBhdGhTZWdtZW50IHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNlcGFyYXRvcnMocGF0aCk7XG4gIGlmIChmcy5pc1Jvb3RlZChub3JtYWxpemVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgRXJyb3I6IHJlbGF0aXZlRnJvbSgke3BhdGh9KTogcGF0aCBpcyBub3QgcmVsYXRpdmVgKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZCBhcyBQYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBTdGF0aWMgYWNjZXNzIHRvIGBkaXJuYW1lYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpcm5hbWU8VCBleHRlbmRzIFBhdGhTdHJpbmc+KGZpbGU6IFQpOiBUIHtcbiAgcmV0dXJuIGZzLmRpcm5hbWUoZmlsZSk7XG59XG5cbi8qKlxuICogU3RhdGljIGFjY2VzcyB0byBgam9pbmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luPFQgZXh0ZW5kcyBQYXRoU3RyaW5nPihiYXNlUGF0aDogVCwgLi4ucGF0aHM6IHN0cmluZ1tdKTogVCB7XG4gIHJldHVybiBmcy5qb2luKGJhc2VQYXRoLCAuLi5wYXRocyk7XG59XG5cbi8qKlxuICogU3RhdGljIGFjY2VzcyB0byBgcmVzb2x2ZWBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShiYXNlUGF0aDogc3RyaW5nLCAuLi5wYXRoczogc3RyaW5nW10pOiBBYnNvbHV0ZUZzUGF0aCB7XG4gIHJldHVybiBmcy5yZXNvbHZlKGJhc2VQYXRoLCAuLi5wYXRocyk7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGF0aCBwcm92aWRlZCBpcyB0aGUgcm9vdCBwYXRoLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm9vdChwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZnMuaXNSb290KHBhdGgpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBhY2Nlc3MgdG8gYGlzUm9vdGVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm9vdGVkKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gZnMuaXNSb290ZWQocGF0aCk7XG59XG5cbi8qKlxuICogU3RhdGljIGFjY2VzcyB0byBgcmVsYXRpdmVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVsYXRpdmU8VCBleHRlbmRzIFBhdGhTdHJpbmc+KGZyb206IFQsIHRvOiBUKTogUGF0aFNlZ21lbnR8QWJzb2x1dGVGc1BhdGgge1xuICByZXR1cm4gZnMucmVsYXRpdmUoZnJvbSwgdG8pO1xufVxuXG4vKipcbiAqIFN0YXRpYyBhY2Nlc3MgdG8gYGJhc2VuYW1lYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2VuYW1lKGZpbGVQYXRoOiBQYXRoU3RyaW5nLCBleHRlbnNpb24/OiBzdHJpbmcpOiBQYXRoU2VnbWVudCB7XG4gIHJldHVybiBmcy5iYXNlbmFtZShmaWxlUGF0aCwgZXh0ZW5zaW9uKSBhcyBQYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgbG9jYWxseSByZWxhdGl2ZS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gd29yayBvdXQgaWYgdGhlIGdpdmVuIHBhdGggaXMgcmVsYXRpdmUgKGkuZS4gbm90IGFic29sdXRlKSBidXQgYWxzbyBpcyBub3RcbiAqIGVzY2FwaW5nIHRoZSBjdXJyZW50IGRpcmVjdG9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxSZWxhdGl2ZVBhdGgocmVsYXRpdmVQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICFpc1Jvb3RlZChyZWxhdGl2ZVBhdGgpICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHBhdGggdG8gYSBmb3JtIHN1aXRhYmxlIGZvciB1c2UgYXMgYSByZWxhdGl2ZSBtb2R1bGUgaW1wb3J0IHNwZWNpZmllci5cbiAqXG4gKiBJbiBvdGhlciB3b3JkcyBpdCBhZGRzIHRoZSBgLi9gIHRvIHRoZSBwYXRoIGlmIGl0IGlzIGxvY2FsbHkgcmVsYXRpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JlbGF0aXZlSW1wb3J0KHJlbGF0aXZlUGF0aDogUGF0aFNlZ21lbnR8QWJzb2x1dGVGc1BhdGgpOiBQYXRoU2VnbWVudHxcbiAgICBBYnNvbHV0ZUZzUGF0aCB7XG4gIHJldHVybiBpc0xvY2FsUmVsYXRpdmVQYXRoKHJlbGF0aXZlUGF0aCkgPyBgLi8ke3JlbGF0aXZlUGF0aH1gIGFzIFBhdGhTZWdtZW50IDogcmVsYXRpdmVQYXRoO1xufVxuIl19