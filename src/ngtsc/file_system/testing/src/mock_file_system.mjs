/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { basename, dirname, resolve } from '../../src/helpers';
/**
 * An in-memory file system that can be used in unit tests.
 */
export class MockFileSystem {
    constructor(_isCaseSensitive = false, cwd = '/') {
        this._isCaseSensitive = _isCaseSensitive;
        this._fileTree = {};
        this._cwd = this.normalize(cwd);
    }
    isCaseSensitive() {
        return this._isCaseSensitive;
    }
    exists(path) {
        return this.findFromPath(path).entity !== null;
    }
    readFile(path) {
        const { entity } = this.findFromPath(path);
        if (isFile(entity)) {
            return entity.toString();
        }
        else {
            throw new MockFileSystemError('ENOENT', path, `File "${path}" does not exist.`);
        }
    }
    readFileBuffer(path) {
        const { entity } = this.findFromPath(path);
        if (isFile(entity)) {
            return entity instanceof Uint8Array ? entity : new Buffer(entity);
        }
        else {
            throw new MockFileSystemError('ENOENT', path, `File "${path}" does not exist.`);
        }
    }
    writeFile(path, data, exclusive = false) {
        const [folderPath, basename] = this.splitIntoFolderAndFile(path);
        const { entity } = this.findFromPath(folderPath);
        if (entity === null || !isFolder(entity)) {
            throw new MockFileSystemError('ENOENT', path, `Unable to write file "${path}". The containing folder does not exist.`);
        }
        if (exclusive && entity[basename] !== undefined) {
            throw new MockFileSystemError('EEXIST', path, `Unable to exclusively write file "${path}". The file already exists.`);
        }
        entity[basename] = data;
    }
    removeFile(path) {
        const [folderPath, basename] = this.splitIntoFolderAndFile(path);
        const { entity } = this.findFromPath(folderPath);
        if (entity === null || !isFolder(entity)) {
            throw new MockFileSystemError('ENOENT', path, `Unable to remove file "${path}". The containing folder does not exist.`);
        }
        if (isFolder(entity[basename])) {
            throw new MockFileSystemError('EISDIR', path, `Unable to remove file "${path}". The path to remove is a folder.`);
        }
        delete entity[basename];
    }
    symlink(target, path) {
        const [folderPath, basename] = this.splitIntoFolderAndFile(path);
        const { entity } = this.findFromPath(folderPath);
        if (entity === null || !isFolder(entity)) {
            throw new MockFileSystemError('ENOENT', path, `Unable to create symlink at "${path}". The containing folder does not exist.`);
        }
        entity[basename] = new SymLink(target);
    }
    readdir(path) {
        const { entity } = this.findFromPath(path);
        if (entity === null) {
            throw new MockFileSystemError('ENOENT', path, `Unable to read directory "${path}". It does not exist.`);
        }
        if (isFile(entity)) {
            throw new MockFileSystemError('ENOTDIR', path, `Unable to read directory "${path}". It is a file.`);
        }
        return Object.keys(entity);
    }
    lstat(path) {
        const { entity } = this.findFromPath(path);
        if (entity === null) {
            throw new MockFileSystemError('ENOENT', path, `File "${path}" does not exist.`);
        }
        return new MockFileStats(entity);
    }
    stat(path) {
        const { entity } = this.findFromPath(path, { followSymLinks: true });
        if (entity === null) {
            throw new MockFileSystemError('ENOENT', path, `File "${path}" does not exist.`);
        }
        return new MockFileStats(entity);
    }
    copyFile(from, to) {
        this.writeFile(to, this.readFile(from));
    }
    moveFile(from, to) {
        this.writeFile(to, this.readFile(from));
        const result = this.findFromPath(dirname(from));
        const folder = result.entity;
        const name = basename(from);
        delete folder[name];
    }
    ensureDir(path) {
        const segments = this.splitPath(path).map(segment => this.getCanonicalPath(segment));
        // Convert the root folder to a canonical empty string `''` (on Windows it would be `'C:'`).
        segments[0] = '';
        if (segments.length > 1 && segments[segments.length - 1] === '') {
            // Remove a trailing slash (unless the path was only `/`)
            segments.pop();
        }
        let current = this._fileTree;
        for (const segment of segments) {
            if (isFile(current[segment])) {
                throw new Error(`Folder already exists as a file.`);
            }
            if (!current[segment]) {
                current[segment] = {};
            }
            current = current[segment];
        }
        return current;
    }
    removeDeep(path) {
        const [folderPath, basename] = this.splitIntoFolderAndFile(path);
        const { entity } = this.findFromPath(folderPath);
        if (entity === null || !isFolder(entity)) {
            throw new MockFileSystemError('ENOENT', path, `Unable to remove folder "${path}". The containing folder does not exist.`);
        }
        delete entity[basename];
    }
    isRoot(path) {
        return this.dirname(path) === path;
    }
    extname(path) {
        const match = /.+(\.[^.]*)$/.exec(path);
        return match !== null ? match[1] : '';
    }
    realpath(filePath) {
        const result = this.findFromPath(filePath, { followSymLinks: true });
        if (result.entity === null) {
            throw new MockFileSystemError('ENOENT', filePath, `Unable to find the real path of "${filePath}". It does not exist.`);
        }
        else {
            return result.path;
        }
    }
    pwd() {
        return this._cwd;
    }
    chdir(path) {
        this._cwd = this.normalize(path);
    }
    getDefaultLibLocation() {
        // Mimic the node module resolution algorithm and start in the current directory, then look
        // progressively further up the tree until reaching the FS root.
        // E.g. if the current directory is /foo/bar, look in /foo/bar/node_modules, then
        // /foo/node_modules, then /node_modules.
        let path = 'node_modules/typescript/lib';
        let resolvedPath = this.resolve(path);
        // Construct a path for the top-level node_modules to identify the stopping point.
        const topLevelNodeModules = this.resolve('/' + path);
        while (resolvedPath !== topLevelNodeModules) {
            if (this.exists(resolvedPath)) {
                return resolvedPath;
            }
            // Not here, look one level higher.
            path = '../' + path;
            resolvedPath = this.resolve(path);
        }
        // The loop exits before checking the existence of /node_modules/typescript at the top level.
        // This is intentional - if no /node_modules/typescript exists anywhere in the tree, there's
        // nothing this function can do about it, and TS may error later if it looks for a lib.d.ts file
        // within this directory. It might be okay, though, if TS never checks for one.
        return topLevelNodeModules;
    }
    dump() {
        const { entity } = this.findFromPath(this.resolve('/'));
        if (entity === null || !isFolder(entity)) {
            return {};
        }
        return this.cloneFolder(entity);
    }
    init(folder) {
        this.mount(this.resolve('/'), folder);
    }
    mount(path, folder) {
        if (this.exists(path)) {
            throw new Error(`Unable to mount in '${path}' as it already exists.`);
        }
        const mountFolder = this.ensureDir(path);
        this.copyInto(folder, mountFolder);
    }
    cloneFolder(folder) {
        const clone = {};
        this.copyInto(folder, clone);
        return clone;
    }
    copyInto(from, to) {
        for (const path in from) {
            const item = from[path];
            const canonicalPath = this.getCanonicalPath(path);
            if (isSymLink(item)) {
                to[canonicalPath] = new SymLink(this.getCanonicalPath(item.path));
            }
            else if (isFolder(item)) {
                to[canonicalPath] = this.cloneFolder(item);
            }
            else {
                to[canonicalPath] = from[path];
            }
        }
    }
    findFromPath(path, options) {
        const followSymLinks = !!options && options.followSymLinks;
        const segments = this.splitPath(path);
        if (segments.length > 1 && segments[segments.length - 1] === '') {
            // Remove a trailing slash (unless the path was only `/`)
            segments.pop();
        }
        // Convert the root folder to a canonical empty string `""` (on Windows it would be `C:`).
        segments[0] = '';
        let current = this._fileTree;
        while (segments.length) {
            current = current[this.getCanonicalPath(segments.shift())];
            if (current === undefined) {
                return { path, entity: null };
            }
            if (segments.length > 0 && (!isFolder(current))) {
                current = null;
                break;
            }
            if (isFile(current)) {
                break;
            }
            if (isSymLink(current)) {
                if (followSymLinks) {
                    return this.findFromPath(resolve(current.path, ...segments), { followSymLinks });
                }
                else {
                    break;
                }
            }
        }
        return { path, entity: current };
    }
    splitIntoFolderAndFile(path) {
        const segments = this.splitPath(this.getCanonicalPath(path));
        const file = segments.pop();
        return [path.substring(0, path.length - file.length - 1), file];
    }
    getCanonicalPath(p) {
        return this.isCaseSensitive() ? p : p.toLowerCase();
    }
}
export class SymLink {
    constructor(path) {
        this.path = path;
    }
}
class MockFileStats {
    constructor(entity) {
        this.entity = entity;
    }
    isFile() {
        return isFile(this.entity);
    }
    isDirectory() {
        return isFolder(this.entity);
    }
    isSymbolicLink() {
        return isSymLink(this.entity);
    }
}
class MockFileSystemError extends Error {
    constructor(code, path, message) {
        super(message);
        this.code = code;
        this.path = path;
    }
}
export function isFile(item) {
    return Buffer.isBuffer(item) || typeof item === 'string';
}
export function isSymLink(item) {
    return item instanceof SymLink;
}
export function isFolder(item) {
    return item !== null && !isFile(item) && !isSymLink(item);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ja19maWxlX3N5c3RlbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvZmlsZV9zeXN0ZW0vdGVzdGluZy9zcmMvbW9ja19maWxlX3N5c3RlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUc3RDs7R0FFRztBQUNILE1BQU0sT0FBZ0IsY0FBYztJQUtsQyxZQUFvQixtQkFBbUIsS0FBSyxFQUFFLE1BQXNCLEdBQXFCO1FBQXJFLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBUTtRQUpwQyxjQUFTLEdBQVcsRUFBRSxDQUFDO1FBSzdCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0lBQy9CLENBQUM7SUFFRCxNQUFNLENBQUMsSUFBb0I7UUFDekIsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUM7SUFDakQsQ0FBQztJQUVELFFBQVEsQ0FBQyxJQUFvQjtRQUMzQixNQUFNLEVBQUMsTUFBTSxFQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNsQixPQUFPLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUMxQjthQUFNO1lBQ0wsTUFBTSxJQUFJLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsU0FBUyxJQUFJLG1CQUFtQixDQUFDLENBQUM7U0FDakY7SUFDSCxDQUFDO0lBRUQsY0FB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QUFhO0lBQ2pCLFlBQW9CLE1BQWM7UUFBZCxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQUcsQ0FBQztJQUN0QyxNQUFNO1FBQ0osT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFDRCxXQUFXO1FBQ1QsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDRCxjQUFjO1FBQ1osT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLENBQUM7Q0FDRjtBQUVELE1BQU0sbUJBQW9CLFNBQVEsS0FBSztJQUNyQyxZQUFtQixJQUFZLEVBQVMsSUFBWSxFQUFFLE9BQWU7UUFDbkUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBREUsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUFTLFNBQUksR0FBSixJQUFJLENBQVE7SUFFcEQsQ0FBQztDQUNGO0FBRUQsTUFBTSxVQUFVLE1BQU0sQ0FBQyxJQUFpQjtJQUN0QyxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDO0FBQzNELENBQUM7QUFFRCxNQUFNLFVBQVUsU0FBUyxDQUFDLElBQWlCO0lBQ3pDLE9BQU8sSUFBSSxZQUFZLE9BQU8sQ0FBQztBQUNqQyxDQUFDO0FBRUQsTUFBTSxVQUFVLFFBQVEsQ0FBQyxJQUFpQjtJQUN4QyxPQUFPLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge2Jhc2VuYW1lLCBkaXJuYW1lLCByZXNvbHZlfSBmcm9tICcuLi8uLi9zcmMvaGVscGVycyc7XG5pbXBvcnQge0Fic29sdXRlRnNQYXRoLCBGaWxlU3RhdHMsIEZpbGVTeXN0ZW0sIFBhdGhTZWdtZW50LCBQYXRoU3RyaW5nfSBmcm9tICcuLi8uLi9zcmMvdHlwZXMnO1xuXG4vKipcbiAqIEFuIGluLW1lbW9yeSBmaWxlIHN5c3RlbSB0aGF0IGNhbiBiZSB1c2VkIGluIHVuaXQgdGVzdHMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNb2NrRmlsZVN5c3RlbSBpbXBsZW1lbnRzIEZpbGVTeXN0ZW0ge1xuICBwcml2YXRlIF9maWxlVHJlZTogRm9sZGVyID0ge307XG4gIHByaXZhdGUgX2N3ZDogQWJzb2x1dGVGc1BhdGg7XG5cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pc0Nhc2VTZW5zaXRpdmUgPSBmYWxzZSwgY3dkOiBBYnNvbHV0ZUZzUGF0aCA9ICcvJyBhcyBBYnNvbHV0ZUZzUGF0aCkge1xuICAgIHRoaXMuX2N3ZCA9IHRoaXMubm9ybWFsaXplKGN3ZCk7XG4gIH1cblxuICBpc0Nhc2VTZW5zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2FzZVNlbnNpdGl2ZTtcbiAgfVxuXG4gIGV4aXN0cyhwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZpbmRGcm9tUGF0aChwYXRoKS5lbnRpdHkgIT09IG51bGw7XG4gIH1cblxuICByZWFkRmlsZShwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IHN0cmluZyB7XG4gICAgY29uc3Qge2VudGl0eX0gPSB0aGlzLmZpbmRGcm9tUGF0aChwYXRoKTtcbiAgICBpZiAoaXNGaWxlKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiBlbnRpdHkudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IE1vY2tGaWxlU3lzdGVtRXJyb3IoJ0VOT0VOVCcsIHBhdGgsIGBGaWxlIFwiJHtwYXRofVwiIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRGaWxlQnVmZmVyKHBhdGg6IEFic29sdXRlRnNQYXRoKTogVWludDhBcnJheSB7XG4gICAgY29uc3Qge2VudGl0eX0gPSB0aGlzLmZpbmRGcm9tUGF0aChwYXRoKTtcbiAgICBpZiAoaXNGaWxlKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiBlbnRpdHkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZW50aXR5IDogbmV3IEJ1ZmZlcihlbnRpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgTW9ja0ZpbGVTeXN0ZW1FcnJvcignRU5PRU5UJywgcGF0aCwgYEZpbGUgXCIke3BhdGh9XCIgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuICB9XG5cbiAgd3JpdGVGaWxlKHBhdGg6IEFic29sdXRlRnNQYXRoLCBkYXRhOiBzdHJpbmd8VWludDhBcnJheSwgZXhjbHVzaXZlOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCBbZm9sZGVyUGF0aCwgYmFzZW5hbWVdID0gdGhpcy5zcGxpdEludG9Gb2xkZXJBbmRGaWxlKHBhdGgpO1xuICAgIGNvbnN0IHtlbnRpdHl9ID0gdGhpcy5maW5kRnJvbVBhdGgoZm9sZGVyUGF0aCk7XG4gICAgaWYgKGVudGl0eSA9PT0gbnVsbCB8fCAhaXNGb2xkZXIoZW50aXR5KSkge1xuICAgICAgdGhyb3cgbmV3IE1vY2tGaWxlU3lzdGVtRXJyb3IoXG4gICAgICAgICAgJ0VOT0VOVCcsIHBhdGgsIGBVbmFibGUgdG8gd3JpdGUgZmlsZSBcIiR7cGF0aH1cIi4gVGhlIGNvbnRhaW5pbmcgZm9sZGVyIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgICBpZiAoZXhjbHVzaXZlICYmIGVudGl0eVtiYXNlbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IE1vY2tGaWxlU3lzdGVtRXJyb3IoXG4gICAgICAgICAgJ0VFWElTVCcsIHBhdGgsIGBVbmFibGUgdG8gZXhjbHVzaXZlbHkgd3JpdGUgZmlsZSBcIiR7cGF0aH1cIi4gVGhlIGZpbGUgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgfVxuICAgIGVudGl0eVtiYXNlbmFtZV0gPSBkYXRhO1xuICB9XG5cbiAgcmVtb3ZlRmlsZShwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IHZvaWQge1xuICAgIGNvbnN0IFtmb2xkZXJQYXRoLCBiYXNlbmFtZV0gPSB0aGlzLnNwbGl0SW50b0ZvbGRlckFuZEZpbGUocGF0aCk7XG4gICAgY29uc3Qge2VudGl0eX0gPSB0aGlzLmZpbmRGcm9tUGF0aChmb2xkZXJQYXRoKTtcbiAgICBpZiAoZW50aXR5ID09PSBudWxsIHx8ICFpc0ZvbGRlcihlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9ja0ZpbGVTeXN0ZW1FcnJvcihcbiAgICAgICAgICAnRU5PRU5UJywgcGF0aCwgYFVuYWJsZSB0byByZW1vdmUgZmlsZSBcIiR7cGF0aH1cIi4gVGhlIGNvbnRhaW5pbmcgZm9sZGVyIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgICBpZiAoaXNGb2xkZXIoZW50aXR5W2Jhc2VuYW1lXSkpIHtcbiAgICAgIHRocm93IG5ldyBNb2NrRmlsZVN5c3RlbUVycm9yKFxuICAgICAgICAgICdFSVNESVInLCBwYXRoLCBgVW5hYmxlIHRvIHJlbW92ZSBmaWxlIFwiJHtwYXRofVwiLiBUaGUgcGF0aCB0byByZW1vdmUgaXMgYSBmb2xkZXIuYCk7XG4gICAgfVxuICAgIGRlbGV0ZSBlbnRpdHlbYmFzZW5hbWVdO1xuICB9XG5cbiAgc3ltbGluayh0YXJnZXQ6IEFic29sdXRlRnNQYXRoLCBwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IHZvaWQge1xuICAgIGNvbnN0IFtmb2xkZXJQYXRoLCBiYXNlbmFtZV0gPSB0aGlzLnNwbGl0SW50b0ZvbGRlckFuZEZpbGUocGF0aCk7XG4gICAgY29uc3Qge2VudGl0eX0gPSB0aGlzLmZpbmRGcm9tUGF0aChmb2xkZXJQYXRoKTtcbiAgICBpZiAoZW50aXR5ID09PSBudWxsIHx8ICFpc0ZvbGRlcihlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9ja0ZpbGVTeXN0ZW1FcnJvcihcbiAgICAgICAgICAnRU5PRU5UJywgcGF0aCxcbiAgICAgICAgICBgVW5hYmxlIHRvIGNyZWF0ZSBzeW1saW5rIGF0IFwiJHtwYXRofVwiLiBUaGUgY29udGFpbmluZyBmb2xkZXIgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfVxuICAgIGVudGl0eVtiYXNlbmFtZV0gPSBuZXcgU3ltTGluayh0YXJnZXQpO1xuICB9XG5cbiAgcmVhZGRpcihwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IFBhdGhTZWdtZW50W10ge1xuICAgIGNvbnN0IHtlbnRpdHl9ID0gdGhpcy5maW5kRnJvbVBhdGgocGF0aCk7XG4gICAgaWYgKGVudGl0eSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE1vY2tGaWxlU3lzdGVtRXJyb3IoXG4gICAgICAgICAgJ0VOT0VOVCcsIHBhdGgsIGBVbmFibGUgdG8gcmVhZCBkaXJlY3RvcnkgXCIke3BhdGh9XCIuIEl0IGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgICBpZiAoaXNGaWxlKGVudGl0eSkpIHtcbiAgICAgIHRocm93IG5ldyBNb2NrRmlsZVN5c3RlbUVycm9yKFxuICAgICAgICAgICdFTk9URElSJywgcGF0aCwgYFVuYWJsZSB0byByZWFkIGRpcmVjdG9yeSBcIiR7cGF0aH1cIi4gSXQgaXMgYSBmaWxlLmApO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZW50aXR5KSBhcyBQYXRoU2VnbWVudFtdO1xuICB9XG5cbiAgbHN0YXQocGF0aDogQWJzb2x1dGVGc1BhdGgpOiBGaWxlU3RhdHMge1xuICAgIGNvbnN0IHtlbnRpdHl9ID0gdGhpcy5maW5kRnJvbVBhdGgocGF0aCk7XG4gICAgaWYgKGVudGl0eSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE1vY2tGaWxlU3lzdGVtRXJyb3IoJ0VOT0VOVCcsIHBhdGgsIGBGaWxlIFwiJHtwYXRofVwiIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1vY2tGaWxlU3RhdHMoZW50aXR5KTtcbiAgfVxuXG4gIHN0YXQocGF0aDogQWJzb2x1dGVGc1BhdGgpOiBGaWxlU3RhdHMge1xuICAgIGNvbnN0IHtlbnRpdHl9ID0gdGhpcy5maW5kRnJvbVBhdGgocGF0aCwge2ZvbGxvd1N5bUxpbmtzOiB0cnVlfSk7XG4gICAgaWYgKGVudGl0eSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE1vY2tGaWxlU3lzdGVtRXJyb3IoJ0VOT0VOVCcsIHBhdGgsIGBGaWxlIFwiJHtwYXRofVwiIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1vY2tGaWxlU3RhdHMoZW50aXR5KTtcbiAgfVxuXG4gIGNvcHlGaWxlKGZyb206IEFic29sdXRlRnNQYXRoLCB0bzogQWJzb2x1dGVGc1BhdGgpOiB2b2lkIHtcbiAgICB0aGlzLndyaXRlRmlsZSh0bywgdGhpcy5yZWFkRmlsZShmcm9tKSk7XG4gIH1cblxuICBtb3ZlRmlsZShmcm9tOiBBYnNvbHV0ZUZzUGF0aCwgdG86IEFic29sdXRlRnNQYXRoKTogdm9pZCB7XG4gICAgdGhpcy53cml0ZUZpbGUodG8sIHRoaXMucmVhZEZpbGUoZnJvbSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZmluZEZyb21QYXRoKGRpcm5hbWUoZnJvbSkpO1xuICAgIGNvbnN0IGZvbGRlciA9IHJlc3VsdC5lbnRpdHkgYXMgRm9sZGVyO1xuICAgIGNvbnN0IG5hbWUgPSBiYXNlbmFtZShmcm9tKTtcbiAgICBkZWxldGUgZm9sZGVyW25hbWVdO1xuICB9XG5cbiAgZW5zdXJlRGlyKHBhdGg6IEFic29sdXRlRnNQYXRoKTogRm9sZGVyIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc3BsaXRQYXRoKHBhdGgpLm1hcChzZWdtZW50ID0+IHRoaXMuZ2V0Q2Fub25pY2FsUGF0aChzZWdtZW50KSk7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSByb290IGZvbGRlciB0byBhIGNhbm9uaWNhbCBlbXB0eSBzdHJpbmcgYCcnYCAob24gV2luZG93cyBpdCB3b3VsZCBiZSBgJ0M6J2ApLlxuICAgIHNlZ21lbnRzWzBdID0gJyc7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEgJiYgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAvLyBSZW1vdmUgYSB0cmFpbGluZyBzbGFzaCAodW5sZXNzIHRoZSBwYXRoIHdhcyBvbmx5IGAvYClcbiAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50OiBGb2xkZXIgPSB0aGlzLl9maWxlVHJlZTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGlmIChpc0ZpbGUoY3VycmVudFtzZWdtZW50XSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb2xkZXIgYWxyZWFkeSBleGlzdHMgYXMgYSBmaWxlLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50W3NlZ21lbnRdKSB7XG4gICAgICAgIGN1cnJlbnRbc2VnbWVudF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3NlZ21lbnRdIGFzIEZvbGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICByZW1vdmVEZWVwKHBhdGg6IEFic29sdXRlRnNQYXRoKTogdm9pZCB7XG4gICAgY29uc3QgW2ZvbGRlclBhdGgsIGJhc2VuYW1lXSA9IHRoaXMuc3BsaXRJbnRvRm9sZGVyQW5kRmlsZShwYXRoKTtcbiAgICBjb25zdCB7ZW50aXR5fSA9IHRoaXMuZmluZEZyb21QYXRoKGZvbGRlclBhdGgpO1xuICAgIGlmIChlbnRpdHkgPT09IG51bGwgfHwgIWlzRm9sZGVyKGVudGl0eSkpIHtcbiAgICAgIHRocm93IG5ldyBNb2NrRmlsZVN5c3RlbUVycm9yKFxuICAgICAgICAgICdFTk9FTlQnLCBwYXRoLFxuICAgICAgICAgIGBVbmFibGUgdG8gcmVtb3ZlIGZvbGRlciBcIiR7cGF0aH1cIi4gVGhlIGNvbnRhaW5pbmcgZm9sZGVyIGRvZXMgbm90IGV4aXN0LmApO1xuICAgIH1cbiAgICBkZWxldGUgZW50aXR5W2Jhc2VuYW1lXTtcbiAgfVxuXG4gIGlzUm9vdChwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRpcm5hbWUocGF0aCkgPT09IHBhdGg7XG4gIH1cblxuICBleHRuYW1lKHBhdGg6IEFic29sdXRlRnNQYXRofFBhdGhTZWdtZW50KTogc3RyaW5nIHtcbiAgICBjb25zdCBtYXRjaCA9IC8uKyhcXC5bXi5dKikkLy5leGVjKHBhdGgpO1xuICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCA/IG1hdGNoWzFdIDogJyc7XG4gIH1cblxuICByZWFscGF0aChmaWxlUGF0aDogQWJzb2x1dGVGc1BhdGgpOiBBYnNvbHV0ZUZzUGF0aCB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5maW5kRnJvbVBhdGgoZmlsZVBhdGgsIHtmb2xsb3dTeW1MaW5rczogdHJ1ZX0pO1xuICAgIGlmIChyZXN1bHQuZW50aXR5ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTW9ja0ZpbGVTeXN0ZW1FcnJvcihcbiAgICAgICAgICAnRU5PRU5UJywgZmlsZVBhdGgsIGBVbmFibGUgdG8gZmluZCB0aGUgcmVhbCBwYXRoIG9mIFwiJHtmaWxlUGF0aH1cIi4gSXQgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQucGF0aDtcbiAgICB9XG4gIH1cblxuICBwd2QoKTogQWJzb2x1dGVGc1BhdGgge1xuICAgIHJldHVybiB0aGlzLl9jd2Q7XG4gIH1cblxuICBjaGRpcihwYXRoOiBBYnNvbHV0ZUZzUGF0aCk6IHZvaWQge1xuICAgIHRoaXMuX2N3ZCA9IHRoaXMubm9ybWFsaXplKHBhdGgpO1xuICB9XG5cbiAgZ2V0RGVmYXVsdExpYkxvY2F0aW9uKCk6IEFic29sdXRlRnNQYXRoIHtcbiAgICAvLyBNaW1pYyB0aGUgbm9kZSBtb2R1bGUgcmVzb2x1dGlvbiBhbGdvcml0aG0gYW5kIHN0YXJ0IGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSwgdGhlbiBsb29rXG4gICAgLy8gcHJvZ3Jlc3NpdmVseSBmdXJ0aGVyIHVwIHRoZSB0cmVlIHVudGlsIHJlYWNoaW5nIHRoZSBGUyByb290LlxuICAgIC8vIEUuZy4gaWYgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGlzIC9mb28vYmFyLCBsb29rIGluIC9mb28vYmFyL25vZGVfbW9kdWxlcywgdGhlblxuICAgIC8vIC9mb28vbm9kZV9tb2R1bGVzLCB0aGVuIC9ub2RlX21vZHVsZXMuXG5cbiAgICBsZXQgcGF0aCA9ICdub2RlX21vZHVsZXMvdHlwZXNjcmlwdC9saWInO1xuICAgIGxldCByZXNvbHZlZFBhdGggPSB0aGlzLnJlc29sdmUocGF0aCk7XG5cbiAgICAvLyBDb25zdHJ1Y3QgYSBwYXRoIGZvciB0aGUgdG9wLWxldmVsIG5vZGVfbW9kdWxlcyB0byBpZGVudGlmeSB0aGUgc3RvcHBpbmcgcG9pbnQuXG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlTW9kdWxlcyA9IHRoaXMucmVzb2x2ZSgnLycgKyBwYXRoKTtcblxuICAgIHdoaWxlIChyZXNvbHZlZFBhdGggIT09IHRvcExldmVsTm9kZU1vZHVsZXMpIHtcbiAgICAgIGlmICh0aGlzLmV4aXN0cyhyZXNvbHZlZFBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdCBoZXJlLCBsb29rIG9uZSBsZXZlbCBoaWdoZXIuXG4gICAgICBwYXRoID0gJy4uLycgKyBwYXRoO1xuICAgICAgcmVzb2x2ZWRQYXRoID0gdGhpcy5yZXNvbHZlKHBhdGgpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsb29wIGV4aXRzIGJlZm9yZSBjaGVja2luZyB0aGUgZXhpc3RlbmNlIG9mIC9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdCBhdCB0aGUgdG9wIGxldmVsLlxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgLSBpZiBubyAvbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQgZXhpc3RzIGFueXdoZXJlIGluIHRoZSB0cmVlLCB0aGVyZSdzXG4gICAgLy8gbm90aGluZyB0aGlzIGZ1bmN0aW9uIGNhbiBkbyBhYm91dCBpdCwgYW5kIFRTIG1heSBlcnJvciBsYXRlciBpZiBpdCBsb29rcyBmb3IgYSBsaWIuZC50cyBmaWxlXG4gICAgLy8gd2l0aGluIHRoaXMgZGlyZWN0b3J5LiBJdCBtaWdodCBiZSBva2F5LCB0aG91Z2gsIGlmIFRTIG5ldmVyIGNoZWNrcyBmb3Igb25lLlxuICAgIHJldHVybiB0b3BMZXZlbE5vZGVNb2R1bGVzO1xuICB9XG5cbiAgYWJzdHJhY3QgcmVzb2x2ZSguLi5wYXRoczogc3RyaW5nW10pOiBBYnNvbHV0ZUZzUGF0aDtcbiAgYWJzdHJhY3QgZGlybmFtZTxUIGV4dGVuZHMgc3RyaW5nPihmaWxlOiBUKTogVDtcbiAgYWJzdHJhY3Qgam9pbjxUIGV4dGVuZHMgc3RyaW5nPihiYXNlUGF0aDogVCwgLi4ucGF0aHM6IHN0cmluZ1tdKTogVDtcbiAgYWJzdHJhY3QgcmVsYXRpdmU8VCBleHRlbmRzIFBhdGhTdHJpbmc+KGZyb206IFQsIHRvOiBUKTogUGF0aFNlZ21lbnR8QWJzb2x1dGVGc1BhdGg7XG4gIGFic3RyYWN0IGJhc2VuYW1lKGZpbGVQYXRoOiBzdHJpbmcsIGV4dGVuc2lvbj86IHN0cmluZyk6IFBhdGhTZWdtZW50O1xuICBhYnN0cmFjdCBpc1Jvb3RlZChwYXRoOiBzdHJpbmcpOiBib29sZWFuO1xuICBhYnN0cmFjdCBub3JtYWxpemU8VCBleHRlbmRzIFBhdGhTdHJpbmc+KHBhdGg6IFQpOiBUO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc3BsaXRQYXRoPFQgZXh0ZW5kcyBQYXRoU3RyaW5nPihwYXRoOiBUKTogc3RyaW5nW107XG5cbiAgZHVtcCgpOiBGb2xkZXIge1xuICAgIGNvbnN0IHtlbnRpdHl9ID0gdGhpcy5maW5kRnJvbVBhdGgodGhpcy5yZXNvbHZlKCcvJykpO1xuICAgIGlmIChlbnRpdHkgPT09IG51bGwgfHwgIWlzRm9sZGVyKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jbG9uZUZvbGRlcihlbnRpdHkpO1xuICB9XG5cbiAgaW5pdChmb2xkZXI6IEZvbGRlcik6IHZvaWQge1xuICAgIHRoaXMubW91bnQodGhpcy5yZXNvbHZlKCcvJyksIGZvbGRlcik7XG4gIH1cblxuICBtb3VudChwYXRoOiBBYnNvbHV0ZUZzUGF0aCwgZm9sZGVyOiBGb2xkZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5leGlzdHMocGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG1vdW50IGluICcke3BhdGh9JyBhcyBpdCBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICB9XG4gICAgY29uc3QgbW91bnRGb2xkZXIgPSB0aGlzLmVuc3VyZURpcihwYXRoKTtcblxuICAgIHRoaXMuY29weUludG8oZm9sZGVyLCBtb3VudEZvbGRlcik7XG4gIH1cblxuICBwcml2YXRlIGNsb25lRm9sZGVyKGZvbGRlcjogRm9sZGVyKTogRm9sZGVyIHtcbiAgICBjb25zdCBjbG9uZTogRm9sZGVyID0ge307XG4gICAgdGhpcy5jb3B5SW50byhmb2xkZXIsIGNsb25lKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBwcml2YXRlIGNvcHlJbnRvKGZyb206IEZvbGRlciwgdG86IEZvbGRlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgcGF0aCBpbiBmcm9tKSB7XG4gICAgICBjb25zdCBpdGVtID0gZnJvbVtwYXRoXTtcbiAgICAgIGNvbnN0IGNhbm9uaWNhbFBhdGggPSB0aGlzLmdldENhbm9uaWNhbFBhdGgocGF0aCk7XG4gICAgICBpZiAoaXNTeW1MaW5rKGl0ZW0pKSB7XG4gICAgICAgIHRvW2Nhbm9uaWNhbFBhdGhdID0gbmV3IFN5bUxpbmsodGhpcy5nZXRDYW5vbmljYWxQYXRoKGl0ZW0ucGF0aCkpO1xuICAgICAgfSBlbHNlIGlmIChpc0ZvbGRlcihpdGVtKSkge1xuICAgICAgICB0b1tjYW5vbmljYWxQYXRoXSA9IHRoaXMuY2xvbmVGb2xkZXIoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1tjYW5vbmljYWxQYXRoXSA9IGZyb21bcGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBwcm90ZWN0ZWQgZmluZEZyb21QYXRoKHBhdGg6IEFic29sdXRlRnNQYXRoLCBvcHRpb25zPzoge2ZvbGxvd1N5bUxpbmtzOiBib29sZWFufSk6IEZpbmRSZXN1bHQge1xuICAgIGNvbnN0IGZvbGxvd1N5bUxpbmtzID0gISFvcHRpb25zICYmIG9wdGlvbnMuZm9sbG93U3ltTGlua3M7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNwbGl0UGF0aChwYXRoKTtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgIC8vIFJlbW92ZSBhIHRyYWlsaW5nIHNsYXNoICh1bmxlc3MgdGhlIHBhdGggd2FzIG9ubHkgYC9gKVxuICAgICAgc2VnbWVudHMucG9wKCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHJvb3QgZm9sZGVyIHRvIGEgY2Fub25pY2FsIGVtcHR5IHN0cmluZyBgXCJcImAgKG9uIFdpbmRvd3MgaXQgd291bGQgYmUgYEM6YCkuXG4gICAgc2VnbWVudHNbMF0gPSAnJztcbiAgICBsZXQgY3VycmVudDogRW50aXR5fG51bGwgPSB0aGlzLl9maWxlVHJlZTtcbiAgICB3aGlsZSAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudFt0aGlzLmdldENhbm9uaWNhbFBhdGgoc2VnbWVudHMuc2hpZnQoKSEpXTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtwYXRoLCBlbnRpdHk6IG51bGx9O1xuICAgICAgfVxuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDAgJiYgKCFpc0ZvbGRlcihjdXJyZW50KSkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGlzRmlsZShjdXJyZW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bUxpbmsoY3VycmVudCkpIHtcbiAgICAgICAgaWYgKGZvbGxvd1N5bUxpbmtzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEZyb21QYXRoKHJlc29sdmUoY3VycmVudC5wYXRoLCAuLi5zZWdtZW50cyksIHtmb2xsb3dTeW1MaW5rc30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7cGF0aCwgZW50aXR5OiBjdXJyZW50fTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzcGxpdEludG9Gb2xkZXJBbmRGaWxlKHBhdGg6IEFic29sdXRlRnNQYXRoKTogW0Fic29sdXRlRnNQYXRoLCBzdHJpbmddIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc3BsaXRQYXRoKHRoaXMuZ2V0Q2Fub25pY2FsUGF0aChwYXRoKSk7XG4gICAgY29uc3QgZmlsZSA9IHNlZ21lbnRzLnBvcCgpITtcbiAgICByZXR1cm4gW3BhdGguc3Vic3RyaW5nKDAsIHBhdGgubGVuZ3RoIC0gZmlsZS5sZW5ndGggLSAxKSBhcyBBYnNvbHV0ZUZzUGF0aCwgZmlsZV07XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Q2Fub25pY2FsUGF0aDxUIGV4dGVuZHMgc3RyaW5nPihwOiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaXNDYXNlU2Vuc2l0aXZlKCkgPyBwIDogcC50b0xvd2VyQ2FzZSgpIGFzIFQ7XG4gIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmluZFJlc3VsdCB7XG4gIHBhdGg6IEFic29sdXRlRnNQYXRoO1xuICBlbnRpdHk6IEVudGl0eXxudWxsO1xufVxuZXhwb3J0IHR5cGUgRW50aXR5ID0gRm9sZGVyfEZpbGV8U3ltTGluaztcbmV4cG9ydCBpbnRlcmZhY2UgRm9sZGVyIHtcbiAgW3BhdGhTZWdtZW50czogc3RyaW5nXTogRW50aXR5O1xufVxuZXhwb3J0IHR5cGUgRmlsZSA9IHN0cmluZ3xVaW50OEFycmF5O1xuZXhwb3J0IGNsYXNzIFN5bUxpbmsge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGF0aDogQWJzb2x1dGVGc1BhdGgpIHt9XG59XG5cbmNsYXNzIE1vY2tGaWxlU3RhdHMgaW1wbGVtZW50cyBGaWxlU3RhdHMge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVudGl0eTogRW50aXR5KSB7fVxuICBpc0ZpbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzRmlsZSh0aGlzLmVudGl0eSk7XG4gIH1cbiAgaXNEaXJlY3RvcnkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzRm9sZGVyKHRoaXMuZW50aXR5KTtcbiAgfVxuICBpc1N5bWJvbGljTGluaygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNTeW1MaW5rKHRoaXMuZW50aXR5KTtcbiAgfVxufVxuXG5jbGFzcyBNb2NrRmlsZVN5c3RlbUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY29kZTogc3RyaW5nLCBwdWJsaWMgcGF0aDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlKGl0ZW06IEVudGl0eXxudWxsKTogaXRlbSBpcyBGaWxlIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSB8fCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N5bUxpbmsoaXRlbTogRW50aXR5fG51bGwpOiBpdGVtIGlzIFN5bUxpbmsge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIFN5bUxpbms7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZvbGRlcihpdGVtOiBFbnRpdHl8bnVsbCk6IGl0ZW0gaXMgRm9sZGVyIHtcbiAgcmV0dXJuIGl0ZW0gIT09IG51bGwgJiYgIWlzRmlsZShpdGVtKSAmJiAhaXNTeW1MaW5rKGl0ZW0pO1xufVxuIl19