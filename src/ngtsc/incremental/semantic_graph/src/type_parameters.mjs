/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
import { isArrayEqual } from './util';
/**
 * Converts the type parameters of the given class into their semantic representation. If the class
 * does not have any type parameters, then `null` is returned.
 */
export function extractSemanticTypeParameters(node) {
    if (!ts.isClassDeclaration(node) || node.typeParameters === undefined) {
        return null;
    }
    return node.typeParameters.map(typeParam => ({ hasGenericTypeBound: typeParam.constraint !== undefined }));
}
/**
 * Compares the list of type parameters to determine if they can be considered equal.
 */
export function areTypeParametersEqual(current, previous) {
    // First compare all type parameters one-to-one; any differences mean that the list of type
    // parameters has changed.
    if (!isArrayEqual(current, previous, isTypeParameterEqual)) {
        return false;
    }
    // If there is a current list of type parameters and if any of them has a generic type constraint,
    // then the meaning of that type parameter may have changed without us being aware; as such we
    // have to assume that the type parameters have in fact changed.
    if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {
        return false;
    }
    return true;
}
function isTypeParameterEqual(a, b) {
    return a.hasGenericTypeBound === b.hasGenericTypeBound;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZV9wYXJhbWV0ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL3NyYy9uZ3RzYy9pbmNyZW1lbnRhbC9zZW1hbnRpY19ncmFwaC9zcmMvdHlwZV9wYXJhbWV0ZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sS0FBSyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBR2pDLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFzQnBDOzs7R0FHRztBQUNILE1BQU0sVUFBVSw2QkFBNkIsQ0FBQyxJQUFzQjtJQUVsRSxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssU0FBUyxFQUFFO1FBQ3JFLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUMxQixTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBQyxtQkFBbUIsRUFBRSxTQUFTLENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBQyxDQUFDLENBQUMsQ0FBQztBQUNoRixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQ2xDLE9BQXFDLEVBQUUsUUFBc0M7SUFDL0UsMkZBQTJGO0lBQzNGLDBCQUEwQjtJQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsb0JBQW9CLENBQUMsRUFBRTtRQUMxRCxPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsa0dBQWtHO0lBQ2xHLDhGQUE4RjtJQUM5RixnRUFBZ0U7SUFDaEUsSUFBSSxPQUFPLEtBQUssSUFBSSxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsRUFBRTtRQUNoRixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBRUQsU0FBUyxvQkFBb0IsQ0FBQyxDQUF3QixFQUFFLENBQXdCO0lBQzlFLE9BQU8sQ0FBQyxDQUFDLG1CQUFtQixLQUFLLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQztBQUN6RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtDbGFzc0RlY2xhcmF0aW9ufSBmcm9tICcuLi8uLi8uLi9yZWZsZWN0aW9uJztcbmltcG9ydCB7aXNBcnJheUVxdWFsfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIERlc2NyaWJlcyBhIGdlbmVyaWMgdHlwZSBwYXJhbWV0ZXIgb2YgYSBzZW1hbnRpYyBzeW1ib2wuIEEgY2xhc3MgZGVjbGFyYXRpb24gd2l0aCB0eXBlIHBhcmFtZXRlcnNcbiAqIG5lZWRzIHNwZWNpYWwgY29uc2lkZXJhdGlvbiBpbiBjZXJ0YWluIGNvbnRleHRzLiBGb3IgZXhhbXBsZSwgdGVtcGxhdGUgdHlwZS1jaGVjayBibG9ja3MgbWF5XG4gKiBjb250YWluIHR5cGUgY29uc3RydWN0b3JzIG9mIHVzZWQgZGlyZWN0aXZlcyB3aGljaCBpbmNsdWRlIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGRpcmVjdGl2ZS5cbiAqIEFzIGEgY29uc2VxdWVuY2UsIGlmIGEgY2hhbmdlIGlzIG1hZGUgdGhhdCBhZmZlY3RzIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2Ygc2FpZCBkaXJlY3RpdmUsIGFueVxuICogdGVtcGxhdGUgdHlwZS1jaGVjayBibG9ja3MgdGhhdCB1c2UgdGhlIGRpcmVjdGl2ZSBuZWVkIHRvIGJlIHJlZ2VuZXJhdGVkLlxuICpcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgc2luZ2xlIGdlbmVyaWMgdHlwZSBwYXJhbWV0ZXIuIEl0IGN1cnJlbnRseSBvbmx5IHRyYWNrcyB3aGV0aGVyIHRoZVxuICogdHlwZSBwYXJhbWV0ZXIgaGFzIGEgY29uc3RyYWludCwgaS5lLiBoYXMgYW4gYGV4dGVuZHNgIGNsYXVzZS4gV2hlbiBhIGNvbnN0cmFpbnQgaXMgcHJlc2VudCwgd2VcbiAqIGN1cnJlbnRseSBhc3N1bWUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgYWZmZWN0ZWQgaW4gZWFjaCBpbmNyZW1lbnRhbCByZWJ1aWxkOyBwcm92aW5nIHRoYXRcbiAqIGEgdHlwZSBwYXJhbWV0ZXIgd2l0aCBjb25zdHJhaW50IGlzIG5vdCBhZmZlY3RlZCBpcyBub24tdHJpdmlhbCBhcyBpdCByZXF1aXJlcyBmdWxsIHNlbWFudGljXG4gKiB1bmRlcnN0YW5kaW5nIG9mIHRoZSB0eXBlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VtYW50aWNUeXBlUGFyYW1ldGVyIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgYSB0eXBlIGNvbnN0cmFpbnQsIGkuZS4gYW4gYGV4dGVuZHNgIGNsYXVzZSBpcyBwcmVzZW50IG9uIHRoZSB0eXBlIHBhcmFtZXRlci5cbiAgICovXG4gIGhhc0dlbmVyaWNUeXBlQm91bmQ6IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZ2l2ZW4gY2xhc3MgaW50byB0aGVpciBzZW1hbnRpYyByZXByZXNlbnRhdGlvbi4gSWYgdGhlIGNsYXNzXG4gKiBkb2VzIG5vdCBoYXZlIGFueSB0eXBlIHBhcmFtZXRlcnMsIHRoZW4gYG51bGxgIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFNlbWFudGljVHlwZVBhcmFtZXRlcnMobm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IFNlbWFudGljVHlwZVBhcmFtZXRlcltdfFxuICAgIG51bGwge1xuICBpZiAoIXRzLmlzQ2xhc3NEZWNsYXJhdGlvbihub2RlKSB8fCBub2RlLnR5cGVQYXJhbWV0ZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBub2RlLnR5cGVQYXJhbWV0ZXJzLm1hcChcbiAgICAgIHR5cGVQYXJhbSA9PiAoe2hhc0dlbmVyaWNUeXBlQm91bmQ6IHR5cGVQYXJhbS5jb25zdHJhaW50ICE9PSB1bmRlZmluZWR9KSk7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIGxpc3Qgb2YgdHlwZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSBpZiB0aGV5IGNhbiBiZSBjb25zaWRlcmVkIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlVHlwZVBhcmFtZXRlcnNFcXVhbChcbiAgICBjdXJyZW50OiBTZW1hbnRpY1R5cGVQYXJhbWV0ZXJbXXxudWxsLCBwcmV2aW91czogU2VtYW50aWNUeXBlUGFyYW1ldGVyW118bnVsbCk6IGJvb2xlYW4ge1xuICAvLyBGaXJzdCBjb21wYXJlIGFsbCB0eXBlIHBhcmFtZXRlcnMgb25lLXRvLW9uZTsgYW55IGRpZmZlcmVuY2VzIG1lYW4gdGhhdCB0aGUgbGlzdCBvZiB0eXBlXG4gIC8vIHBhcmFtZXRlcnMgaGFzIGNoYW5nZWQuXG4gIGlmICghaXNBcnJheUVxdWFsKGN1cnJlbnQsIHByZXZpb3VzLCBpc1R5cGVQYXJhbWV0ZXJFcXVhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBhIGN1cnJlbnQgbGlzdCBvZiB0eXBlIHBhcmFtZXRlcnMgYW5kIGlmIGFueSBvZiB0aGVtIGhhcyBhIGdlbmVyaWMgdHlwZSBjb25zdHJhaW50LFxuICAvLyB0aGVuIHRoZSBtZWFuaW5nIG9mIHRoYXQgdHlwZSBwYXJhbWV0ZXIgbWF5IGhhdmUgY2hhbmdlZCB3aXRob3V0IHVzIGJlaW5nIGF3YXJlOyBhcyBzdWNoIHdlXG4gIC8vIGhhdmUgdG8gYXNzdW1lIHRoYXQgdGhlIHR5cGUgcGFyYW1ldGVycyBoYXZlIGluIGZhY3QgY2hhbmdlZC5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5zb21lKHR5cGVQYXJhbSA9PiB0eXBlUGFyYW0uaGFzR2VuZXJpY1R5cGVCb3VuZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlUGFyYW1ldGVyRXF1YWwoYTogU2VtYW50aWNUeXBlUGFyYW1ldGVyLCBiOiBTZW1hbnRpY1R5cGVQYXJhbWV0ZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGEuaGFzR2VuZXJpY1R5cGVCb3VuZCA9PT0gYi5oYXNHZW5lcmljVHlwZUJvdW5kO1xufVxuIl19