(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api", ["require", "exports", "typescript", "@angular/compiler-cli/src/ngtsc/file_system"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticSymbol = void 0;
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ts = require("typescript");
    var file_system_1 = require("@angular/compiler-cli/src/ngtsc/file_system");
    /**
     * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured
     * metadata to be compared to the prior compilation. This allows for semantic understanding of
     * the changes that have been made in a rebuild, which potentially enables more reuse of work
     * from the prior compilation.
     */
    var SemanticSymbol = /** @class */ (function () {
        function SemanticSymbol(
        /**
         * The declaration for this symbol.
         */
        decl) {
            this.decl = decl;
            this.path = file_system_1.absoluteFromSourceFile(decl.getSourceFile());
            this.identifier = getSymbolIdentifier(decl);
        }
        return SemanticSymbol;
    }());
    exports.SemanticSymbol = SemanticSymbol;
    function getSymbolIdentifier(decl) {
        if (!ts.isSourceFile(decl.parent)) {
            return null;
        }
        // If this is a top-level class declaration, the class name is used as unique identifier.
        // Other scenarios are currently not supported and causes the symbol not to be identified
        // across rebuilds, unless the declaration node has not changed.
        return decl.name.text;
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29tcGlsZXItY2xpL3NyYy9uZ3RzYy9pbmNyZW1lbnRhbC9zZW1hbnRpY19ncmFwaC9zcmMvYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUFBOzs7Ozs7T0FNRztJQUNILCtCQUFpQztJQUVqQywyRUFBNEU7SUFHNUU7Ozs7O09BS0c7SUFDSDtRQWlCRTtRQUNJOztXQUVHO1FBQ2EsSUFBc0I7WUFBdEIsU0FBSSxHQUFKLElBQUksQ0FBa0I7WUFFeEMsSUFBSSxDQUFDLElBQUksR0FBRyxvQ0FBc0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsVUFBVSxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlDLENBQUM7UUErQkgscUJBQUM7SUFBRCxDQUFDLEFBeERELElBd0RDO0lBeERxQix3Q0FBYztJQTJFcEMsU0FBUyxtQkFBbUIsQ0FBQyxJQUFzQjtRQUNqRCxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELHlGQUF5RjtRQUN6Rix5RkFBeUY7UUFDekYsZ0VBQWdFO1FBQ2hFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDeEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7YWJzb2x1dGVGcm9tU291cmNlRmlsZSwgQWJzb2x1dGVGc1BhdGh9IGZyb20gJy4uLy4uLy4uL2ZpbGVfc3lzdGVtJztcbmltcG9ydCB7Q2xhc3NEZWNsYXJhdGlvbn0gZnJvbSAnLi4vLi4vLi4vcmVmbGVjdGlvbic7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIHJlY29nbml6YWJsZSBhY3Jvc3MgaW5jcmVtZW50YWwgcmVidWlsZHMsIHdoaWNoIGVuYWJsZXMgdGhlIGNhcHR1cmVkXG4gKiBtZXRhZGF0YSB0byBiZSBjb21wYXJlZCB0byB0aGUgcHJpb3IgY29tcGlsYXRpb24uIFRoaXMgYWxsb3dzIGZvciBzZW1hbnRpYyB1bmRlcnN0YW5kaW5nIG9mXG4gKiB0aGUgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBtYWRlIGluIGEgcmVidWlsZCwgd2hpY2ggcG90ZW50aWFsbHkgZW5hYmxlcyBtb3JlIHJldXNlIG9mIHdvcmtcbiAqIGZyb20gdGhlIHByaW9yIGNvbXBpbGF0aW9uLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2VtYW50aWNTeW1ib2wge1xuICAvKipcbiAgICogVGhlIHBhdGggb2YgdGhlIGZpbGUgdGhhdCBkZWNsYXJlcyB0aGlzIHN5bWJvbC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwYXRoOiBBYnNvbHV0ZUZzUGF0aDtcblxuICAvKipcbiAgICogVGhlIGlkZW50aWZpZXIgb2YgdGhpcyBzeW1ib2wsIG9yIG51bGwgaWYgbm8gaWRlbnRpZmllciBjb3VsZCBiZSBkZXRlcm1pbmVkLiBJdCBzaG91bGRcbiAgICogdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHN5bWJvbCByZWxhdGl2ZSB0byBgZmlsZWAuIFRoaXMgaXMgdHlwaWNhbGx5IGp1c3QgdGhlIG5hbWUgb2YgYVxuICAgKiB0b3AtbGV2ZWwgY2xhc3MgZGVjbGFyYXRpb24sIGFzIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgY2xhc3Mgd2l0aGluIHRoZSBmaWxlLlxuICAgKlxuICAgKiBJZiB0aGUgaWRlbnRpZmllciBpcyBudWxsLCB0aGVuIHRoaXMgc3ltYm9sIGNhbm5vdCBiZSByZWNvZ25pemVkIGFjcm9zcyByZWJ1aWxkcy4gSW4gdGhhdFxuICAgKiBjYXNlLCB0aGUgc3ltYm9sIGlzIGFsd2F5cyBhc3N1bWVkIHRvIGhhdmUgc2VtYW50aWNhbGx5IGNoYW5nZWQgdG8gZ3VhcmFudGVlIGEgcHJvcGVyXG4gICAqIHJlYnVpbGQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaWRlbnRpZmllcjogc3RyaW5nfG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZWNsYXJhdGlvbiBmb3IgdGhpcyBzeW1ib2wuXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkZWNsOiBDbGFzc0RlY2xhcmF0aW9uLFxuICApIHtcbiAgICB0aGlzLnBhdGggPSBhYnNvbHV0ZUZyb21Tb3VyY2VGaWxlKGRlY2wuZ2V0U291cmNlRmlsZSgpKTtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBnZXRTeW1ib2xJZGVudGlmaWVyKGRlY2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgc3ltYm9sIHRvIGJlIGNvbXBhcmVkIHRvIHRoZSBlcXVpdmFsZW50IHN5bWJvbCBpbiB0aGUgcHJldmlvdXMgY29tcGlsYXRpb24uIFRoZVxuICAgKiByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN5bWJvbCBoYXMgYmVlbiBjaGFuZ2VkIGluIGEgd2F5IHN1Y2ggdGhhdCBpdHMgcHVibGljIEFQSVxuICAgKiBpcyBhZmZlY3RlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIGEgY2hhbmdlIHRvIF90aGlzXyBzeW1ib2wgcmVxdWlyZSB0aGUgc3ltYm9scyB0aGF0XG4gICAqIHVzZSB0byB0aGlzIHN5bWJvbCB0byBiZSByZS1lbWl0dGVkLlxuICAgKlxuICAgKiBOb3RlOiBgcHJldmlvdXNTeW1ib2xgIGlzIG9idGFpbmVkIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgc3VjY2VlZGVkIGNvbXBpbGF0aW9uLiBTeW1ib2xzIG9mXG4gICAqIGZhaWxlZCBjb21waWxhdGlvbnMgYXJlIG5ldmVyIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gcHJldmlvdXNTeW1ib2wgVGhlIHN5bWJvbCBmcm9tIGEgcHJpb3IgY29tcGlsYXRpb24uXG4gICAqL1xuICBhYnN0cmFjdCBpc1B1YmxpY0FwaUFmZmVjdGVkKHByZXZpb3VzU3ltYm9sOiBTZW1hbnRpY1N5bWJvbCk6IGJvb2xlYW47XG5cbiAgYWJzdHJhY3QgaXNUeXBlQ2hlY2tFbWl0QWZmZWN0ZWQocHJldmlvdXNTeW1ib2w6IFNlbWFudGljU3ltYm9sKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBzeW1ib2wgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgaXRzIGVtaXQgaXMgYWZmZWN0ZWQuIFRoZSBlcXVpdmFsZW50IHN5bWJvbCBmcm9tIGEgcHJpb3JcbiAgICogYnVpbGQgaXMgZ2l2ZW4sIGluIGFkZGl0aW9uIHRvIHRoZSBzZXQgb2Ygc3ltYm9scyBvZiB3aGljaCB0aGUgcHVibGljIEFQSSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB3aGV0aGVyIGEgY2hhbmdlIHRvIF9vdGhlcl8gc3ltYm9scywgaS5lLiB0aG9zZSBwcmVzZW50IGluXG4gICAqIGBwdWJsaWNBcGlBZmZlY3RlZGAsIHNob3VsZCBjYXVzZSBfdGhpc18gc3ltYm9sIHRvIGJlIHJlLWVtaXR0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBwcmV2aW91c1N5bWJvbCBUaGUgZXF1aXZhbGVudCBzeW1ib2wgZnJvbSBhIHByaW9yIGNvbXBpbGF0aW9uLiBOb3RlIHRoYXQgaXQgbWF5IGJlIGFcbiAgICogZGlmZmVyZW50IHR5cGUgb2Ygc3ltYm9sLCBpZiBlLmcuIGEgQ29tcG9uZW50IHdhcyBjaGFuZ2VkIGludG8gYSBEaXJlY3RpdmUgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICAgKiBAcGFyYW0gcHVibGljQXBpQWZmZWN0ZWQgVGhlIHNldCBvZiBzeW1ib2xzIHdoaWNoIG9mIHdoaWNoIHRoZSBwdWJsaWMgQVBJIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgaXNFbWl0QWZmZWN0ZWQ/KHByZXZpb3VzU3ltYm9sOiBTZW1hbnRpY1N5bWJvbCwgcHVibGljQXBpQWZmZWN0ZWQ6IFNldDxTZW1hbnRpY1N5bWJvbD4pOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZWZlcmVuY2UgdG8gYSBzZW1hbnRpYyBzeW1ib2wgdGhhdCBoYXMgYmVlbiBlbWl0dGVkIGludG8gYSBzb3VyY2UgZmlsZS4gVGhlXG4gKiByZWZlcmVuY2UgbWF5IHJlZmVyIHRvIHRoZSBzeW1ib2wgdXNpbmcgYSBkaWZmZXJlbnQgbmFtZSB0aGFuIHRoZSBzZW1hbnRpYyBzeW1ib2wncyBkZWNsYXJlZFxuICogbmFtZSwgZS5nLiBpbiBjYXNlIGEgcmUtZXhwb3J0IHVuZGVyIGEgZGlmZmVyZW50IG5hbWUgd2FzIGNob3NlbiBieSBhIHJlZmVyZW5jZSBlbWl0dGVyLlxuICogQ29uc2VxdWVudGx5LCB0byBrbm93IHRoYXQgYW4gZW1pdHRlZCByZWZlcmVuY2UgaXMgc3RpbGwgdmFsaWQgbm90IG9ubHkgcmVxdWlyZXMgdGhhdCB0aGVcbiAqIHNlbWFudGljIHN5bWJvbCBpcyBzdGlsbCB2YWxpZCwgYnV0IGFsc28gdGhhdCB0aGUgcGF0aCBieSB3aGljaCB0aGUgc3ltYm9sIGlzIGltcG9ydGVkIGhhcyBub3RcbiAqIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VtYW50aWNSZWZlcmVuY2Uge1xuICBzeW1ib2w6IFNlbWFudGljU3ltYm9sO1xuXG4gIC8qKlxuICAgKiBUaGUgcGF0aCBieSB3aGljaCB0aGUgc3ltYm9sIGhhcyBiZWVuIHJlZmVyZW5jZWQuXG4gICAqL1xuICBpbXBvcnRQYXRoOiBzdHJpbmd8bnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U3ltYm9sSWRlbnRpZmllcihkZWNsOiBDbGFzc0RlY2xhcmF0aW9uKTogc3RyaW5nfG51bGwge1xuICBpZiAoIXRzLmlzU291cmNlRmlsZShkZWNsLnBhcmVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoaXMgaXMgYSB0b3AtbGV2ZWwgY2xhc3MgZGVjbGFyYXRpb24sIHRoZSBjbGFzcyBuYW1lIGlzIHVzZWQgYXMgdW5pcXVlIGlkZW50aWZpZXIuXG4gIC8vIE90aGVyIHNjZW5hcmlvcyBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYW5kIGNhdXNlcyB0aGUgc3ltYm9sIG5vdCB0byBiZSBpZGVudGlmaWVkXG4gIC8vIGFjcm9zcyByZWJ1aWxkcywgdW5sZXNzIHRoZSBkZWNsYXJhdGlvbiBub2RlIGhhcyBub3QgY2hhbmdlZC5cbiAgcmV0dXJuIGRlY2wubmFtZS50ZXh0O1xufVxuIl19