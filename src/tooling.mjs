/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { TypeScriptReflectionHost } from './ngtsc/reflection';
import { getDownlevelDecoratorsTransform } from './transformers/downlevel_decorators_transform';
/**
 * Known values for global variables in `@angular/core` that Terser should set using
 * https://github.com/terser-js/terser#conditional-compilation
 */
export const GLOBAL_DEFS_FOR_TERSER = {
    ngDevMode: false,
    ngI18nClosureMode: false,
};
export const GLOBAL_DEFS_FOR_TERSER_WITH_AOT = Object.assign(Object.assign({}, GLOBAL_DEFS_FOR_TERSER), { ngJitMode: false });
/**
 * Transform for downleveling Angular decorators and Angular-decorated class constructor
 * parameters for dependency injection. This transform can be used by the CLI for JIT-mode
 * compilation where constructor parameters and associated Angular decorators should be
 * downleveled so that apps are not exposed to the ES2015 temporal dead zone limitation
 * in TypeScript. See https://github.com/angular/angular-cli/pull/14473 for more details.
 */
export function constructorParametersDownlevelTransform(program) {
    const typeChecker = program.getTypeChecker();
    const reflectionHost = new TypeScriptReflectionHost(typeChecker);
    return getDownlevelDecoratorsTransform(typeChecker, reflectionHost, [], /* isCore */ false, 
    /* enableClosureCompiler */ false, /* skipClassDecorators */ true);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvdG9vbGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFXSCxPQUFPLEVBQUMsd0JBQXdCLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUM1RCxPQUFPLEVBQUMsK0JBQStCLEVBQUMsTUFBTSwrQ0FBK0MsQ0FBQztBQUU5Rjs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxzQkFBc0IsR0FBRztJQUNwQyxTQUFTLEVBQUUsS0FBSztJQUNoQixpQkFBaUIsRUFBRSxLQUFLO0NBQ3pCLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSwrQkFBK0IsbUNBQ3ZDLHNCQUFzQixLQUN6QixTQUFTLEVBQUUsS0FBSyxHQUNqQixDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLHVDQUF1QyxDQUFDLE9BQW1CO0lBRXpFLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUM3QyxNQUFNLGNBQWMsR0FBRyxJQUFJLHdCQUF3QixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2pFLE9BQU8sK0JBQStCLENBQ2xDLFdBQVcsRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFLFlBQVksQ0FBQyxLQUFLO0lBQ25ELDJCQUEyQixDQUFDLEtBQUssRUFBRSx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogVGhpcyBmaWxlIGlzIHVzZWQgYXMgYSBwcml2YXRlIEFQSSBjaGFubmVsIHRvIHNoYXJlZCBBbmd1bGFyIEZXIEFQSXMgd2l0aCBAYW5ndWxhci9jbGkuXG4gKlxuICogQW55IGNoYW5nZXMgdG8gdGhpcyBmaWxlIHNob3VsZCBiZSBkaXNjdXNzZWQgd2l0aCB0aGUgQW5ndWxhciBDTEkgdGVhbS5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtUeXBlU2NyaXB0UmVmbGVjdGlvbkhvc3R9IGZyb20gJy4vbmd0c2MvcmVmbGVjdGlvbic7XG5pbXBvcnQge2dldERvd25sZXZlbERlY29yYXRvcnNUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtZXJzL2Rvd25sZXZlbF9kZWNvcmF0b3JzX3RyYW5zZm9ybSc7XG5cbi8qKlxuICogS25vd24gdmFsdWVzIGZvciBnbG9iYWwgdmFyaWFibGVzIGluIGBAYW5ndWxhci9jb3JlYCB0aGF0IFRlcnNlciBzaG91bGQgc2V0IHVzaW5nXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdGVyc2VyLWpzL3RlcnNlciNjb25kaXRpb25hbC1jb21waWxhdGlvblxuICovXG5leHBvcnQgY29uc3QgR0xPQkFMX0RFRlNfRk9SX1RFUlNFUiA9IHtcbiAgbmdEZXZNb2RlOiBmYWxzZSxcbiAgbmdJMThuQ2xvc3VyZU1vZGU6IGZhbHNlLFxufTtcblxuZXhwb3J0IGNvbnN0IEdMT0JBTF9ERUZTX0ZPUl9URVJTRVJfV0lUSF9BT1QgPSB7XG4gIC4uLkdMT0JBTF9ERUZTX0ZPUl9URVJTRVIsXG4gIG5nSml0TW9kZTogZmFsc2UsXG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBmb3IgZG93bmxldmVsaW5nIEFuZ3VsYXIgZGVjb3JhdG9ycyBhbmQgQW5ndWxhci1kZWNvcmF0ZWQgY2xhc3MgY29uc3RydWN0b3JcbiAqIHBhcmFtZXRlcnMgZm9yIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBUaGlzIHRyYW5zZm9ybSBjYW4gYmUgdXNlZCBieSB0aGUgQ0xJIGZvciBKSVQtbW9kZVxuICogY29tcGlsYXRpb24gd2hlcmUgY29uc3RydWN0b3IgcGFyYW1ldGVycyBhbmQgYXNzb2NpYXRlZCBBbmd1bGFyIGRlY29yYXRvcnMgc2hvdWxkIGJlXG4gKiBkb3dubGV2ZWxlZCBzbyB0aGF0IGFwcHMgYXJlIG5vdCBleHBvc2VkIHRvIHRoZSBFUzIwMTUgdGVtcG9yYWwgZGVhZCB6b25lIGxpbWl0YXRpb25cbiAqIGluIFR5cGVTY3JpcHQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLWNsaS9wdWxsLzE0NDczIGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RvclBhcmFtZXRlcnNEb3dubGV2ZWxUcmFuc2Zvcm0ocHJvZ3JhbTogdHMuUHJvZ3JhbSk6XG4gICAgdHMuVHJhbnNmb3JtZXJGYWN0b3J5PHRzLlNvdXJjZUZpbGU+IHtcbiAgY29uc3QgdHlwZUNoZWNrZXIgPSBwcm9ncmFtLmdldFR5cGVDaGVja2VyKCk7XG4gIGNvbnN0IHJlZmxlY3Rpb25Ib3N0ID0gbmV3IFR5cGVTY3JpcHRSZWZsZWN0aW9uSG9zdCh0eXBlQ2hlY2tlcik7XG4gIHJldHVybiBnZXREb3dubGV2ZWxEZWNvcmF0b3JzVHJhbnNmb3JtKFxuICAgICAgdHlwZUNoZWNrZXIsIHJlZmxlY3Rpb25Ib3N0LCBbXSwgLyogaXNDb3JlICovIGZhbHNlLFxuICAgICAgLyogZW5hYmxlQ2xvc3VyZUNvbXBpbGVyICovIGZhbHNlLCAvKiBza2lwQ2xhc3NEZWNvcmF0b3JzICovIHRydWUpO1xufVxuIl19