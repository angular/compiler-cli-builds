{"version":3,"file":"inline_resources.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/inline_resources.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataObject, MetadataValue, isClassMetadata, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicCallExpression} from '../metadata/index';\n\nimport {MetadataTransformer, ValueTransform} from './metadata_cache';\n\nexport type ResourceLoader = {\n  loadResource(path: string): Promise<string>| string;\n};\n\nexport class InlineResourcesMetadataTransformer implements MetadataTransformer {\n  constructor(private host: ResourceLoader) {}\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (isClassMetadata(value) && ts.isClassDeclaration(node) && value.decorators) {\n        value.decorators.forEach(d => {\n          if (isMetadataSymbolicCallExpression(d) &&\n              isMetadataImportedSymbolReferenceExpression(d.expression) &&\n              d.expression.module === '@angular/core' && d.expression.name === 'Component' &&\n              d.arguments) {\n            d.arguments = d.arguments.map(this.updateDecoratorMetadata.bind(this));\n          }\n        });\n      }\n      return value;\n    };\n  }\n\n  inlineResource(url: MetadataValue): string|undefined {\n    if (typeof url === 'string') {\n      const content = this.host.loadResource(url);\n      if (typeof content === 'string') {\n        return content;\n      }\n    }\n  }\n\n  updateDecoratorMetadata(arg: MetadataObject): MetadataObject {\n    if (arg['templateUrl']) {\n      const template = this.inlineResource(arg['templateUrl']);\n      if (template) {\n        arg['template'] = template;\n        delete arg.templateUrl;\n      }\n    }\n    if (arg['styleUrls']) {\n      const styleUrls = arg['styleUrls'];\n      if (Array.isArray(styleUrls)) {\n        let allStylesInlined = true;\n        const newStyles = styleUrls.map(styleUrl => {\n          const style = this.inlineResource(styleUrl);\n          if (style) return style;\n          allStylesInlined = false;\n          return styleUrl;\n        });\n        if (allStylesInlined) {\n          arg['styles'] = newStyles;\n          delete arg.styleUrls;\n        }\n      }\n    }\n\n    return arg;\n  }\n}\n\nexport function getInlineResourcesTransformFactory(\n    program: ts.Program, host: ResourceLoader): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => {\n    const visitor: ts.Visitor = node => {\n      // Components are always classes; skip any other node\n      if (!ts.isClassDeclaration(node)) {\n        return node;\n      }\n\n      // Decorator case - before or without decorator downleveling\n      // @Component()\n      const newDecorators = ts.visitNodes(node.decorators, (node: ts.Decorator) => {\n        if (isComponentDecorator(node, program.getTypeChecker())) {\n          return updateDecorator(node, host);\n        }\n        return node;\n      });\n\n      // Annotation case - after decorator downleveling\n      // static decorators: {type: Function, args?: any[]}[]\n      const newMembers = ts.visitNodes(\n          node.members,\n          (node: ts.ClassElement) => updateAnnotations(node, host, program.getTypeChecker()));\n\n      // Create a new AST subtree with our modifications\n      return ts.updateClassDeclaration(\n          node, newDecorators, node.modifiers, node.name, node.typeParameters,\n          node.heritageClauses || [], newMembers);\n    };\n\n    return ts.visitEachChild(sourceFile, visitor, context);\n  };\n}\n\n/**\n * Update a Decorator AST node to inline the resources\n * @param node the @Component decorator\n * @param host provides access to load resources\n */\nfunction updateDecorator(node: ts.Decorator, host: ResourceLoader): ts.Decorator {\n  if (!ts.isCallExpression(node.expression)) {\n    // User will get an error somewhere else with bare @Component\n    return node;\n  }\n  const expr = node.expression;\n  const newArguments = updateComponentProperties(expr.arguments, host);\n  return ts.updateDecorator(\n      node, ts.updateCall(expr, expr.expression, expr.typeArguments, newArguments));\n}\n\n/**\n * Update an Annotations AST node to inline the resources\n * @param node the static decorators property\n * @param host provides access to load resources\n * @param typeChecker provides access to symbol table\n */\nfunction updateAnnotations(\n    node: ts.ClassElement, host: ResourceLoader, typeChecker: ts.TypeChecker): ts.ClassElement {\n  // Looking for a member of this shape:\n  // PropertyDeclaration called decorators, with static modifier\n  // Initializer is ArrayLiteralExpression\n  // One element is the Component type, its initializer is the @angular/core Component symbol\n  // One element is the component args, its initializer is the Component arguments to change\n  // e.g.\n  //   static decorators: {type: Function, args?: any[]}[] =\n  //   [{\n  //     type: Component,\n  //     args: [{\n  //       templateUrl: './my.component.html',\n  //       styleUrls: ['./my.component.css'],\n  //     }],\n  //   }];\n  if (!ts.isPropertyDeclaration(node) ||  // ts.ModifierFlags.Static &&\n      !ts.isIdentifier(node.name) || node.name.text !== 'decorators' || !node.initializer ||\n      !ts.isArrayLiteralExpression(node.initializer)) {\n    return node;\n  }\n\n  const newAnnotations = node.initializer.elements.map(annotation => {\n    // No-op if there's a non-object-literal mixed in the decorators values\n    if (!ts.isObjectLiteralExpression(annotation)) return annotation;\n\n    const decoratorType = annotation.properties.find(p => isIdentifierNamed(p, 'type'));\n\n    // No-op if there's no 'type' property, or if it's not initialized to the Component symbol\n    if (!decoratorType || !ts.isPropertyAssignment(decoratorType) ||\n        !ts.isIdentifier(decoratorType.initializer) ||\n        !isComponentSymbol(decoratorType.initializer, typeChecker)) {\n      return annotation;\n    }\n\n    const newAnnotation = annotation.properties.map(prop => {\n      // No-op if this isn't the 'args' property or if it's not initialized to an array\n      if (!isIdentifierNamed(prop, 'args') || !ts.isPropertyAssignment(prop) ||\n          !ts.isArrayLiteralExpression(prop.initializer))\n        return prop;\n\n      const newDecoratorArgs = ts.updatePropertyAssignment(\n          prop, prop.name,\n          ts.createArrayLiteral(updateComponentProperties(prop.initializer.elements, host)));\n\n      return newDecoratorArgs;\n    });\n\n    return ts.updateObjectLiteral(annotation, newAnnotation);\n  });\n\n  return ts.updateProperty(\n      node, node.decorators, node.modifiers, node.name, node.questionToken, node.type,\n      ts.updateArrayLiteral(node.initializer, newAnnotations));\n}\n\nfunction isIdentifierNamed(p: ts.ObjectLiteralElementLike, name: string): boolean {\n  return !!p.name && ts.isIdentifier(p.name) && p.name.text === name;\n}\n\n/**\n * Check that the node we are visiting is the actual Component decorator defined in @angular/core.\n */\nfunction isComponentDecorator(node: ts.Decorator, typeChecker: ts.TypeChecker): boolean {\n  if (!ts.isCallExpression(node.expression)) {\n    return false;\n  }\n  const callExpr = node.expression;\n\n  let identifier: ts.Node;\n\n  if (ts.isIdentifier(callExpr.expression)) {\n    identifier = callExpr.expression;\n  } else {\n    return false;\n  }\n  return isComponentSymbol(identifier, typeChecker);\n}\n\nfunction isComponentSymbol(identifier: ts.Node, typeChecker: ts.TypeChecker) {\n  // Only handle identifiers, not expressions\n  if (!ts.isIdentifier(identifier)) return false;\n\n  // NOTE: resolver.getReferencedImportDeclaration would work as well but is internal\n  const symbol = typeChecker.getSymbolAtLocation(identifier);\n\n  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n    console.error(\n        `Unable to resolve symbol '${identifier.text}' in the program, does it type-check?`);\n    return false;\n  }\n\n  const declaration = symbol.declarations[0];\n\n  if (!declaration || !ts.isImportSpecifier(declaration)) {\n    return false;\n  }\n\n  const name = (declaration.propertyName || declaration.name).text;\n  // We know that parent pointers are set because we created the SourceFile ourselves.\n  // The number of parent references here match the recursion depth at this point.\n  const moduleId =\n      (declaration.parent !.parent !.parent !.moduleSpecifier as ts.StringLiteral).text;\n  return moduleId === '@angular/core' && name === 'Component';\n}\n\n/**\n * For each property in the object literal, if it's templateUrl or styleUrls, replace it\n * with content.\n * @param node the arguments to @Component() or args property of decorators: [{type:Component}]\n * @param host provides access to the loadResource method of the host\n * @returns updated arguments\n */\nfunction updateComponentProperties(\n    args: ts.NodeArray<ts.Expression>, host: ResourceLoader): ts.NodeArray<ts.Expression> {\n  if (args.length !== 1) {\n    // User should have gotten a type-check error because @Component takes one argument\n    return args;\n  }\n  const componentArg = args[0];\n  if (!ts.isObjectLiteralExpression(componentArg)) {\n    // User should have gotten a type-check error because @Component takes an object literal\n    // argument\n    return args;\n  }\n  const newArgument = ts.updateObjectLiteral(\n      componentArg, ts.visitNodes(componentArg.properties, (node: ts.ObjectLiteralElementLike) => {\n        if (!ts.isPropertyAssignment(node)) {\n          // Error: unsupported\n          return node;\n        }\n\n        if (ts.isComputedPropertyName(node.name)) {\n          // computed names are not supported\n          return node;\n        }\n\n        const name = node.name.text;\n        switch (name) {\n          case 'styleUrls':\n            if (!ts.isArrayLiteralExpression(node.initializer)) {\n              // Error: unsupported\n              return node;\n            }\n            const styleUrls = node.initializer.elements;\n\n            return ts.updatePropertyAssignment(\n                node, ts.createIdentifier('styles'),\n                ts.createArrayLiteral(ts.visitNodes(styleUrls, (expr: ts.Expression) => {\n                  if (ts.isStringLiteral(expr)) {\n                    const styles = host.loadResource(expr.text);\n                    if (typeof styles === 'string') {\n                      return ts.createLiteral(styles);\n                    }\n                  }\n                  return expr;\n                })));\n\n\n          case 'templateUrl':\n            if (ts.isStringLiteral(node.initializer)) {\n              const template = host.loadResource(node.initializer.text);\n              if (typeof template === 'string') {\n                return ts.updatePropertyAssignment(\n                    node, ts.createIdentifier('template'), ts.createLiteral(template));\n              }\n            }\n            return node;\n\n          default:\n            return node;\n        }\n      }));\n  return ts.createNodeArray<ts.Expression>([newArgument]);\n}\n"]}