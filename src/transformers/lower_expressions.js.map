{"version":3,"file":"lower_expressions.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/lower_expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CollectorOptions, MetadataCollector, MetadataValue, ModuleMetadata, isMetadataGlobalReferenceExpression} from '@angular/tsc-wrapped';\nimport * as ts from 'typescript';\n\nexport interface LoweringRequest {\n  kind: ts.SyntaxKind;\n  location: number;\n  end: number;\n  name: string;\n}\n\nexport type RequestLocationMap = Map<number, LoweringRequest>;\n\ninterface Declaration {\n  name: string;\n  node: ts.Node;\n}\n\ninterface DeclarationInsert {\n  declarations: Declaration[];\n  priorTo: ts.Node;\n}\n\nfunction toMap<T, K>(items: T[], select: (item: T) => K): Map<K, T> {\n  return new Map(items.map<[K, T]>(i => [select(i), i]));\n}\n\n// We will never lower expressions in a nested lexical scope so avoid entering them.\n// This also avoids a bug in TypeScript 2.3 where the lexical scopes get out of sync\n// when using visitEachChild.\nfunction isLexicalScope(node: ts.Node): boolean {\n  switch (node.kind) {\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.TypeLiteral:\n    case ts.SyntaxKind.ArrayType:\n      return true;\n  }\n  return false;\n}\n\nfunction transformSourceFile(\n    sourceFile: ts.SourceFile, requests: RequestLocationMap,\n    context: ts.TransformationContext): ts.SourceFile {\n  const inserts: DeclarationInsert[] = [];\n\n  // Calculate the range of interesting locations. The transform will only visit nodes in this\n  // range to improve the performance on large files.\n  const locations = Array.from(requests.keys());\n  const min = Math.min(...locations);\n  const max = Math.max(...locations);\n\n  // Visit nodes matching the request and synthetic nodes added by tsickle\n  function shouldVisit(pos: number, end: number): boolean {\n    return (pos <= max && end >= min) || pos == -1;\n  }\n\n  function visitSourceFile(sourceFile: ts.SourceFile): ts.SourceFile {\n    function topLevelStatement(node: ts.Node): ts.Node {\n      const declarations: Declaration[] = [];\n\n      function visitNode(node: ts.Node): ts.Node {\n        // Get the original node before tsickle\n        const {pos, end, kind} = ts.getOriginalNode(node);\n        const nodeRequest = requests.get(pos);\n        if (nodeRequest && nodeRequest.kind == kind && nodeRequest.end == end) {\n          // This node is requested to be rewritten as a reference to the exported name.\n          // Record that the node needs to be moved to an exported variable with the given name\n          const name = nodeRequest.name;\n          declarations.push({name, node});\n          return ts.createIdentifier(name);\n        }\n        let result = node;\n\n        if (shouldVisit(pos, end) && !isLexicalScope(node)) {\n          result = ts.visitEachChild(node, visitNode, context);\n        }\n        return result;\n      }\n\n      // Get the original node before tsickle\n      const {pos, end} = ts.getOriginalNode(node);\n      const result = shouldVisit(pos, end) ? ts.visitEachChild(node, visitNode, context) : node;\n\n      if (declarations.length) {\n        inserts.push({priorTo: result, declarations});\n      }\n      return result;\n    }\n\n    const traversedSource = ts.visitEachChild(sourceFile, topLevelStatement, context);\n\n    if (inserts.length) {\n      // Insert the declarations before the rewritten statement that references them.\n      const insertMap = toMap(inserts, i => i.priorTo);\n      const newStatements: ts.Statement[] = [...traversedSource.statements];\n      for (let i = newStatements.length; i >= 0; i--) {\n        const statement = newStatements[i];\n        const insert = insertMap.get(statement);\n        if (insert) {\n          const declarations = insert.declarations.map(\n              i => ts.createVariableDeclaration(\n                  i.name, /* type */ undefined, i.node as ts.Expression));\n          const statement = ts.createVariableStatement(\n              /* modifiers */ undefined,\n              ts.createVariableDeclarationList(declarations, ts.NodeFlags.Const));\n          newStatements.splice(i, 0, statement);\n        }\n      }\n\n      // Insert an exports clause to export the declarations\n      newStatements.push(ts.createExportDeclaration(\n          /* decorators */ undefined,\n          /* modifiers */ undefined,\n          ts.createNamedExports(\n              inserts\n                  .reduce(\n                      (accumulator, insert) => [...accumulator, ...insert.declarations],\n                      [] as Declaration[])\n                  .map(\n                      declaration => ts.createExportSpecifier(\n                          /* propertyName */ undefined, declaration.name)))));\n      return ts.updateSourceFileNode(traversedSource, newStatements);\n    }\n    return traversedSource;\n  }\n\n  return visitSourceFile(sourceFile);\n}\n\nexport function getExpressionLoweringTransformFactory(requestsMap: RequestsMap):\n    (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => ts.SourceFile {\n  // Return the factory\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile): ts.SourceFile => {\n    const requests = requestsMap.getRequests(sourceFile);\n    if (requests && requests.size) {\n      return transformSourceFile(sourceFile, requests, context);\n    }\n    return sourceFile;\n  };\n}\n\nexport interface RequestsMap { getRequests(sourceFile: ts.SourceFile): RequestLocationMap; }\n\ninterface MetadataAndLoweringRequests {\n  metadata: ModuleMetadata|undefined;\n  requests: RequestLocationMap;\n}\n\nfunction shouldLower(node: ts.Node | undefined): boolean {\n  if (node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n      case ts.SyntaxKind.Decorator:\n        // Lower expressions that are local to the module scope or\n        // in a decorator.\n        return true;\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n        // Don't lower expressions in a declaration.\n        return false;\n      case ts.SyntaxKind.VariableDeclaration:\n        // Avoid lowering expressions already in an exported variable declaration\n        return (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) == 0;\n    }\n    return shouldLower(node.parent);\n  }\n  return true;\n}\n\nconst REWRITE_PREFIX = '\\u0275';\n\nfunction isPrimitive(value: any): boolean {\n  return Object(value) !== value;\n}\n\nfunction isRewritten(value: any): boolean {\n  return isMetadataGlobalReferenceExpression(value) && value.name.startsWith(REWRITE_PREFIX);\n}\n\nfunction isLiteralFieldNamed(node: ts.Node, names: Set<string>): boolean {\n  if (node.parent && node.parent.kind == ts.SyntaxKind.PropertyAssignment) {\n    const property = node.parent as ts.PropertyAssignment;\n    if (property.parent && property.parent.kind == ts.SyntaxKind.ObjectLiteralExpression &&\n        property.name && property.name.kind == ts.SyntaxKind.Identifier) {\n      const propertyName = property.name as ts.Identifier;\n      return names.has(propertyName.text);\n    }\n  }\n  return false;\n}\n\nconst LOWERABLE_FIELD_NAMES = new Set(['useValue', 'useFactory', 'data']);\n\nexport class LowerMetadataCache implements RequestsMap {\n  private collector: MetadataCollector;\n  private metadataCache = new Map<string, MetadataAndLoweringRequests>();\n\n  constructor(options: CollectorOptions, private strict?: boolean) {\n    this.collector = new MetadataCollector(options);\n  }\n\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n    return this.ensureMetadataAndRequests(sourceFile).metadata;\n  }\n\n  getRequests(sourceFile: ts.SourceFile): RequestLocationMap {\n    return this.ensureMetadataAndRequests(sourceFile).requests;\n  }\n\n  private ensureMetadataAndRequests(sourceFile: ts.SourceFile): MetadataAndLoweringRequests {\n    let result = this.metadataCache.get(sourceFile.fileName);\n    if (!result) {\n      result = this.getMetadataAndRequests(sourceFile);\n      this.metadataCache.set(sourceFile.fileName, result);\n    }\n    return result;\n  }\n\n  private getMetadataAndRequests(sourceFile: ts.SourceFile): MetadataAndLoweringRequests {\n    let identNumber = 0;\n    const freshIdent = () => REWRITE_PREFIX + identNumber++;\n    const requests = new Map<number, LoweringRequest>();\n\n    const isExportedSymbol = (() => {\n      let exportTable: Set<string>;\n      return (node: ts.Node) => {\n        if (node.kind == ts.SyntaxKind.Identifier) {\n          const ident = node as ts.Identifier;\n\n          if (!exportTable) {\n            exportTable = createExportTableFor(sourceFile);\n          }\n          return exportTable.has(ident.text);\n        }\n        return false;\n      };\n    })();\n\n    const replaceNode = (node: ts.Node) => {\n      const name = freshIdent();\n      requests.set(node.pos, {name, kind: node.kind, location: node.pos, end: node.end});\n      return {__symbolic: 'reference', name};\n    };\n\n    const substituteExpression = (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (!isPrimitive(value) && !isRewritten(value)) {\n        if ((node.kind === ts.SyntaxKind.ArrowFunction ||\n             node.kind === ts.SyntaxKind.FunctionExpression) &&\n            shouldLower(node)) {\n          return replaceNode(node);\n        }\n        if (isLiteralFieldNamed(node, LOWERABLE_FIELD_NAMES) && shouldLower(node) &&\n            !isExportedSymbol(node)) {\n          return replaceNode(node);\n        }\n      }\n      return value;\n    };\n\n    const metadata = this.collector.getMetadata(sourceFile, this.strict, substituteExpression);\n\n    return {metadata, requests};\n  }\n}\n\nfunction createExportTableFor(sourceFile: ts.SourceFile): Set<string> {\n  const exportTable = new Set<string>();\n  // Lazily collect all the exports from the source file\n  ts.forEachChild(sourceFile, function scan(node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        if ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) != 0) {\n          const classDeclaration =\n              node as(ts.ClassDeclaration | ts.FunctionDeclaration | ts.InterfaceDeclaration);\n          const name = classDeclaration.name;\n          if (name) exportTable.add(name.text);\n        }\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        const variableStatement = node as ts.VariableStatement;\n        for (const declaration of variableStatement.declarationList.declarations) {\n          scan(declaration);\n        }\n        break;\n      case ts.SyntaxKind.VariableDeclaration:\n        const variableDeclaration = node as ts.VariableDeclaration;\n        if ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) != 0 &&\n            variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n          const name = variableDeclaration.name as ts.Identifier;\n          exportTable.add(name.text);\n        }\n        break;\n      case ts.SyntaxKind.ExportDeclaration:\n        const exportDeclaration = node as ts.ExportDeclaration;\n        const {moduleSpecifier, exportClause} = exportDeclaration;\n        if (!moduleSpecifier && exportClause) {\n          exportClause.elements.forEach(spec => { exportTable.add(spec.name.text); });\n        }\n    }\n  });\n  return exportTable;\n}\n"]}