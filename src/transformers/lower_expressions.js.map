{"version":3,"file":"lower_expressions.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/lower_expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CollectorOptions, MetadataCollector, MetadataValue, ModuleMetadata} from '@angular/tsc-wrapped';\nimport * as ts from 'typescript';\n\nexport interface LoweringRequest {\n  kind: ts.SyntaxKind;\n  location: number;\n  end: number;\n  name: string;\n}\n\nexport type RequestLocationMap = Map<number, LoweringRequest>;\n\ninterface Declaration {\n  name: string;\n  node: ts.Node;\n}\n\ninterface DeclarationInsert {\n  declarations: Declaration[];\n  priorTo: ts.Node;\n}\n\nfunction toMap<T, K>(items: T[], select: (item: T) => K): Map<K, T> {\n  return new Map(items.map<[K, T]>(i => [select(i), i]));\n}\n\n// We will never lower expressions in a nested lexical scope so avoid entering them.\n// This also avoids a bug in TypeScript 2.3 where the lexical scopes get out of sync\n// when using visitEachChild.\nfunction isLexicalScope(node: ts.Node): boolean {\n  switch (node.kind) {\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.TypeLiteral:\n    case ts.SyntaxKind.ArrayType:\n      return true;\n  }\n  return false;\n}\n\nfunction transformSourceFile(\n    sourceFile: ts.SourceFile, requests: RequestLocationMap,\n    context: ts.TransformationContext): ts.SourceFile {\n  const inserts: DeclarationInsert[] = [];\n\n  // Calculate the range of interesting locations. The transform will only visit nodes in this\n  // range to improve the performance on large files.\n  const locations = Array.from(requests.keys());\n  const min = Math.min(...locations);\n  const max = Math.max(...locations);\n\n  // Visit nodes matching the request and synthetic nodes added by tsickle\n  function shouldVisit(pos: number, end: number): boolean {\n    return (pos <= max && end >= min) || pos == -1;\n  }\n\n  function visitSourceFile(sourceFile: ts.SourceFile): ts.SourceFile {\n    function topLevelStatement(node: ts.Node): ts.Node {\n      const declarations: Declaration[] = [];\n\n      function visitNode(node: ts.Node): ts.Node {\n        // Get the original node before tsickle\n        const {pos, end, kind} = ts.getOriginalNode(node);\n        const nodeRequest = requests.get(pos);\n        if (nodeRequest && nodeRequest.kind == kind && nodeRequest.end == end) {\n          // This node is requested to be rewritten as a reference to the exported name.\n          // Record that the node needs to be moved to an exported variable with the given name\n          const name = nodeRequest.name;\n          declarations.push({name, node});\n          return ts.createIdentifier(name);\n        }\n        let result = node;\n\n        if (shouldVisit(pos, end) && !isLexicalScope(node)) {\n          result = ts.visitEachChild(node, visitNode, context);\n        }\n        return result;\n      }\n\n      // Get the original node before tsickle\n      const {pos, end} = ts.getOriginalNode(node);\n      const result = shouldVisit(pos, end) ? ts.visitEachChild(node, visitNode, context) : node;\n\n      if (declarations.length) {\n        inserts.push({priorTo: result, declarations});\n      }\n      return result;\n    }\n\n    const traversedSource = ts.visitEachChild(sourceFile, topLevelStatement, context);\n\n    if (inserts.length) {\n      // Insert the declarations before the rewritten statement that references them.\n      const insertMap = toMap(inserts, i => i.priorTo);\n      const newStatements: ts.Statement[] = [...traversedSource.statements];\n      for (let i = newStatements.length; i >= 0; i--) {\n        const statement = newStatements[i];\n        const insert = insertMap.get(statement);\n        if (insert) {\n          const declarations = insert.declarations.map(\n              i => ts.createVariableDeclaration(\n                  i.name, /* type */ undefined, i.node as ts.Expression));\n          const statement = ts.createVariableStatement(\n              /* modifiers */ undefined,\n              ts.createVariableDeclarationList(declarations, ts.NodeFlags.Const));\n          newStatements.splice(i, 0, statement);\n        }\n      }\n\n      // Insert an exports clause to export the declarations\n      newStatements.push(ts.createExportDeclaration(\n          /* decorators */ undefined,\n          /* modifiers */ undefined,\n          ts.createNamedExports(\n              inserts\n                  .reduce(\n                      (accumulator, insert) => [...accumulator, ...insert.declarations],\n                      [] as Declaration[])\n                  .map(\n                      declaration => ts.createExportSpecifier(\n                          /* propertyName */ undefined, declaration.name)))));\n      return ts.updateSourceFileNode(traversedSource, newStatements);\n    }\n    return traversedSource;\n  }\n\n  return visitSourceFile(sourceFile);\n}\n\nexport function getExpressionLoweringTransformFactory(requestsMap: RequestsMap):\n    (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => ts.SourceFile {\n  // Return the factory\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile): ts.SourceFile => {\n    const requests = requestsMap.getRequests(sourceFile);\n    if (requests && requests.size) {\n      return transformSourceFile(sourceFile, requests, context);\n    }\n    return sourceFile;\n  };\n}\n\nexport interface RequestsMap { getRequests(sourceFile: ts.SourceFile): RequestLocationMap; }\n\ninterface MetadataAndLoweringRequests {\n  metadata: ModuleMetadata|undefined;\n  requests: RequestLocationMap;\n}\n\nfunction shouldLower(node: ts.Node | undefined): boolean {\n  if (node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n      case ts.SyntaxKind.Decorator:\n        // Lower expressions that are local to the module scope or\n        // in a decorator.\n        return true;\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n        // Don't lower expressions in a declaration.\n        return false;\n      case ts.SyntaxKind.VariableDeclaration:\n        // Avoid lowering expressions already in an exported variable declaration\n        return (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) == 0;\n    }\n    return shouldLower(node.parent);\n  }\n  return true;\n}\n\nexport class LowerMetadataCache implements RequestsMap {\n  private collector: MetadataCollector;\n  private metadataCache = new Map<string, MetadataAndLoweringRequests>();\n\n  constructor(options: CollectorOptions, private strict?: boolean) {\n    this.collector = new MetadataCollector(options);\n  }\n\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n    return this.ensureMetadataAndRequests(sourceFile).metadata;\n  }\n\n  getRequests(sourceFile: ts.SourceFile): RequestLocationMap {\n    return this.ensureMetadataAndRequests(sourceFile).requests;\n  }\n\n  private ensureMetadataAndRequests(sourceFile: ts.SourceFile): MetadataAndLoweringRequests {\n    let result = this.metadataCache.get(sourceFile.fileName);\n    if (!result) {\n      result = this.getMetadataAndRequests(sourceFile);\n      this.metadataCache.set(sourceFile.fileName, result);\n    }\n    return result;\n  }\n\n  private getMetadataAndRequests(sourceFile: ts.SourceFile): MetadataAndLoweringRequests {\n    let identNumber = 0;\n    const freshIdent = () => '\\u0275' + identNumber++;\n    const requests = new Map<number, LoweringRequest>();\n    const replaceNode = (node: ts.Node) => {\n      const name = freshIdent();\n      requests.set(node.pos, {name, kind: node.kind, location: node.pos, end: node.end});\n      return {__symbolic: 'reference', name};\n    };\n\n    const substituteExpression = (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if ((node.kind === ts.SyntaxKind.ArrowFunction ||\n           node.kind === ts.SyntaxKind.FunctionExpression) &&\n          shouldLower(node)) {\n        return replaceNode(node);\n      }\n      return value;\n    };\n\n    const metadata = this.collector.getMetadata(sourceFile, this.strict, substituteExpression);\n\n    return {metadata, requests};\n  }\n}"]}