{"version":3,"file":"metadata_cache.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/metadata_cache.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,+BAAiC;AAajC;;GAEG;AACH;IAGE,uBACY,SAA4B,EAAU,MAAe,EACrD,YAAmC;QADnC,cAAS,GAAT,SAAS,CAAmB;QAAU,WAAM,GAAN,MAAM,CAAS;QACrD,iBAAY,GAAZ,YAAY,CAAuB;QAJvC,kBAAa,GAAG,IAAI,GAAG,EAAoC,CAAC;QAKlE,GAAG,CAAC,CAAoB,UAAY,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY;YAA/B,IAAI,WAAW,qBAAA;YAClB,EAAE,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;gBACxB,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC5B,CAAC;SACF;IACH,CAAC;IAED,mCAAW,GAAX,UAAY,UAAyB;QACnC,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAChD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QACrD,CAAC;QACD,IAAI,UAAU,GAA6B,SAAS,CAAC;QAErD,uEAAuE;QACvE,IAAM,eAAe,GAAG,UAAU,CAAC,iBAAiB,CAAC;QACrD,IAAM,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QACnD,EAAE,CAAC,CAAC,CAAC,eAAe,IAAI,UAAU,CAAC,CAAC,CAAC;oCAC1B,SAAS;gBAChB,IAAM,mBAAmB,GAAG,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;gBACxD,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;oBACxB,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;wBACf,IAAM,UAAQ,GAAmB,UAAU,CAAC;wBAC5C,UAAU,GAAG,UAAC,KAAoB,EAAE,IAAa;4BAC7C,OAAA,mBAAmB,CAAC,UAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC;wBAAhD,CAAgD,CAAC;oBACvD,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,UAAU,GAAG,mBAAmB,CAAC;oBACnC,CAAC;gBACH,CAAC;YACH,CAAC;YAXD,GAAG,CAAC,CAAkB,UAAiB,EAAjB,KAAA,IAAI,CAAC,YAAY,EAAjB,cAAiB,EAAjB,IAAiB;gBAAlC,IAAI,SAAS,SAAA;wBAAT,SAAS;aAWjB;QACH,CAAC;QAED,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAC/E,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QACpD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IACH,oBAAC;AAAD,CAAC,AAzCD,IAyCC;AAzCY,sCAAa","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n\nimport {MetadataProvider} from './compiler_host';\n\nexport type ValueTransform = (value: MetadataValue, node: ts.Node) => MetadataValue;\n\nexport interface MetadataTransformer {\n  connect?(cache: MetadataCache): void;\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined;\n}\n\n/**\n * Cache, and potentially transform, metadata as it is being collected.\n */\nexport class MetadataCache implements MetadataProvider {\n  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n\n  constructor(\n      private collector: MetadataCollector, private strict: boolean,\n      private transformers: MetadataTransformer[]) {\n    for (let transformer of transformers) {\n      if (transformer.connect) {\n        transformer.connect(this);\n      }\n    }\n  }\n\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n    if (this.metadataCache.has(sourceFile.fileName)) {\n      return this.metadataCache.get(sourceFile.fileName);\n    }\n    let substitute: ValueTransform|undefined = undefined;\n\n    // Only process transformers on modules that are not declaration files.\n    const declarationFile = sourceFile.isDeclarationFile;\n    const moduleFile = ts.isExternalModule(sourceFile);\n    if (!declarationFile && moduleFile) {\n      for (let transform of this.transformers) {\n        const transformSubstitute = transform.start(sourceFile);\n        if (transformSubstitute) {\n          if (substitute) {\n            const previous: ValueTransform = substitute;\n            substitute = (value: MetadataValue, node: ts.Node) =>\n                transformSubstitute(previous(value, node), node);\n          } else {\n            substitute = transformSubstitute;\n          }\n        }\n      }\n    }\n\n    const result = this.collector.getMetadata(sourceFile, this.strict, substitute);\n    this.metadataCache.set(sourceFile.fileName, result);\n    return result;\n  }\n}"]}