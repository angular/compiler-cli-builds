{"version":3,"file":"metadata_cache.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/metadata_cache.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,iCAAiC;AAajC;;GAEG;AACH;IAGE,YACY,SAA4B,EAAU,MAAe,EACrD,YAAmC;QADnC,cAAS,GAAT,SAAS,CAAmB;QAAU,WAAM,GAAN,MAAM,CAAS;QACrD,iBAAY,GAAZ,YAAY,CAAuB;QAJvC,kBAAa,GAAG,IAAI,GAAG,EAAoC,CAAC;QAKlE,GAAG,CAAC,CAAC,IAAI,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;gBACxB,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC5B,CAAC;QACH,CAAC;IACH,CAAC;IAED,WAAW,CAAC,UAAyB;QACnC,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAChD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QACrD,CAAC;QACD,IAAI,UAAU,GAA6B,SAAS,CAAC;QAErD,uEAAuE;QACvE,MAAM,eAAe,GAAG,UAAU,CAAC,iBAAiB,CAAC;QACrD,MAAM,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;QACnD,EAAE,CAAC,CAAC,CAAC,eAAe,IAAI,UAAU,CAAC,CAAC,CAAC;YACnC,GAAG,CAAC,CAAC,IAAI,SAAS,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;gBACxC,MAAM,mBAAmB,GAAG,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;gBACxD,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;oBACxB,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;wBACf,MAAM,QAAQ,GAAmB,UAAU,CAAC;wBAC5C,UAAU,GAAG,CAAC,KAAoB,EAAE,IAAa,EAAE,EAAE,CACjD,mBAAmB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;oBACvD,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,UAAU,GAAG,mBAAmB,CAAC;oBACnC,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAC/E,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QACpD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;CACF;AAzCD,sCAyCC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n\nimport {MetadataProvider} from './compiler_host';\n\nexport type ValueTransform = (value: MetadataValue, node: ts.Node) => MetadataValue;\n\nexport interface MetadataTransformer {\n  connect?(cache: MetadataCache): void;\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined;\n}\n\n/**\n * Cache, and potentially transform, metadata as it is being collected.\n */\nexport class MetadataCache implements MetadataProvider {\n  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n\n  constructor(\n      private collector: MetadataCollector, private strict: boolean,\n      private transformers: MetadataTransformer[]) {\n    for (let transformer of transformers) {\n      if (transformer.connect) {\n        transformer.connect(this);\n      }\n    }\n  }\n\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n    if (this.metadataCache.has(sourceFile.fileName)) {\n      return this.metadataCache.get(sourceFile.fileName);\n    }\n    let substitute: ValueTransform|undefined = undefined;\n\n    // Only process transformers on modules that are not declaration files.\n    const declarationFile = sourceFile.isDeclarationFile;\n    const moduleFile = ts.isExternalModule(sourceFile);\n    if (!declarationFile && moduleFile) {\n      for (let transform of this.transformers) {\n        const transformSubstitute = transform.start(sourceFile);\n        if (transformSubstitute) {\n          if (substitute) {\n            const previous: ValueTransform = substitute;\n            substitute = (value: MetadataValue, node: ts.Node) =>\n                transformSubstitute(previous(value, node), node);\n          } else {\n            substitute = transformSubstitute;\n          }\n        }\n      }\n    }\n\n    const result = this.collector.getMetadata(sourceFile, this.strict, substitute);\n    this.metadataCache.set(sourceFile.fileName, result);\n    return result;\n  }\n}"]}