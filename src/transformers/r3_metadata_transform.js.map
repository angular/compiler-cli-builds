{"version":3,"file":"r3_metadata_transform.js","sourceRoot":"","sources":["../../../../../packages/compiler-cli/src/transformers/r3_metadata_transform.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;;;;;;;;AAEH,8CAAoF;AACpF,+BAAiC;AAEjC,2CAAoG;AAIpG;IAGE,0CAAY,OAAwB;QAClC,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAA0B,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAf,CAAe,CAAC,CAAC,CAAC;IACvF,CAAC;IAED,gDAAK,GAAL,UAAM,UAAyB;QAC7B,IAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;QAC9D,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAClB,IAAM,UAAQ,GAAG,IAAI,GAAG,CACpB,aAAa,CAAC,UAAU,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,GAAG,CAAsB,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,EAAX,CAAW,CAAC,CAAC,CAAC;YAC7F,EAAE,CAAC,CAAC,UAAQ,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;gBACtB,MAAM,CAAC,UAAC,KAAoB,EAAE,IAAa;oBACzC,wFAAwF;oBACxF,gEAAgE;oBAChE,EAAE,CAAC,CAAC,uBAAe,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC;wBAC3E,IAAM,gBAAgB,GAAG,IAA2B,CAAC;wBACrD,EAAE,CAAC,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;4BAC1B,IAAM,YAAY,GAAG,UAAQ,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;4BAC9D,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gCACjB,GAAG,CAAC,CAAgB,UAAmB,EAAnB,KAAA,YAAY,CAAC,MAAM,EAAnB,cAAmB,EAAnB,IAAmB;oCAAlC,IAAM,KAAK,SAAA;oCACd,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,SAAS;wCAC7B,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,KAAK,uBAAY,CAAC,MAAM,EAAhC,CAAgC,CAAC,CAAC,CAAC,CAAC;wCACvE,KAAK,CAAC,OAAO,gBAAO,CAAC,KAAK,CAAC,OAAO,IAAI,EAAE,CAAC,eAAG,KAAK,CAAC,IAAI,IAAG,EAAE,MAAC,CAAC;oCAC/D,CAAC;iCACF;4BACH,CAAC;wBACH,CAAC;oBACH,CAAC;oBACD,MAAM,CAAC,KAAK,CAAC;;gBACf,CAAC,CAAC;YACJ,CAAC;QACH,CAAC;IACH,CAAC;IACH,uCAAC;AAAD,CAAC,AAnCD,IAmCC;AAnCY,4EAAgC;AAqC7C,qBAAqB,CAAY;IAC/B,MAAM,CAAC,CAAC,YAAY,oBAAS,CAAC;AAChC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassStmt, PartialModule, Statement, StmtModifier} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {MetadataCollector, MetadataValue, ModuleMetadata, isClassMetadata} from '../metadata/index';\n\nimport {MetadataTransformer, ValueTransform} from './metadata_cache';\n\nexport class PartialModuleMetadataTransformer implements MetadataTransformer {\n  private moduleMap: Map<string, PartialModule>;\n\n  constructor(modules: PartialModule[]) {\n    this.moduleMap = new Map(modules.map<[string, PartialModule]>(m => [m.fileName, m]));\n  }\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    const partialModule = this.moduleMap.get(sourceFile.fileName);\n    if (partialModule) {\n      const classMap = new Map<string, ClassStmt>(\n          partialModule.statements.filter(isClassStmt).map<[string, ClassStmt]>(s => [s.name, s]));\n      if (classMap.size > 0) {\n        return (value: MetadataValue, node: ts.Node): MetadataValue => {\n          // For class metadata that is going to be transformed to have a static method ensure the\n          // metadata contains a static declaration the new static method.\n          if (isClassMetadata(value) && node.kind === ts.SyntaxKind.ClassDeclaration) {\n            const classDeclaration = node as ts.ClassDeclaration;\n            if (classDeclaration.name) {\n              const partialClass = classMap.get(classDeclaration.name.text);\n              if (partialClass) {\n                for (const field of partialClass.fields) {\n                  if (field.name && field.modifiers &&\n                      field.modifiers.some(modifier => modifier === StmtModifier.Static)) {\n                    value.statics = {...(value.statics || {}), [field.name]: {}};\n                  }\n                }\n              }\n            }\n          }\n          return value;\n        };\n      }\n    }\n  }\n}\n\nfunction isClassStmt(v: Statement): v is ClassStmt {\n  return v instanceof ClassStmt;\n}\n"]}