/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as ts from 'typescript';
import { TypeScriptNodeEmitter } from './node_emitter';
import { GENERATED_FILES, stripComment } from './util';
function getPreamble(original) {
    return `*
 * @fileoverview This file was generated by the Angular template compiler. Do not edit.
 * ${original}
 * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes,extraRequire}
 * tslint:disable
 `;
}
/**
 * Returns a transformer that does two things for generated files (ngfactory etc):
 * - adds a fileoverview JSDoc comment containing Closure Compiler specific "suppress"ions in JSDoc.
 *   The new comment will contain any fileoverview comment text from the original source file this
 *   file was generated from.
 * - updates generated files that are not in the given map of generatedFiles to have an empty
 *   list of statements as their body.
 */
export function getAngularEmitterTransformFactory(generatedFiles, program, annotateForClosureCompiler) {
    return function () {
        const emitter = new TypeScriptNodeEmitter(annotateForClosureCompiler);
        return function (sourceFile) {
            const g = generatedFiles.get(sourceFile.fileName);
            const orig = g && program.getSourceFile(g.srcFileUrl);
            let originalComment = '';
            if (orig)
                originalComment = getFileoverviewComment(orig);
            const preamble = getPreamble(originalComment);
            if (g && g.stmts) {
                const [newSourceFile] = emitter.updateSourceFile(sourceFile, g.stmts, preamble);
                return newSourceFile;
            }
            else if (GENERATED_FILES.test(sourceFile.fileName)) {
                // The file should be empty, but emitter.updateSourceFile would still add imports
                // and various minutiae.
                // Clear out the source file entirely, only including the preamble comment, so that
                // ngc produces an empty .js file.
                const commentStmt = ts.createNotEmittedStatement(sourceFile);
                ts.addSyntheticLeadingComment(commentStmt, ts.SyntaxKind.MultiLineCommentTrivia, preamble, 
                /* hasTrailingNewline */ true);
                return ts.updateSourceFileNode(sourceFile, [commentStmt]);
            }
            return sourceFile;
        };
    };
}
/**
 * Parses and returns the comment text (without start and end markers) of a \@fileoverview comment
 * in the given source file. Returns the empty string if no such comment can be found.
 */
function getFileoverviewComment(sourceFile) {
    const trivia = sourceFile.getFullText().substring(0, sourceFile.getStart());
    const leadingComments = ts.getLeadingCommentRanges(trivia, 0);
    if (!leadingComments || leadingComments.length === 0)
        return '';
    const comment = leadingComments[0];
    if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia)
        return '';
    // Only comments separated with a \n\n from the file contents are considered file-level comments
    // in TypeScript.
    if (sourceFile.getFullText().substring(comment.end, comment.end + 2) !== '\n\n')
        return '';
    const commentText = sourceFile.getFullText().substring(comment.pos, comment.end);
    // Closure Compiler ignores @suppress and similar if the comment contains @license.
    if (commentText.indexOf('@license') !== -1)
        return '';
    // Also remove any leading `* ` from the first line in case it was a JSDOC comment
    return stripComment(commentText).replace(/^\*\s+/, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9lbWl0dGVyX3RyYW5zZm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvdHJhbnNmb3JtZXJzL25vZGVfZW1pdHRlcl90cmFuc2Zvcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBR0gsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFakMsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDckQsT0FBTyxFQUFDLGVBQWUsRUFBRSxZQUFZLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFckQsU0FBUyxXQUFXLENBQUMsUUFBZ0I7SUFDbkMsT0FBTzs7S0FFSixRQUFROzs7RUFHWCxDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsaUNBQWlDLENBQzdDLGNBQTBDLEVBQUUsT0FBbUIsRUFDL0QsMEJBQW1DO0lBQ3JDLE9BQU87UUFDTCxNQUFNLE9BQU8sR0FBRyxJQUFJLHFCQUFxQixDQUFDLDBCQUEwQixDQUFDLENBQUM7UUFDdEUsT0FBTyxVQUFTLFVBQXlCO1lBQ3ZDLE1BQU0sQ0FBQyxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2xELE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0RCxJQUFJLGVBQWUsR0FBRyxFQUFFLENBQUM7WUFDekIsSUFBSSxJQUFJO2dCQUFFLGVBQWUsR0FBRyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN6RCxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRTtnQkFDaEIsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDaEYsT0FBTyxhQUFhLENBQUM7YUFDdEI7aUJBQU0sSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDcEQsaUZBQWlGO2dCQUNqRix3QkFBd0I7Z0JBQ3hCLG1GQUFtRjtnQkFDbkYsa0NBQWtDO2dCQUNsQyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzdELEVBQUUsQ0FBQywwQkFBMEIsQ0FDekIsV0FBVyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsUUFBUTtnQkFDM0Qsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ25DLE9BQU8sRUFBRSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7YUFDM0Q7WUFDRCxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyxzQkFBc0IsQ0FBQyxVQUF5QjtJQUN2RCxNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUM1RSxNQUFNLGVBQWUsR0FBRyxFQUFFLENBQUMsdUJBQXVCLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzlELElBQUksQ0FBQyxlQUFlLElBQUksZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDO1FBQUUsT0FBTyxFQUFFLENBQUM7SUFDaEUsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLHNCQUFzQjtRQUFFLE9BQU8sRUFBRSxDQUFDO0lBQ3JFLGdHQUFnRztJQUNoRyxpQkFBaUI7SUFDakIsSUFBSSxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBSyxNQUFNO1FBQUUsT0FBTyxFQUFFLENBQUM7SUFDM0YsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqRixtRkFBbUY7SUFDbkYsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUFFLE9BQU8sRUFBRSxDQUFDO0lBQ3RELGtGQUFrRjtJQUNsRixPQUFPLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3pELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtHZW5lcmF0ZWRGaWxlfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtUeXBlU2NyaXB0Tm9kZUVtaXR0ZXJ9IGZyb20gJy4vbm9kZV9lbWl0dGVyJztcbmltcG9ydCB7R0VORVJBVEVEX0ZJTEVTLCBzdHJpcENvbW1lbnR9IGZyb20gJy4vdXRpbCc7XG5cbmZ1bmN0aW9uIGdldFByZWFtYmxlKG9yaWdpbmFsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGAqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSBBbmd1bGFyIHRlbXBsYXRlIGNvbXBpbGVyLiBEbyBub3QgZWRpdC5cbiAqICR7b3JpZ2luYWx9XG4gKiBAc3VwcHJlc3Mge3N1c3BpY2lvdXNDb2RlLHVzZWxlc3NDb2RlLG1pc3NpbmdQcm9wZXJ0aWVzLG1pc3NpbmdPdmVycmlkZSxjaGVja1R5cGVzLGV4dHJhUmVxdWlyZX1cbiAqIHRzbGludDpkaXNhYmxlXG4gYDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHJhbnNmb3JtZXIgdGhhdCBkb2VzIHR3byB0aGluZ3MgZm9yIGdlbmVyYXRlZCBmaWxlcyAobmdmYWN0b3J5IGV0Yyk6XG4gKiAtIGFkZHMgYSBmaWxlb3ZlcnZpZXcgSlNEb2MgY29tbWVudCBjb250YWluaW5nIENsb3N1cmUgQ29tcGlsZXIgc3BlY2lmaWMgXCJzdXBwcmVzc1wiaW9ucyBpbiBKU0RvYy5cbiAqICAgVGhlIG5ldyBjb21tZW50IHdpbGwgY29udGFpbiBhbnkgZmlsZW92ZXJ2aWV3IGNvbW1lbnQgdGV4dCBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGlzXG4gKiAgIGZpbGUgd2FzIGdlbmVyYXRlZCBmcm9tLlxuICogLSB1cGRhdGVzIGdlbmVyYXRlZCBmaWxlcyB0aGF0IGFyZSBub3QgaW4gdGhlIGdpdmVuIG1hcCBvZiBnZW5lcmF0ZWRGaWxlcyB0byBoYXZlIGFuIGVtcHR5XG4gKiAgIGxpc3Qgb2Ygc3RhdGVtZW50cyBhcyB0aGVpciBib2R5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5ndWxhckVtaXR0ZXJUcmFuc2Zvcm1GYWN0b3J5KFxuICAgIGdlbmVyYXRlZEZpbGVzOiBNYXA8c3RyaW5nLCBHZW5lcmF0ZWRGaWxlPiwgcHJvZ3JhbTogdHMuUHJvZ3JhbSxcbiAgICBhbm5vdGF0ZUZvckNsb3N1cmVDb21waWxlcjogYm9vbGVhbik6ICgpID0+IChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKSA9PiB0cy5Tb3VyY2VGaWxlIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgVHlwZVNjcmlwdE5vZGVFbWl0dGVyKGFubm90YXRlRm9yQ2xvc3VyZUNvbXBpbGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlRmlsZTogdHMuU291cmNlRmlsZSk6IHRzLlNvdXJjZUZpbGUge1xuICAgICAgY29uc3QgZyA9IGdlbmVyYXRlZEZpbGVzLmdldChzb3VyY2VGaWxlLmZpbGVOYW1lKTtcbiAgICAgIGNvbnN0IG9yaWcgPSBnICYmIHByb2dyYW0uZ2V0U291cmNlRmlsZShnLnNyY0ZpbGVVcmwpO1xuICAgICAgbGV0IG9yaWdpbmFsQ29tbWVudCA9ICcnO1xuICAgICAgaWYgKG9yaWcpIG9yaWdpbmFsQ29tbWVudCA9IGdldEZpbGVvdmVydmlld0NvbW1lbnQob3JpZyk7XG4gICAgICBjb25zdCBwcmVhbWJsZSA9IGdldFByZWFtYmxlKG9yaWdpbmFsQ29tbWVudCk7XG4gICAgICBpZiAoZyAmJiBnLnN0bXRzKSB7XG4gICAgICAgIGNvbnN0IFtuZXdTb3VyY2VGaWxlXSA9IGVtaXR0ZXIudXBkYXRlU291cmNlRmlsZShzb3VyY2VGaWxlLCBnLnN0bXRzLCBwcmVhbWJsZSk7XG4gICAgICAgIHJldHVybiBuZXdTb3VyY2VGaWxlO1xuICAgICAgfSBlbHNlIGlmIChHRU5FUkFURURfRklMRVMudGVzdChzb3VyY2VGaWxlLmZpbGVOYW1lKSkge1xuICAgICAgICAvLyBUaGUgZmlsZSBzaG91bGQgYmUgZW1wdHksIGJ1dCBlbWl0dGVyLnVwZGF0ZVNvdXJjZUZpbGUgd291bGQgc3RpbGwgYWRkIGltcG9ydHNcbiAgICAgICAgLy8gYW5kIHZhcmlvdXMgbWludXRpYWUuXG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgc291cmNlIGZpbGUgZW50aXJlbHksIG9ubHkgaW5jbHVkaW5nIHRoZSBwcmVhbWJsZSBjb21tZW50LCBzbyB0aGF0XG4gICAgICAgIC8vIG5nYyBwcm9kdWNlcyBhbiBlbXB0eSAuanMgZmlsZS5cbiAgICAgICAgY29uc3QgY29tbWVudFN0bXQgPSB0cy5jcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50KHNvdXJjZUZpbGUpO1xuICAgICAgICB0cy5hZGRTeW50aGV0aWNMZWFkaW5nQ29tbWVudChcbiAgICAgICAgICAgIGNvbW1lbnRTdG10LCB0cy5TeW50YXhLaW5kLk11bHRpTGluZUNvbW1lbnRUcml2aWEsIHByZWFtYmxlLFxuICAgICAgICAgICAgLyogaGFzVHJhaWxpbmdOZXdsaW5lICovIHRydWUpO1xuICAgICAgICByZXR1cm4gdHMudXBkYXRlU291cmNlRmlsZU5vZGUoc291cmNlRmlsZSwgW2NvbW1lbnRTdG10XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRmlsZTtcbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbmQgcmV0dXJucyB0aGUgY29tbWVudCB0ZXh0ICh3aXRob3V0IHN0YXJ0IGFuZCBlbmQgbWFya2Vycykgb2YgYSBcXEBmaWxlb3ZlcnZpZXcgY29tbWVudFxuICogaW4gdGhlIGdpdmVuIHNvdXJjZSBmaWxlLiBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBjb21tZW50IGNhbiBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsZW92ZXJ2aWV3Q29tbWVudChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKTogc3RyaW5nIHtcbiAgY29uc3QgdHJpdmlhID0gc291cmNlRmlsZS5nZXRGdWxsVGV4dCgpLnN1YnN0cmluZygwLCBzb3VyY2VGaWxlLmdldFN0YXJ0KCkpO1xuICBjb25zdCBsZWFkaW5nQ29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyh0cml2aWEsIDApO1xuICBpZiAoIWxlYWRpbmdDb21tZW50cyB8fCBsZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGNvbnN0IGNvbW1lbnQgPSBsZWFkaW5nQ29tbWVudHNbMF07XG4gIGlmIChjb21tZW50LmtpbmQgIT09IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSkgcmV0dXJuICcnO1xuICAvLyBPbmx5IGNvbW1lbnRzIHNlcGFyYXRlZCB3aXRoIGEgXFxuXFxuIGZyb20gdGhlIGZpbGUgY29udGVudHMgYXJlIGNvbnNpZGVyZWQgZmlsZS1sZXZlbCBjb21tZW50c1xuICAvLyBpbiBUeXBlU2NyaXB0LlxuICBpZiAoc291cmNlRmlsZS5nZXRGdWxsVGV4dCgpLnN1YnN0cmluZyhjb21tZW50LmVuZCwgY29tbWVudC5lbmQgKyAyKSAhPT0gJ1xcblxcbicpIHJldHVybiAnJztcbiAgY29uc3QgY29tbWVudFRleHQgPSBzb3VyY2VGaWxlLmdldEZ1bGxUZXh0KCkuc3Vic3RyaW5nKGNvbW1lbnQucG9zLCBjb21tZW50LmVuZCk7XG4gIC8vIENsb3N1cmUgQ29tcGlsZXIgaWdub3JlcyBAc3VwcHJlc3MgYW5kIHNpbWlsYXIgaWYgdGhlIGNvbW1lbnQgY29udGFpbnMgQGxpY2Vuc2UuXG4gIGlmIChjb21tZW50VGV4dC5pbmRleE9mKCdAbGljZW5zZScpICE9PSAtMSkgcmV0dXJuICcnO1xuICAvLyBBbHNvIHJlbW92ZSBhbnkgbGVhZGluZyBgKiBgIGZyb20gdGhlIGZpcnN0IGxpbmUgaW4gY2FzZSBpdCB3YXMgYSBKU0RPQyBjb21tZW50XG4gIHJldHVybiBzdHJpcENvbW1lbnQoY29tbWVudFRleHQpLnJlcGxhY2UoL15cXCpcXHMrLywgJycpO1xufVxuIl19