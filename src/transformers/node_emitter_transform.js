/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@angular/compiler-cli/src/transformers/node_emitter_transform", ["require", "exports", "tslib", "typescript", "@angular/compiler-cli/src/transformers/node_emitter", "@angular/compiler-cli/src/transformers/util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAngularEmitterTransformFactory = void 0;
    var tslib_1 = require("tslib");
    var ts = require("typescript");
    var node_emitter_1 = require("@angular/compiler-cli/src/transformers/node_emitter");
    var util_1 = require("@angular/compiler-cli/src/transformers/util");
    function getPreamble(original) {
        return "/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n * " + original + "\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes,extraRequire}\n * tslint:disable\n */";
    }
    /**
     * Returns a transformer that does two things for generated files (ngfactory etc):
     * - adds a fileoverview JSDoc comment containing Closure Compiler specific "suppress"ions in JSDoc.
     *   The new comment will contain any fileoverview comment text from the original source file this
     *   file was generated from.
     * - updates generated files that are not in the given map of generatedFiles to have an empty
     *   list of statements as their body.
     */
    function getAngularEmitterTransformFactory(generatedFiles, program, annotateForClosureCompiler) {
        return function () {
            var emitter = new node_emitter_1.TypeScriptNodeEmitter(annotateForClosureCompiler);
            return function (sourceFile) {
                var g = generatedFiles.get(sourceFile.fileName);
                var orig = g && program.getSourceFile(g.srcFileUrl);
                var originalComment = '';
                if (orig)
                    originalComment = getFileoverviewComment(orig);
                var preamble = getPreamble(originalComment);
                if (g && g.stmts) {
                    var orig_1 = program.getSourceFile(g.srcFileUrl);
                    var originalComment_1 = '';
                    if (orig_1)
                        originalComment_1 = getFileoverviewComment(orig_1);
                    var _a = tslib_1.__read(emitter.updateSourceFile(sourceFile, g.stmts, preamble), 1), newSourceFile = _a[0];
                    return newSourceFile;
                }
                else if (util_1.GENERATED_FILES.test(sourceFile.fileName)) {
                    // The file should be empty, but emitter.updateSourceFile would still add imports
                    // and various minutiae.
                    // Clear out the source file entirely, only including the preamble comment, so that
                    // ngc produces an empty .js file.
                    return ts.updateSourceFileNode(sourceFile, [emitter.createCommentStatement(sourceFile, preamble)]);
                }
                return sourceFile;
            };
        };
    }
    exports.getAngularEmitterTransformFactory = getAngularEmitterTransformFactory;
    /**
     * Parses and returns the comment text (without start and end markers) of a \@fileoverview comment
     * in the given source file. Returns the empty string if no such comment can be found.
     */
    function getFileoverviewComment(sourceFile) {
        var trivia = sourceFile.getFullText().substring(0, sourceFile.getStart());
        var leadingComments = ts.getLeadingCommentRanges(trivia, 0);
        if (!leadingComments || leadingComments.length === 0)
            return '';
        var comment = leadingComments[0];
        if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia)
            return '';
        // Only comments separated with a \n\n from the file contents are considered file-level comments
        // in TypeScript.
        if (sourceFile.getFullText().substring(comment.end, comment.end + 2) !== '\n\n')
            return '';
        var commentText = sourceFile.getFullText().substring(comment.pos, comment.end);
        // Closure Compiler ignores @suppress and similar if the comment contains @license.
        if (commentText.indexOf('@license') !== -1)
            return '';
        return commentText.replace(/^\/\*\*/, '').replace(/ ?\*\/$/, '');
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9lbWl0dGVyX3RyYW5zZm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvdHJhbnNmb3JtZXJzL25vZGVfZW1pdHRlcl90cmFuc2Zvcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7OztJQUdILCtCQUFpQztJQUVqQyxvRkFBcUQ7SUFDckQsb0VBQXVDO0lBRXZDLFNBQVMsV0FBVyxDQUFDLFFBQWdCO1FBQ25DLE9BQU8sc0dBRUosUUFBUSxrSUFHVCxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxTQUFnQixpQ0FBaUMsQ0FDN0MsY0FBMEMsRUFBRSxPQUFtQixFQUMvRCwwQkFBbUM7UUFDckMsT0FBTztZQUNMLElBQU0sT0FBTyxHQUFHLElBQUksb0NBQXFCLENBQUMsMEJBQTBCLENBQUMsQ0FBQztZQUN0RSxPQUFPLFVBQVMsVUFBeUI7Z0JBQ3ZDLElBQU0sQ0FBQyxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNsRCxJQUFNLElBQUksR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQ3RELElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxJQUFJO29CQUFFLGVBQWUsR0FBRyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDekQsSUFBTSxRQUFRLEdBQUcsV0FBVyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUM5QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFO29CQUNoQixJQUFNLE1BQUksR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFDakQsSUFBSSxpQkFBZSxHQUFHLEVBQUUsQ0FBQztvQkFDekIsSUFBSSxNQUFJO3dCQUFFLGlCQUFlLEdBQUcsc0JBQXNCLENBQUMsTUFBSSxDQUFDLENBQUM7b0JBQ25ELElBQUEsS0FBQSxlQUFrQixPQUFPLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUEsRUFBeEUsYUFBYSxRQUEyRCxDQUFDO29CQUNoRixPQUFPLGFBQWEsQ0FBQztpQkFDdEI7cUJBQU0sSUFBSSxzQkFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7b0JBQ3BELGlGQUFpRjtvQkFDakYsd0JBQXdCO29CQUN4QixtRkFBbUY7b0JBQ25GLGtDQUFrQztvQkFDbEMsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQzFCLFVBQVUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUN6RTtnQkFDRCxPQUFPLFVBQVUsQ0FBQztZQUNwQixDQUFDLENBQUM7UUFDSixDQUFDLENBQUM7SUFDSixDQUFDO0lBNUJELDhFQTRCQztJQUVEOzs7T0FHRztJQUNILFNBQVMsc0JBQXNCLENBQUMsVUFBeUI7UUFDdkQsSUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDNUUsSUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsZUFBZSxJQUFJLGVBQWUsQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUFFLE9BQU8sRUFBRSxDQUFDO1FBQ2hFLElBQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0I7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUNyRSxnR0FBZ0c7UUFDaEcsaUJBQWlCO1FBQ2pCLElBQUksVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEtBQUssTUFBTTtZQUFFLE9BQU8sRUFBRSxDQUFDO1FBQzNGLElBQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakYsbUZBQW1GO1FBQ25GLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUN0RCxPQUFPLFdBQVcsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDbkUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtHZW5lcmF0ZWRGaWxlfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtUeXBlU2NyaXB0Tm9kZUVtaXR0ZXJ9IGZyb20gJy4vbm9kZV9lbWl0dGVyJztcbmltcG9ydCB7R0VORVJBVEVEX0ZJTEVTfSBmcm9tICcuL3V0aWwnO1xuXG5mdW5jdGlvbiBnZXRQcmVhbWJsZShvcmlnaW5hbDogc3RyaW5nKSB7XG4gIHJldHVybiBgLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSBBbmd1bGFyIHRlbXBsYXRlIGNvbXBpbGVyLiBEbyBub3QgZWRpdC5cbiAqICR7b3JpZ2luYWx9XG4gKiBAc3VwcHJlc3Mge3N1c3BpY2lvdXNDb2RlLHVzZWxlc3NDb2RlLG1pc3NpbmdQcm9wZXJ0aWVzLG1pc3NpbmdPdmVycmlkZSxjaGVja1R5cGVzLGV4dHJhUmVxdWlyZX1cbiAqIHRzbGludDpkaXNhYmxlXG4gKi9gO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0cmFuc2Zvcm1lciB0aGF0IGRvZXMgdHdvIHRoaW5ncyBmb3IgZ2VuZXJhdGVkIGZpbGVzIChuZ2ZhY3RvcnkgZXRjKTpcbiAqIC0gYWRkcyBhIGZpbGVvdmVydmlldyBKU0RvYyBjb21tZW50IGNvbnRhaW5pbmcgQ2xvc3VyZSBDb21waWxlciBzcGVjaWZpYyBcInN1cHByZXNzXCJpb25zIGluIEpTRG9jLlxuICogICBUaGUgbmV3IGNvbW1lbnQgd2lsbCBjb250YWluIGFueSBmaWxlb3ZlcnZpZXcgY29tbWVudCB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoaXNcbiAqICAgZmlsZSB3YXMgZ2VuZXJhdGVkIGZyb20uXG4gKiAtIHVwZGF0ZXMgZ2VuZXJhdGVkIGZpbGVzIHRoYXQgYXJlIG5vdCBpbiB0aGUgZ2l2ZW4gbWFwIG9mIGdlbmVyYXRlZEZpbGVzIHRvIGhhdmUgYW4gZW1wdHlcbiAqICAgbGlzdCBvZiBzdGF0ZW1lbnRzIGFzIHRoZWlyIGJvZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmd1bGFyRW1pdHRlclRyYW5zZm9ybUZhY3RvcnkoXG4gICAgZ2VuZXJhdGVkRmlsZXM6IE1hcDxzdHJpbmcsIEdlbmVyYXRlZEZpbGU+LCBwcm9ncmFtOiB0cy5Qcm9ncmFtLFxuICAgIGFubm90YXRlRm9yQ2xvc3VyZUNvbXBpbGVyOiBib29sZWFuKTogKCkgPT4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHRzLlNvdXJjZUZpbGUge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZW1pdHRlciA9IG5ldyBUeXBlU2NyaXB0Tm9kZUVtaXR0ZXIoYW5ub3RhdGVGb3JDbG9zdXJlQ29tcGlsZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKTogdHMuU291cmNlRmlsZSB7XG4gICAgICBjb25zdCBnID0gZ2VuZXJhdGVkRmlsZXMuZ2V0KHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICAgICAgY29uc3Qgb3JpZyA9IGcgJiYgcHJvZ3JhbS5nZXRTb3VyY2VGaWxlKGcuc3JjRmlsZVVybCk7XG4gICAgICBsZXQgb3JpZ2luYWxDb21tZW50ID0gJyc7XG4gICAgICBpZiAob3JpZykgb3JpZ2luYWxDb21tZW50ID0gZ2V0RmlsZW92ZXJ2aWV3Q29tbWVudChvcmlnKTtcbiAgICAgIGNvbnN0IHByZWFtYmxlID0gZ2V0UHJlYW1ibGUob3JpZ2luYWxDb21tZW50KTtcbiAgICAgIGlmIChnICYmIGcuc3RtdHMpIHtcbiAgICAgICAgY29uc3Qgb3JpZyA9IHByb2dyYW0uZ2V0U291cmNlRmlsZShnLnNyY0ZpbGVVcmwpO1xuICAgICAgICBsZXQgb3JpZ2luYWxDb21tZW50ID0gJyc7XG4gICAgICAgIGlmIChvcmlnKSBvcmlnaW5hbENvbW1lbnQgPSBnZXRGaWxlb3ZlcnZpZXdDb21tZW50KG9yaWcpO1xuICAgICAgICBjb25zdCBbbmV3U291cmNlRmlsZV0gPSBlbWl0dGVyLnVwZGF0ZVNvdXJjZUZpbGUoc291cmNlRmlsZSwgZy5zdG10cywgcHJlYW1ibGUpO1xuICAgICAgICByZXR1cm4gbmV3U291cmNlRmlsZTtcbiAgICAgIH0gZWxzZSBpZiAoR0VORVJBVEVEX0ZJTEVTLnRlc3Qoc291cmNlRmlsZS5maWxlTmFtZSkpIHtcbiAgICAgICAgLy8gVGhlIGZpbGUgc2hvdWxkIGJlIGVtcHR5LCBidXQgZW1pdHRlci51cGRhdGVTb3VyY2VGaWxlIHdvdWxkIHN0aWxsIGFkZCBpbXBvcnRzXG4gICAgICAgIC8vIGFuZCB2YXJpb3VzIG1pbnV0aWFlLlxuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHNvdXJjZSBmaWxlIGVudGlyZWx5LCBvbmx5IGluY2x1ZGluZyB0aGUgcHJlYW1ibGUgY29tbWVudCwgc28gdGhhdFxuICAgICAgICAvLyBuZ2MgcHJvZHVjZXMgYW4gZW1wdHkgLmpzIGZpbGUuXG4gICAgICAgIHJldHVybiB0cy51cGRhdGVTb3VyY2VGaWxlTm9kZShcbiAgICAgICAgICAgIHNvdXJjZUZpbGUsIFtlbWl0dGVyLmNyZWF0ZUNvbW1lbnRTdGF0ZW1lbnQoc291cmNlRmlsZSwgcHJlYW1ibGUpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRmlsZTtcbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbmQgcmV0dXJucyB0aGUgY29tbWVudCB0ZXh0ICh3aXRob3V0IHN0YXJ0IGFuZCBlbmQgbWFya2Vycykgb2YgYSBcXEBmaWxlb3ZlcnZpZXcgY29tbWVudFxuICogaW4gdGhlIGdpdmVuIHNvdXJjZSBmaWxlLiBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBjb21tZW50IGNhbiBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsZW92ZXJ2aWV3Q29tbWVudChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKTogc3RyaW5nIHtcbiAgY29uc3QgdHJpdmlhID0gc291cmNlRmlsZS5nZXRGdWxsVGV4dCgpLnN1YnN0cmluZygwLCBzb3VyY2VGaWxlLmdldFN0YXJ0KCkpO1xuICBjb25zdCBsZWFkaW5nQ29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyh0cml2aWEsIDApO1xuICBpZiAoIWxlYWRpbmdDb21tZW50cyB8fCBsZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGNvbnN0IGNvbW1lbnQgPSBsZWFkaW5nQ29tbWVudHNbMF07XG4gIGlmIChjb21tZW50LmtpbmQgIT09IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSkgcmV0dXJuICcnO1xuICAvLyBPbmx5IGNvbW1lbnRzIHNlcGFyYXRlZCB3aXRoIGEgXFxuXFxuIGZyb20gdGhlIGZpbGUgY29udGVudHMgYXJlIGNvbnNpZGVyZWQgZmlsZS1sZXZlbCBjb21tZW50c1xuICAvLyBpbiBUeXBlU2NyaXB0LlxuICBpZiAoc291cmNlRmlsZS5nZXRGdWxsVGV4dCgpLnN1YnN0cmluZyhjb21tZW50LmVuZCwgY29tbWVudC5lbmQgKyAyKSAhPT0gJ1xcblxcbicpIHJldHVybiAnJztcbiAgY29uc3QgY29tbWVudFRleHQgPSBzb3VyY2VGaWxlLmdldEZ1bGxUZXh0KCkuc3Vic3RyaW5nKGNvbW1lbnQucG9zLCBjb21tZW50LmVuZCk7XG4gIC8vIENsb3N1cmUgQ29tcGlsZXIgaWdub3JlcyBAc3VwcHJlc3MgYW5kIHNpbWlsYXIgaWYgdGhlIGNvbW1lbnQgY29udGFpbnMgQGxpY2Vuc2UuXG4gIGlmIChjb21tZW50VGV4dC5pbmRleE9mKCdAbGljZW5zZScpICE9PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gY29tbWVudFRleHQucmVwbGFjZSgvXlxcL1xcKlxcKi8sICcnKS5yZXBsYWNlKC8gP1xcKlxcLyQvLCAnJyk7XG59XG4iXX0=