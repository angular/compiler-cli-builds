#!/usr/bin/env node
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Must be imported first, because Angular decorators throw on load.
import 'reflect-metadata';
import * as ts from 'typescript';
import * as api from './transformers/api';
import { GENERATED_FILES } from './transformers/util';
import { exitCodeFromResult, performCompilation, readConfiguration, formatDiagnostics, filterErrorsAndWarnings } from './perform_compile';
import { performWatchCompilation, createPerformWatchHost } from './perform_watch';
import { NodeJSFileSystem, setFileSystem } from './ngtsc/file_system';
export function main(args, consoleError = console.error, config, customTransformers, programReuse, modifiedResourceFiles) {
    let { project, rootNames, options, errors: configErrors, watch, emitFlags } = config || readNgcCommandLineAndConfiguration(args);
    if (configErrors.length) {
        return reportErrorsAndExit(configErrors, /*options*/ undefined, consoleError);
    }
    if (watch) {
        const result = watchMode(project, options, consoleError);
        return reportErrorsAndExit(result.firstCompileResult, options, consoleError);
    }
    let oldProgram;
    if (programReuse !== undefined) {
        oldProgram = programReuse.program;
    }
    const { diagnostics: compileDiags, program } = performCompilation({
        rootNames,
        options,
        emitFlags,
        oldProgram,
        emitCallback: createEmitCallback(options),
        customTransformers,
        modifiedResourceFiles
    });
    if (programReuse !== undefined) {
        programReuse.program = program;
    }
    return reportErrorsAndExit(compileDiags, options, consoleError);
}
export function mainDiagnosticsForTest(args, config, programReuse, modifiedResourceFiles) {
    let { project, rootNames, options, errors: configErrors, watch, emitFlags } = config || readNgcCommandLineAndConfiguration(args);
    if (configErrors.length) {
        return configErrors;
    }
    let oldProgram;
    if (programReuse !== undefined) {
        oldProgram = programReuse.program;
    }
    const { diagnostics: compileDiags, program } = performCompilation({
        rootNames,
        options,
        emitFlags,
        oldProgram,
        modifiedResourceFiles,
        emitCallback: createEmitCallback(options),
    });
    if (programReuse !== undefined) {
        programReuse.program = program;
    }
    return compileDiags;
}
function createEmitCallback(options) {
    if (!options.annotateForClosureCompiler) {
        return undefined;
    }
    const tsickleHost = {
        shouldSkipTsickleProcessing: (fileName) => /\.d\.ts$/.test(fileName) ||
            // View Engine's generated files were never intended to be processed with tsickle.
            (!options.enableIvy && GENERATED_FILES.test(fileName)),
        pathToModuleName: (context, importPath) => '',
        shouldIgnoreWarningsForPath: (filePath) => false,
        fileNameToModuleId: (fileName) => fileName,
        googmodule: false,
        untyped: true,
        convertIndexImportShorthand: false,
        // Decorators are transformed as part of the Angular compiler programs. To avoid
        // conflicts, we disable decorator transformations for tsickle.
        transformDecorators: false,
        transformTypesToClosure: true,
    };
    return ({ program, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers = {}, host, options }) => 
    // tslint:disable-next-line:no-require-imports only depend on tsickle if requested
    require('tsickle').emitWithTsickle(program, Object.assign(Object.assign({}, tsickleHost), { options, host, moduleResolutionHost: host }), host, options, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, {
        beforeTs: customTransformers.before,
        afterTs: customTransformers.after,
    });
}
export function readNgcCommandLineAndConfiguration(args) {
    const options = {};
    const parsedArgs = require('minimist')(args);
    if (parsedArgs.i18nFile)
        options.i18nInFile = parsedArgs.i18nFile;
    if (parsedArgs.i18nFormat)
        options.i18nInFormat = parsedArgs.i18nFormat;
    if (parsedArgs.locale)
        options.i18nInLocale = parsedArgs.locale;
    const mt = parsedArgs.missingTranslation;
    if (mt === 'error' || mt === 'warning' || mt === 'ignore') {
        options.i18nInMissingTranslations = mt;
    }
    const config = readCommandLineAndConfiguration(args, options, ['i18nFile', 'i18nFormat', 'locale', 'missingTranslation', 'watch']);
    const watch = parsedArgs.w || parsedArgs.watch;
    return Object.assign(Object.assign({}, config), { watch });
}
export function readCommandLineAndConfiguration(args, existingOptions = {}, ngCmdLineOptions = []) {
    let cmdConfig = ts.parseCommandLine(args);
    const project = cmdConfig.options.project || '.';
    const cmdErrors = cmdConfig.errors.filter(e => {
        if (typeof e.messageText === 'string') {
            const msg = e.messageText;
            return !ngCmdLineOptions.some(o => msg.indexOf(o) >= 0);
        }
        return true;
    });
    if (cmdErrors.length) {
        return {
            project,
            rootNames: [],
            options: cmdConfig.options,
            errors: cmdErrors,
            emitFlags: api.EmitFlags.Default
        };
    }
    const config = readConfiguration(project, cmdConfig.options);
    const options = Object.assign(Object.assign({}, config.options), existingOptions);
    if (options.locale) {
        options.i18nInLocale = options.locale;
    }
    return {
        project,
        rootNames: config.rootNames,
        options,
        errors: config.errors,
        emitFlags: config.emitFlags
    };
}
function getFormatDiagnosticsHost(options) {
    const basePath = options ? options.basePath : undefined;
    return {
        getCurrentDirectory: () => basePath || ts.sys.getCurrentDirectory(),
        // We need to normalize the path separators here because by default, TypeScript
        // compiler hosts use posix canonical paths. In order to print consistent diagnostics,
        // we also normalize the paths.
        getCanonicalFileName: fileName => fileName.replace(/\\/g, '/'),
        getNewLine: () => {
            // Manually determine the proper new line string based on the passed compiler
            // options. There is no public TypeScript function that returns the corresponding
            // new line string. see: https://github.com/Microsoft/TypeScript/issues/29581
            if (options && options.newLine !== undefined) {
                return options.newLine === ts.NewLineKind.LineFeed ? '\n' : '\r\n';
            }
            return ts.sys.newLine;
        },
    };
}
function reportErrorsAndExit(allDiagnostics, options, consoleError = console.error) {
    const errorsAndWarnings = filterErrorsAndWarnings(allDiagnostics);
    printDiagnostics(errorsAndWarnings, options, consoleError);
    return exitCodeFromResult(allDiagnostics);
}
export function watchMode(project, options, consoleError) {
    return performWatchCompilation(createPerformWatchHost(project, diagnostics => {
        printDiagnostics(diagnostics, options, consoleError);
    }, options, options => createEmitCallback(options)));
}
function printDiagnostics(diagnostics, options, consoleError) {
    if (diagnostics.length === 0) {
        return;
    }
    const formatHost = getFormatDiagnosticsHost(options);
    consoleError(formatDiagnostics(diagnostics, formatHost));
}
// CLI entry point
if (require.main === module) {
    process.title = 'Angular Compiler (ngc)';
    const args = process.argv.slice(2);
    // We are running the real compiler so run against the real file-system
    setFileSystem(new NodeJSFileSystem());
    process.exitCode = main(args);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7Ozs7OztHQU1HO0FBRUgsb0VBQW9FO0FBQ3BFLE9BQU8sa0JBQWtCLENBQUM7QUFFMUIsT0FBTyxLQUFLLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFJakMsT0FBTyxLQUFLLEdBQUcsTUFBTSxvQkFBb0IsQ0FBQztBQUMxQyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFFcEQsT0FBTyxFQUFDLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFvQyx1QkFBdUIsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzFLLE9BQU8sRUFBQyx1QkFBdUIsRUFBRSxzQkFBc0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ2hGLE9BQU8sRUFBQyxnQkFBZ0IsRUFBRSxhQUFhLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUVwRSxNQUFNLFVBQVUsSUFBSSxDQUNoQixJQUFjLEVBQUUsZUFBb0MsT0FBTyxDQUFDLEtBQUssRUFDakUsTUFBK0IsRUFBRSxrQkFBMkMsRUFBRSxZQUU3RSxFQUNELHFCQUF3QztJQUMxQyxJQUFJLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFDLEdBQ3JFLE1BQU0sSUFBSSxrQ0FBa0MsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxJQUFJLFlBQVksQ0FBQyxNQUFNLEVBQUU7UUFDdkIsT0FBTyxtQkFBbUIsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsQ0FBQztLQUMvRTtJQUNELElBQUksS0FBSyxFQUFFO1FBQ1QsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLE9B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T0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDL0IiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLy8gTXVzdCBiZSBpbXBvcnRlZCBmaXJzdCwgYmVjYXVzZSBBbmd1bGFyIGRlY29yYXRvcnMgdGhyb3cgb24gbG9hZC5cbmltcG9ydCAncmVmbGVjdC1tZXRhZGF0YSc7XG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuaW1wb3J0ICogYXMgdHNpY2tsZSBmcm9tICd0c2lja2xlJztcblxuaW1wb3J0IHtyZXBsYWNlVHNXaXRoTmdJbkVycm9yc30gZnJvbSAnLi9uZ3RzYy9kaWFnbm9zdGljcyc7XG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi90cmFuc2Zvcm1lcnMvYXBpJztcbmltcG9ydCB7R0VORVJBVEVEX0ZJTEVTfSBmcm9tICcuL3RyYW5zZm9ybWVycy91dGlsJztcblxuaW1wb3J0IHtleGl0Q29kZUZyb21SZXN1bHQsIHBlcmZvcm1Db21waWxhdGlvbiwgcmVhZENvbmZpZ3VyYXRpb24sIGZvcm1hdERpYWdub3N0aWNzLCBEaWFnbm9zdGljcywgUGFyc2VkQ29uZmlndXJhdGlvbiwgZmlsdGVyRXJyb3JzQW5kV2FybmluZ3N9IGZyb20gJy4vcGVyZm9ybV9jb21waWxlJztcbmltcG9ydCB7cGVyZm9ybVdhdGNoQ29tcGlsYXRpb24swqBjcmVhdGVQZXJmb3JtV2F0Y2hIb3N0fSBmcm9tICcuL3BlcmZvcm1fd2F0Y2gnO1xuaW1wb3J0IHtOb2RlSlNGaWxlU3lzdGVtLCBzZXRGaWxlU3lzdGVtfSBmcm9tICcuL25ndHNjL2ZpbGVfc3lzdGVtJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1haW4oXG4gICAgYXJnczogc3RyaW5nW10sIGNvbnNvbGVFcnJvcjogKHM6IHN0cmluZykgPT4gdm9pZCA9IGNvbnNvbGUuZXJyb3IsXG4gICAgY29uZmlnPzogTmdjUGFyc2VkQ29uZmlndXJhdGlvbiwgY3VzdG9tVHJhbnNmb3JtZXJzPzogYXBpLkN1c3RvbVRyYW5zZm9ybWVycywgcHJvZ3JhbVJldXNlPzoge1xuICAgICAgcHJvZ3JhbTogYXBpLlByb2dyYW18dW5kZWZpbmVkLFxuICAgIH0sXG4gICAgbW9kaWZpZWRSZXNvdXJjZUZpbGVzPzogU2V0PHN0cmluZz58bnVsbCk6IG51bWJlciB7XG4gIGxldCB7cHJvamVjdCwgcm9vdE5hbWVzLCBvcHRpb25zLCBlcnJvcnM6IGNvbmZpZ0Vycm9ycywgd2F0Y2gsIGVtaXRGbGFnc30gPVxuICAgICAgY29uZmlnIHx8IHJlYWROZ2NDb21tYW5kTGluZUFuZENvbmZpZ3VyYXRpb24oYXJncyk7XG4gIGlmIChjb25maWdFcnJvcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlcG9ydEVycm9yc0FuZEV4aXQoY29uZmlnRXJyb3JzLCAvKm9wdGlvbnMqLyB1bmRlZmluZWQsIGNvbnNvbGVFcnJvcik7XG4gIH1cbiAgaWYgKHdhdGNoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gd2F0Y2hNb2RlKHByb2plY3QsIG9wdGlvbnMsIGNvbnNvbGVFcnJvcik7XG4gICAgcmV0dXJuIHJlcG9ydEVycm9yc0FuZEV4aXQocmVzdWx0LmZpcnN0Q29tcGlsZVJlc3VsdCwgb3B0aW9ucywgY29uc29sZUVycm9yKTtcbiAgfVxuXG4gIGxldCBvbGRQcm9ncmFtOiBhcGkuUHJvZ3JhbXx1bmRlZmluZWQ7XG4gIGlmIChwcm9ncmFtUmV1c2UgIT09IHVuZGVmaW5lZCkge1xuICAgIG9sZFByb2dyYW0gPSBwcm9ncmFtUmV1c2UucHJvZ3JhbTtcbiAgfVxuXG4gIGNvbnN0IHtkaWFnbm9zdGljczogY29tcGlsZURpYWdzLCBwcm9ncmFtfSA9IHBlcmZvcm1Db21waWxhdGlvbih7XG4gICAgcm9vdE5hbWVzLFxuICAgIG9wdGlvbnMsXG4gICAgZW1pdEZsYWdzLFxuICAgIG9sZFByb2dyYW0sXG4gICAgZW1pdENhbGxiYWNrOiBjcmVhdGVFbWl0Q2FsbGJhY2sob3B0aW9ucyksXG4gICAgY3VzdG9tVHJhbnNmb3JtZXJzLFxuICAgIG1vZGlmaWVkUmVzb3VyY2VGaWxlc1xuICB9KTtcbiAgaWYgKHByb2dyYW1SZXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvZ3JhbVJldXNlLnByb2dyYW0gPSBwcm9ncmFtO1xuICB9XG4gIHJldHVybiByZXBvcnRFcnJvcnNBbmRFeGl0KGNvbXBpbGVEaWFncywgb3B0aW9ucywgY29uc29sZUVycm9yKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1haW5EaWFnbm9zdGljc0ZvclRlc3QoXG4gICAgYXJnczogc3RyaW5nW10sIGNvbmZpZz86IE5nY1BhcnNlZENvbmZpZ3VyYXRpb24sXG4gICAgcHJvZ3JhbVJldXNlPzoge3Byb2dyYW06IGFwaS5Qcm9ncmFtfHVuZGVmaW5lZH0sXG4gICAgbW9kaWZpZWRSZXNvdXJjZUZpbGVzPzogU2V0PHN0cmluZz58bnVsbCk6IFJlYWRvbmx5QXJyYXk8dHMuRGlhZ25vc3RpY3xhcGkuRGlhZ25vc3RpYz4ge1xuICBsZXQge3Byb2plY3QsIHJvb3ROYW1lcywgb3B0aW9ucywgZXJyb3JzOiBjb25maWdFcnJvcnMsIHdhdGNoLCBlbWl0RmxhZ3N9ID1cbiAgICAgIGNvbmZpZyB8fCByZWFkTmdjQ29tbWFuZExpbmVBbmRDb25maWd1cmF0aW9uKGFyZ3MpO1xuICBpZiAoY29uZmlnRXJyb3JzLmxlbmd0aCkge1xuICAgIHJldHVybiBjb25maWdFcnJvcnM7XG4gIH1cblxuICBsZXQgb2xkUHJvZ3JhbTogYXBpLlByb2dyYW18dW5kZWZpbmVkO1xuICBpZiAocHJvZ3JhbVJldXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBvbGRQcm9ncmFtID0gcHJvZ3JhbVJldXNlLnByb2dyYW07XG4gIH1cblxuICBjb25zdCB7ZGlhZ25vc3RpY3M6IGNvbXBpbGVEaWFncywgcHJvZ3JhbX0gPSBwZXJmb3JtQ29tcGlsYXRpb24oe1xuICAgIHJvb3ROYW1lcyxcbiAgICBvcHRpb25zLFxuICAgIGVtaXRGbGFncyxcbiAgICBvbGRQcm9ncmFtLFxuICAgIG1vZGlmaWVkUmVzb3VyY2VGaWxlcyxcbiAgICBlbWl0Q2FsbGJhY2s6IGNyZWF0ZUVtaXRDYWxsYmFjayhvcHRpb25zKSxcbiAgfSk7XG5cbiAgaWYgKHByb2dyYW1SZXVzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvZ3JhbVJldXNlLnByb2dyYW0gPSBwcm9ncmFtO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVEaWFncztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW1pdENhbGxiYWNrKG9wdGlvbnM6IGFwaS5Db21waWxlck9wdGlvbnMpOiBhcGkuVHNFbWl0Q2FsbGJhY2t8dW5kZWZpbmVkIHtcbiAgaWYgKCFvcHRpb25zLmFubm90YXRlRm9yQ2xvc3VyZUNvbXBpbGVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB0c2lja2xlSG9zdDogUGljazxcbiAgICAgIHRzaWNrbGUuVHNpY2tsZUhvc3QsXG4gICAgICAnc2hvdWxkU2tpcFRzaWNrbGVQcm9jZXNzaW5nJ3wncGF0aFRvTW9kdWxlTmFtZSd8J3Nob3VsZElnbm9yZVdhcm5pbmdzRm9yUGF0aCd8XG4gICAgICAnZmlsZU5hbWVUb01vZHVsZUlkJ3wnZ29vZ21vZHVsZSd8J3VudHlwZWQnfCdjb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQnfFxuICAgICAgJ3RyYW5zZm9ybURlY29yYXRvcnMnfCd0cmFuc2Zvcm1UeXBlc1RvQ2xvc3VyZSc+ID0ge1xuICAgIHNob3VsZFNraXBUc2lja2xlUHJvY2Vzc2luZzogKGZpbGVOYW1lKSA9PiAvXFwuZFxcLnRzJC8udGVzdChmaWxlTmFtZSkgfHxcbiAgICAgICAgLy8gVmlldyBFbmdpbmUncyBnZW5lcmF0ZWQgZmlsZXMgd2VyZSBuZXZlciBpbnRlbmRlZCB0byBiZSBwcm9jZXNzZWQgd2l0aCB0c2lja2xlLlxuICAgICAgICAoIW9wdGlvbnMuZW5hYmxlSXZ5ICYmIEdFTkVSQVRFRF9GSUxFUy50ZXN0KGZpbGVOYW1lKSksXG4gICAgcGF0aFRvTW9kdWxlTmFtZTogKGNvbnRleHQsIGltcG9ydFBhdGgpID0+ICcnLFxuICAgIHNob3VsZElnbm9yZVdhcm5pbmdzRm9yUGF0aDogKGZpbGVQYXRoKSA9PiBmYWxzZSxcbiAgICBmaWxlTmFtZVRvTW9kdWxlSWQ6IChmaWxlTmFtZSkgPT4gZmlsZU5hbWUsXG4gICAgZ29vZ21vZHVsZTogZmFsc2UsXG4gICAgdW50eXBlZDogdHJ1ZSxcbiAgICBjb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQ6IGZhbHNlLFxuICAgIC8vIERlY29yYXRvcnMgYXJlIHRyYW5zZm9ybWVkIGFzIHBhcnQgb2YgdGhlIEFuZ3VsYXIgY29tcGlsZXIgcHJvZ3JhbXMuIFRvIGF2b2lkXG4gICAgLy8gY29uZmxpY3RzLCB3ZSBkaXNhYmxlIGRlY29yYXRvciB0cmFuc2Zvcm1hdGlvbnMgZm9yIHRzaWNrbGUuXG4gICAgdHJhbnNmb3JtRGVjb3JhdG9yczogZmFsc2UsXG4gICAgdHJhbnNmb3JtVHlwZXNUb0Nsb3N1cmU6IHRydWUsXG4gIH07XG5cbiAgcmV0dXJuICh7XG4gICAgICAgICAgIHByb2dyYW0sXG4gICAgICAgICAgIHRhcmdldFNvdXJjZUZpbGUsXG4gICAgICAgICAgIHdyaXRlRmlsZSxcbiAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgIGVtaXRPbmx5RHRzRmlsZXMsXG4gICAgICAgICAgIGN1c3RvbVRyYW5zZm9ybWVycyA9IHt9LFxuICAgICAgICAgICBob3N0LFxuICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICB9KSA9PlxuICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1yZXF1aXJlLWltcG9ydHMgb25seSBkZXBlbmQgb24gdHNpY2tsZSBpZiByZXF1ZXN0ZWRcbiAgICAgIHJlcXVpcmUoJ3RzaWNrbGUnKS5lbWl0V2l0aFRzaWNrbGUoXG4gICAgICAgICAgcHJvZ3JhbSwgey4uLnRzaWNrbGVIb3N0LCBvcHRpb25zLCBob3N0LCBtb2R1bGVSZXNvbHV0aW9uSG9zdDogaG9zdH0sIGhvc3QsIG9wdGlvbnMsXG4gICAgICAgICAgdGFyZ2V0U291cmNlRmlsZSwgd3JpdGVGaWxlLCBjYW5jZWxsYXRpb25Ub2tlbiwgZW1pdE9ubHlEdHNGaWxlcywge1xuICAgICAgICAgICAgYmVmb3JlVHM6IGN1c3RvbVRyYW5zZm9ybWVycy5iZWZvcmUsXG4gICAgICAgICAgICBhZnRlclRzOiBjdXN0b21UcmFuc2Zvcm1lcnMuYWZ0ZXIsXG4gICAgICAgICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmdjUGFyc2VkQ29uZmlndXJhdGlvbiBleHRlbmRzIFBhcnNlZENvbmZpZ3VyYXRpb24ge1xuICB3YXRjaD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkTmdjQ29tbWFuZExpbmVBbmRDb25maWd1cmF0aW9uKGFyZ3M6IHN0cmluZ1tdKTogTmdjUGFyc2VkQ29uZmlndXJhdGlvbiB7XG4gIGNvbnN0IG9wdGlvbnM6IGFwaS5Db21waWxlck9wdGlvbnMgPSB7fTtcbiAgY29uc3QgcGFyc2VkQXJncyA9IHJlcXVpcmUoJ21pbmltaXN0JykoYXJncyk7XG4gIGlmIChwYXJzZWRBcmdzLmkxOG5GaWxlKSBvcHRpb25zLmkxOG5JbkZpbGUgPSBwYXJzZWRBcmdzLmkxOG5GaWxlO1xuICBpZiAocGFyc2VkQXJncy5pMThuRm9ybWF0KSBvcHRpb25zLmkxOG5JbkZvcm1hdCA9IHBhcnNlZEFyZ3MuaTE4bkZvcm1hdDtcbiAgaWYgKHBhcnNlZEFyZ3MubG9jYWxlKSBvcHRpb25zLmkxOG5JbkxvY2FsZSA9IHBhcnNlZEFyZ3MubG9jYWxlO1xuICBjb25zdCBtdCA9IHBhcnNlZEFyZ3MubWlzc2luZ1RyYW5zbGF0aW9uO1xuICBpZiAobXQgPT09ICdlcnJvcicgfHwgbXQgPT09ICd3YXJuaW5nJyB8fCBtdCA9PT0gJ2lnbm9yZScpIHtcbiAgICBvcHRpb25zLmkxOG5Jbk1pc3NpbmdUcmFuc2xhdGlvbnMgPSBtdDtcbiAgfVxuICBjb25zdCBjb25maWcgPSByZWFkQ29tbWFuZExpbmVBbmRDb25maWd1cmF0aW9uKFxuICAgICAgYXJncywgb3B0aW9ucywgWydpMThuRmlsZScsICdpMThuRm9ybWF0JywgJ2xvY2FsZScsICdtaXNzaW5nVHJhbnNsYXRpb24nLCAnd2F0Y2gnXSk7XG4gIGNvbnN0IHdhdGNoID0gcGFyc2VkQXJncy53IHx8IHBhcnNlZEFyZ3Mud2F0Y2g7XG4gIHJldHVybiB7Li4uY29uZmlnLCB3YXRjaH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkQ29tbWFuZExpbmVBbmRDb25maWd1cmF0aW9uKFxuICAgIGFyZ3M6IHN0cmluZ1tdLCBleGlzdGluZ09wdGlvbnM6IGFwaS5Db21waWxlck9wdGlvbnMgPSB7fSxcbiAgICBuZ0NtZExpbmVPcHRpb25zOiBzdHJpbmdbXSA9IFtdKTogUGFyc2VkQ29uZmlndXJhdGlvbiB7XG4gIGxldCBjbWRDb25maWcgPSB0cy5wYXJzZUNvbW1hbmRMaW5lKGFyZ3MpO1xuICBjb25zdCBwcm9qZWN0ID0gY21kQ29uZmlnLm9wdGlvbnMucHJvamVjdCB8fCAnLic7XG4gIGNvbnN0IGNtZEVycm9ycyA9IGNtZENvbmZpZy5lcnJvcnMuZmlsdGVyKGUgPT4ge1xuICAgIGlmICh0eXBlb2YgZS5tZXNzYWdlVGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGUubWVzc2FnZVRleHQ7XG4gICAgICByZXR1cm4gIW5nQ21kTGluZU9wdGlvbnMuc29tZShvID0+IG1zZy5pbmRleE9mKG8pID49IDApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIGlmIChjbWRFcnJvcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2plY3QsXG4gICAgICByb290TmFtZXM6IFtdLFxuICAgICAgb3B0aW9uczogY21kQ29uZmlnLm9wdGlvbnMsXG4gICAgICBlcnJvcnM6IGNtZEVycm9ycyxcbiAgICAgIGVtaXRGbGFnczogYXBpLkVtaXRGbGFncy5EZWZhdWx0XG4gICAgfTtcbiAgfVxuICBjb25zdCBjb25maWcgPSByZWFkQ29uZmlndXJhdGlvbihwcm9qZWN0LCBjbWRDb25maWcub3B0aW9ucyk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7Li4uY29uZmlnLm9wdGlvbnMsIC4uLmV4aXN0aW5nT3B0aW9uc307XG4gIGlmIChvcHRpb25zLmxvY2FsZSkge1xuICAgIG9wdGlvbnMuaTE4bkluTG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9qZWN0LFxuICAgIHJvb3ROYW1lczogY29uZmlnLnJvb3ROYW1lcyxcbiAgICBvcHRpb25zLFxuICAgIGVycm9yczogY29uZmlnLmVycm9ycyxcbiAgICBlbWl0RmxhZ3M6IGNvbmZpZy5lbWl0RmxhZ3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0RGlhZ25vc3RpY3NIb3N0KG9wdGlvbnM/OiBhcGkuQ29tcGlsZXJPcHRpb25zKTogdHMuRm9ybWF0RGlhZ25vc3RpY3NIb3N0IHtcbiAgY29uc3QgYmFzZVBhdGggPSBvcHRpb25zID8gb3B0aW9ucy5iYXNlUGF0aCA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgICBnZXRDdXJyZW50RGlyZWN0b3J5OiAoKSA9PiBiYXNlUGF0aCB8fCB0cy5zeXMuZ2V0Q3VycmVudERpcmVjdG9yeSgpLFxuICAgIC8vIFdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSBwYXRoIHNlcGFyYXRvcnMgaGVyZSBiZWNhdXNlIGJ5IGRlZmF1bHQsIFR5cGVTY3JpcHRcbiAgICAvLyBjb21waWxlciBob3N0cyB1c2UgcG9zaXggY2Fub25pY2FsIHBhdGhzLiBJbiBvcmRlciB0byBwcmludCBjb25zaXN0ZW50IGRpYWdub3N0aWNzLFxuICAgIC8vIHdlIGFsc28gbm9ybWFsaXplIHRoZSBwYXRocy5cbiAgICBnZXRDYW5vbmljYWxGaWxlTmFtZTogZmlsZU5hbWUgPT4gZmlsZU5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpLFxuICAgIGdldE5ld0xpbmU6ICgpID0+IHtcbiAgICAgIC8vIE1hbnVhbGx5IGRldGVybWluZSB0aGUgcHJvcGVyIG5ldyBsaW5lIHN0cmluZyBiYXNlZCBvbiB0aGUgcGFzc2VkIGNvbXBpbGVyXG4gICAgICAvLyBvcHRpb25zLiBUaGVyZSBpcyBubyBwdWJsaWMgVHlwZVNjcmlwdCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgIC8vIG5ldyBsaW5lIHN0cmluZy4gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI5NTgxXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5ld0xpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5uZXdMaW5lID09PSB0cy5OZXdMaW5lS2luZC5MaW5lRmVlZCA/ICdcXG4nIDogJ1xcclxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHMuc3lzLm5ld0xpbmU7XG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwb3J0RXJyb3JzQW5kRXhpdChcbiAgICBhbGxEaWFnbm9zdGljczogRGlhZ25vc3RpY3MsIG9wdGlvbnM/OiBhcGkuQ29tcGlsZXJPcHRpb25zLFxuICAgIGNvbnNvbGVFcnJvcjogKHM6IHN0cmluZykgPT4gdm9pZCA9IGNvbnNvbGUuZXJyb3IpOiBudW1iZXIge1xuICBjb25zdCBlcnJvcnNBbmRXYXJuaW5ncyA9IGZpbHRlckVycm9yc0FuZFdhcm5pbmdzKGFsbERpYWdub3N0aWNzKTtcbiAgcHJpbnREaWFnbm9zdGljcyhlcnJvcnNBbmRXYXJuaW5ncywgb3B0aW9ucywgY29uc29sZUVycm9yKTtcbiAgcmV0dXJuIGV4aXRDb2RlRnJvbVJlc3VsdChhbGxEaWFnbm9zdGljcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXRjaE1vZGUoXG4gICAgcHJvamVjdDogc3RyaW5nLCBvcHRpb25zOiBhcGkuQ29tcGlsZXJPcHRpb25zLCBjb25zb2xlRXJyb3I6IChzOiBzdHJpbmcpID0+IHZvaWQpIHtcbiAgcmV0dXJuIHBlcmZvcm1XYXRjaENvbXBpbGF0aW9uKGNyZWF0ZVBlcmZvcm1XYXRjaEhvc3QocHJvamVjdCwgZGlhZ25vc3RpY3MgPT4ge1xuICAgIHByaW50RGlhZ25vc3RpY3MoZGlhZ25vc3RpY3MsIG9wdGlvbnMsIGNvbnNvbGVFcnJvcik7XG4gIH0sIG9wdGlvbnMsIG9wdGlvbnMgPT4gY3JlYXRlRW1pdENhbGxiYWNrKG9wdGlvbnMpKSk7XG59XG5cbmZ1bmN0aW9uIHByaW50RGlhZ25vc3RpY3MoXG4gICAgZGlhZ25vc3RpY3M6IFJlYWRvbmx5QXJyYXk8dHMuRGlhZ25vc3RpY3xhcGkuRGlhZ25vc3RpYz4sXG4gICAgb3B0aW9uczogYXBpLkNvbXBpbGVyT3B0aW9uc3x1bmRlZmluZWQsIGNvbnNvbGVFcnJvcjogKHM6IHN0cmluZykgPT4gdm9pZCk6IHZvaWQge1xuICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZvcm1hdEhvc3QgPSBnZXRGb3JtYXREaWFnbm9zdGljc0hvc3Qob3B0aW9ucyk7XG4gIGNvbnNvbGVFcnJvcihmb3JtYXREaWFnbm9zdGljcyhkaWFnbm9zdGljcywgZm9ybWF0SG9zdCkpO1xufVxuXG4vLyBDTEkgZW50cnkgcG9pbnRcbmlmIChyZXF1aXJlLm1haW4gPT09IG1vZHVsZSkge1xuICBwcm9jZXNzLnRpdGxlID0gJ0FuZ3VsYXIgQ29tcGlsZXIgKG5nYyknO1xuICBjb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuICAvLyBXZSBhcmUgcnVubmluZyB0aGUgcmVhbCBjb21waWxlciBzbyBydW4gYWdhaW5zdCB0aGUgcmVhbCBmaWxlLXN5c3RlbVxuICBzZXRGaWxlU3lzdGVtKG5ldyBOb2RlSlNGaWxlU3lzdGVtKCkpO1xuICBwcm9jZXNzLmV4aXRDb2RlID0gbWFpbihhcmdzKTtcbn1cbiJdfQ==